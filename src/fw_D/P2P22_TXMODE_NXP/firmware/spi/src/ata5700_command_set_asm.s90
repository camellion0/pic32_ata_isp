/* *ASM************************************************************************
  Use of this software is subject to Atmel's Software License Agreement.
-------------------------------------------------------------------------------
  $URL: http://svnservulm.corp.atmel.com/svn/CDB/Apps/SW_Lib/Car_Access/CARS_GEN2/ATAB5702A/Branches/P2P22_TXMODE_NXP/firmware/spi/src/ata5700_command_set_asm.s90 $
  $LastChangedRevision: 328482 $
  $LastChangedDate: 2015-07-22 13:17:23 -0600 (Wed, 22 Jul 2015) $
  $LastChangedBy: grueter $
-------------------------------------------------------------------------------
  Project:      ATA5700
  Target MCU:   ATA5700
  Compiler:     IAR Assembler for AVR 6.3.18.0
-------------------------------------------------------------------------------

******************************************************************************
* Copyright 2011, Atmel Automotive GmbH                                       *
*                                                                             *
* This software is owned by the Atmel Automotive GmbH                         *
* and is protected by and subject to worldwide patent protection.             *
* Atmel hereby grants to licensee a personal,                                 *
* non-exclusive, non-transferable license to copy, use, modify, create        *
* derivative works of, and compile the Atmel Source Code and derivative       *
* works for the sole purpose of creating custom software in support of        *
* licensee product to be used only in conjunction with a Atmel integrated     *
* circuit as specified in the applicable agreement. Any reproduction,         *
* modification, translation, compilation, or representation of this           *
* software except as specified above is prohibited without the express        *
* written permission of Atmel.                                                *
*                                                                             *
* Disclaimer: ATMEL MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,         *
* WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
* Atmel reserves the right to make changes without further notice to the      *
* materials described herein. Atmel does not assume any liability arising     *
* out of the application or use of any product or circuit described herein.   *
* Atmel does not authorize its products for use as critical components in     *
* life-support systems where a malfunction or failure may reasonably be       *
* expected to result in significant injury to the user. The inclusion of      *
* Atmel products in a life-support systems application implies that the       *
* manufacturer assumes all risk of such use and in doing so indemnifies       *
* Atmel against all charges.                                                  *
*                                                                             *
* Use may be limited by and subject to the applicable Atmel software          *
* license agreement.                                                          *
*******************************************************************************/
/* \file ata5700_command_set_asm.s90
*/
    NAME ata5700_command_set_asm

    PUBLIC ATA_interrupt0Handler_ASM
    PUBLIC ATA_spiSerialTransferCompleteHandler_ASM

    EXTERN g_sAta5700_flash
    EXTERN extReq
    EXTERN events
    EXTERN g_sEventHandling_flash

    EXTERN sleepModeConfig
    EXTERN romVersion
    EXTERN calib
    EXTERN trxConf

    EXTERN ATA_systemSetEventPin_flash_ASM

    EXTERN ATA_spiRxBufferDisableInt_ASM
    EXTERN ATA_spiRxBufferEnd_ASM

    EXTERN ATA_spiTxBufferDisableInt_ASM
    EXTERN ATA_spiTxBufferEnd_ASM

    EXTERN g_sSpiConfig
    
    ; LF variables (Flash)
    EXTERN g_sLfRxIdShadowValues_flash
    EXTERN g_sLfRxEotShadowValues_flash
    EXTERN g_bLfRxEotShadowIndex_flash
    EXTERN g_bLfRxEmTransponderModeEnabled_flash
    
    ; Timer 3 (ROM)
    EXTERN g_sTimer3

    ; Timer 3 (Flash)
    EXTERN g_bTimer3CaptureIndex_flash
    EXTERN ATA_timer3CaptureEvents_flash_ASM
    
    ; Timer 4 (ROM)
    EXTERN g_sTimer4
    
    ; Timer 4 (Flash)
    EXTERN g_bTimer4CaptureIndex_flash
    EXTERN ATA_timer4CaptureEvents_flash_ASM
 
    EXTERN g_bTpEmTransponderStateIndex_flash 
/* ===========================================================================*/
/*   INCLUDES                                                                 */
/* ===========================================================================*/
#include "regs.inc"
#include "globals.h"
#include "calib.h"
#include "spi.h"
#include "ata5700_command_set.h"
#include "../../../firmware/timer3/src/timer3.h"
#include "../../../firmware/timer3/src/timer3_flash.h"
#include "../../../firmware/timer4/src/timer4.h"
#include "../../../firmware/timer4/src/timer4_flash.h"
#include "../../../firmware/tp/src/tp_flash.h"

/* ===========================================================================*/
/*  DEFINES                                                                   */
/* ===========================================================================*/
MAXCOMMANDS                     EQU 0x2F

SYSVER_EEP_START_ADDR           EQU 0x0280
SYSVER_EEP_LF_CONT_START_ADDR   EQU 0x0340

TX_DIR                  EQU 1
RX_DIR                  EQU 0
/* ===========================================================================*/
/*   Modul Globals                                                            */
/* ===========================================================================*/
/* ===========================================================================*/
/*   Macros                                                                   */
/* ===========================================================================*/

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>SET_RXTX_DFC_DIR</b>
    This macro stores the actual access direction of the DFC to the T-Bit and sets
    the desired access direction (via dir parameter).

    \param address: Direction of access. (TX_DIR or RX_DIR)

    \return none
*/
/* ----------------------------------------------------------------------------- */
SET_RXTX_DFC_DIR MACRO     dir
    LDI     R31 , dir
    LDS     R30 , DFC
    BST     R30 , DFDRA        ; Store the actual direction of the D FIFO in the T-bit

    CBR     R30 , BM_DFDRA     ; DFC.DRA = 0

    SBRC    R31 , BIT_0        ; if (dir == RX_DIR)
                               ; else
    SBR     R30 , BM_DFDRA     ;     DFC.DRA = 1

    STS     DFC , R30
    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>RESTORE_RXTX_DFC_DIR</b>
    This macro restores the former (stored in the T-Bit) access direction of the D Fifo.

    \param address: none

    \return none
*/
/* ----------------------------------------------------------------------------- */
RESTORE_RXTX_DFC_DIR MACRO
    LDS     R30 , DFC
    BLD     R30 , DFDRA        ; restore the former direction of the D FIFO
    STS     DFC , R30
    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>SET_RXTX_SFC_DIR</b>
    This macro stores the actual access direction of the SFC to the T-Bit and sets
    the desired access direction (via dir parameter).

    \param address: Direction of access. (TX_DIR or RX_DIR)

    \return none
*/
/* ----------------------------------------------------------------------------- */
SET_RXTX_SFC_DIR MACRO     dir
    LDI     R31 , dir
    LDS     R30 , SFC
    BST     R30 , SFDRA        ; Store the actual direction of the S FIFO in the T-bit

    CBR     R30 , BM_SFDRA     ; SFC.DRA = 0

    SBRC    R31 , BIT_0         ; if (dir == RX_DIR)
                                ; else
    SBR     R30 , BM_SFDRA     ;    SFC.DRA = 1

    STS     SFC , R30
    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>RESTORE_RXTX_DFC_DIR</b>
    This macro restores the former (stored in the T-Bit) access direction of the S Fifo.

    \param address: none

    \return none
*/
/* ----------------------------------------------------------------------------- */
RESTORE_RXTX_SFC_DIR MACRO
    LDS     R30 , SFC
    BLD     R30 , SFDRA        ; restore the former direction of the S FIFO
    STS     SFC , R30
    ENDM
/* stopDoxyExclude */


/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>SET_RXTX_PHFC_DIR</b>
    This macro stores the actual access direction of the PHFD to the T-Bit and sets
    the desired access direction (via dir parameter).

    \param address: Direction of access. (TX_DIR or RX_DIR)

    \return none
*/
/* ----------------------------------------------------------------------------- */
SET_RXTX_PHFC_DIR MACRO     dir
 
    ; Set Direct Access Direction for Protocol Handler FIFO
    LDI     R31 , dir
    LDS     R30 , PHFC
    BST     R30 , DRA        ; Store the actual direction of the PH FIFO in the T-bit

    CBR     R30 , BM_DRA     ; PHFC.DRA = 0

    SBRC    R31 , BIT_0      ; if (dir == RX_DIR)
                             ; else
    SBR     R30 , BM_DFDRA   ;     PHFC.DRA = 1

    STS     PHFC , R30

    ; Switch clock from PH clock to AVR clock
    LDI     R31 , 0x01
    STS     PHCKCR , R31

SET_RXTX_PHFC_DIR_LOOP_CLOCK_SWITCH_PH_TO_AVR:
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x01
    BRNE    SET_RXTX_PHFC_DIR_LOOP_CLOCK_SWITCH_PH_TO_AVR

    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>RESTORE_RXTX_PHFC_DIR</b>
    This macro restores the former (stored in the T-Bit) access direction of the
    PH Fifo.

    \param address: none

    \return none
*/
/* ----------------------------------------------------------------------------- */
RESTORE_RXTX_PHFC_DIR MACRO
    
    ; Set Direct Access Direction for Protocol Handler FIFO
    LDS     R30 , PHFC
    BLD     R30 , DRA        ; restore the former direction of the PH FIFO
    STS     PHFC , R30
    
    ; Switch clock from AVR clock back to PH clock
    LDI     R31 , 0x00
    STS     PHCKCR , R31

RESTORE_RXTX_PHFC_DIR_LOOP_CLOCK_SWITCH_AVR_TO_PH:
    ; Wait until clock switch has been completed    
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x00
    BRNE    RESTORE_RXTX_PHFC_DIR_LOOP_CLOCK_SWITCH_AVR_TO_PH

    ENDM
/* stopDoxyExclude */

/* ===========================================================================*/
/*   IMPLEMENTATION                                                           */
/* ===========================================================================*/
/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/**  \brief <b>JMPTABLE</b>
    used for SPI commands. Backward compatibility to SigmaX is ensured by inserting
    wholes ("INVALIDCMD") for SPI commands not used for Primus2P.

    \return none
*/
/* ----------------------------------------------------------------------------- */
RSEG CODE:CODE:ROOT(7)
; ****************
; *  JMP  Table  *
; ****************
JMPTABLE:                                       ; Must be aligned to 0xXX00-0xXXXX
    RJMP    SPI_READY                           ; in order to be able to not include
    RJMP    INVALIDCMD                          ; the carry into the calculation of
    RJMP    READ_FILL_LEVEL_TX_BUFFER           ; ijmp to the jump table.
    RJMP    READ_FILL_LEVEL_RSSI_BUFFER         ; 0x03
    RJMP    INVALIDCMD                          ; 0x04
    RJMP    READ_RSSI_BUFFER                    ; 0x05
    RJMP    READ_RX_BUFFER                      ; 0x06
    RJMP    WRITE_REGISTER_SRAM                 ; 0x07
    RJMP    READ_REGISTER_SRAM                  ; 0x08
    RJMP    WRITE_EEPROM                        ; 0x09
    RJMP    READ_EEPROM                         ; 0x0A
    RJMP    WRITE_TX_BUFFER                     ; 0x0B
    RJMP    WRITE_TX_PREAMBLE_BUFFER            ; 0x0C
    RJMP    SET_SYSTEM_MODE                     ; 0x0D
    RJMP    CALIBRATE_AND_CHECK                 ; 0x0E
    RJMP    PATCH_SPI                           ; 0x0F
    RJMP    INVALIDCMD                          ; 0x10
    RJMP    INVALIDCMD                          ; 0x11
    RJMP    GET_ROM_VERSION                     ; 0x12
    RJMP    GET_FLASH_VERSION                   ; 0x13
    RJMP    INVALIDCMD                          ; 0x14
    RJMP    SYSTEM_RESET                        ; 0x15
    RJMP    INVALIDCMD                          ; 0x16
    RJMP    SET_VOLTAGE_MONITOR                 ; 0x17
    RJMP    OFF_COMMAND                         ; 0x18
    RJMP    INVALIDCMD                          ; 0x19
    RJMP    INIT_SRAM_SERVICE                   ; 0x1A
    RJMP    INVALIDCMD                          ; 0x1B
    RJMP    INVALIDCMD                          ; 0x1C
    RJMP    INVALIDCMD                          ; 0x1D
    RJMP    INVALIDCMD                          ; 0x1E
    RJMP    INVALIDCMD                          ; 0x1F
    RJMP    SYSVER_SPI_LF_TP_INIT               ; 0x20    
    RJMP    SYSVER_SPI_LF_ENABLE                ; 0x21
    RJMP    SYSVER_SPI_TP_START_RX              ; 0x22
    RJMP    SYSVER_SPI_TP_START_TX              ; 0x23
    RJMP    SYSVER_SPI_PH_FIFO_READ_FL          ; 0x24
    RJMP    SYSVER_SPI_PH_FIFO_READ_DATA        ; 0x25
    RJMP    SYSVER_SPI_PH_FIFO_WRITE_DATA       ; 0x26
    RJMP    SYSVER_SPI_LF_ENABLE_CONT           ; 0x27
    RJMP    SYSVER_SPI_LF_RSSI_MEAS             ; 0x28
    RJMP    SYSVER_SPI_LF_TRANSP_ENABLE         ; 0x29
    RJMP    SYSVER_SPI_SWITCH_AVR_TO_MRC        ; 0x2A
    RJMP    SYSVER_SPI_LFRX_RFTX_TP             ; 0x2B
    RJMP    SYSVER_SPI_START_EM_MODE            ; 0x2C
    RJMP    SYSVER_SPI_REMOTE_KEYLESS_ENTRY     ; 0x2D
    RJMP    MODIFY_VAR_REGISTER_SRAM            ; 0x2E
    RJMP    INVALIDCMD                          ; 0x2F must be value of MAXCOMMANDS!! (last command in JMP table)

/* stopDoxyExclude */


/* ----------------------------------------------------------------------------- */
/**  \brief <b>ATA_spiSerialTransferCompleteHandler_ASM</b>
    triggers each complete Byte transmission/reception

    \return none
*/
/* ----------------------------------------------------------------------------- */
#pragma vector=SPI_STC_vect
RSEG CODE:CODE:ROOT(1)
ATA_spiSerialTransferCompleteHandler_ASM:
    PUSH    R25
    PUSH    R30
    PUSH    R31

    IN      R31 , SREG
    PUSH    R31

    ; ------------------------------------------
    IN      R25 , SPDR

    CPI     R25 , MAXCOMMANDS
    BRLO    VALIDSPICMD
    RJMP    INVALIDCMD

VALIDSPICMD:
    LDI     R30 , low(JMPTABLE/2)
    ADD     R30 , R25
    LDI     R31 , high(JMPTABLE/2)
    IJMP
    ; ------------------------------------------

SPI_READY:
    IN      R25 , SPCR  ; disable SPI interrupt
    ANDI    R25 , ~(BM_SPIE)
    OUT     SPCR , R25

    POP     R31
    OUT     SREG , R31

    POP     R31
    POP     R30
    POP     R25
    RETI


/* startDoxyExclude */

/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>READ_FILL_LEVEL_TX_BUFFER</b>
    This spi command returns the fill level of the Tx buffer (D-Fifo).

    \return none
*/
/* ---------------------------------------------------------------------------*/
READ_FILL_LEVEL_TX_BUFFER:        ; ID= 0x02
; ------------------------------------------------------------------------------

    LDS     R31 , DFL       ;   SPDR = DFL
    OUT     SPDR , R31

    RJMP    SPI_READY

/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>READ_FILL_LEVEL_RSSI_BUFFER</b>
    The command ReadFillLevelRssiBuffer returns the fill level of the Rssi Buffer
    of the S-Fifo (Rx-Direction).

   \return none
*/
/* ---------------------------------------------------------------------------*/
READ_FILL_LEVEL_RSSI_BUFFER:      ; ID= 0x03
; ------------------------------------------------------------------------------

    LDS     R31 , SFL       ;   SPDR = SFL
    OUT     SPDR , R31

    RJMP    SPI_READY

/* ----------------------------------------------------------------------------- */
/**  \brief SPI Command <b>READ_RSSI_BUFFER</b>
    The command ReadRssiBuffer returns the content of the Rssi buffer which is
    implemented in the S-Fifo on Rx side.

    \return none
*/
; /* ----------------------------------------------------------------------------- */

READ_RSSI_BUFFER:                 ; ID= 0x05
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_RSSI_BUFFER_LEN , 1

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
READ_RSSI_BUFFER_LEN:
; ------------------------------------------------------------------------------
    ; write first BYTE to spi
    SET_RXTX_SFC_DIR RX_DIR
    LDS     R31 , SFD
    OUT     SPDR , R31
    RESTORE_RXTX_SFC_DIR

    ; read length BYTE
    IN      R30 , SPDR
    DEC     R30         ; first byte is already written
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30
    ENABLE_SPITXBUFFER READ_RSSI_BUFFER_DATA , 0
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
READ_RSSI_BUFFER_DATA:
; ------------------------------------------------------------------------------

    SET_RXTX_SFC_DIR RX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

    CPI     R30 , 0
    BREQ    BREAK_READ_RSSI_BUFFER_DATA

LOOP_READ_RSSI_BUFFER_DATA:                 ; do{

    LDS     R31 , SFD                       ;   Load Data from SFD
    OUT     SPDR , R31

    DEC     R30                             ;   DataToWrite(R30)--;
    BREQ    BREAK_READ_RSSI_BUFFER_DATA     ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    SBRS    R31 , TFL2                      ; }
    BRNE    LOOP_READ_RSSI_BUFFER_DATA      ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30     ; Store remaining DataToWrite(R30)
    LDI     R30 , (BM_STIE)                 ; Set next IRQ when FillLevel = 0
                                            ; & EnableIRQ

BREAK_READ_RSSI_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_SFC_DIR

    JMP     ATA_spiTxBufferEnd_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>READ_RX_BUFFER</b>
    The command ReadRxBuffer returns the content of the Rx buffer which is
    implemented in the D-Fifo.

  \return none
*/
/* ----------------------------------------------------------------------------- */
READ_RX_BUFFER:                   ; ID= 0x06
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_RX_BUFFER_LEN, 1

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
READ_RX_BUFFER_LEN:
; ------------------------------------------------------------------------------
    SET_RXTX_DFC_DIR RX_DIR
    ; write first BYTE to spi
    LDS     R31 , DFD
    OUT     SPDR , R31

    RESTORE_RXTX_DFC_DIR

    ; read length BYTE
    IN      R30 , SPDR
    DEC     R30             ; first byte is already written
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30
    ENABLE_SPITXBUFFER READ_RX_BUFFER_DATA , 0
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
READ_RX_BUFFER_DATA:
; ------------------------------------------------------------------------------
    SET_RXTX_DFC_DIR RX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

    CPI     R30 , 0
    BREQ    BREAK_READ_RX_BUFFER_DATA

LOOP_READ_RX_BUFFER_DATA:                   ; do{
    LDS     R31 , DFD                       ;   Load Data from DFD
    OUT     SPDR , R31

    DEC     R30                             ;   DataToWrite(R30)--;
    BREQ    BREAK_READ_RX_BUFFER_DATA       ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    SBRS    R31 , TFL2                      ; }
    BRNE    LOOP_READ_RX_BUFFER_DATA        ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30     ; Store remaining DataToWrite(R30)

    LDI     R30 , (BM_STIE)                 ; Set next IRQ when FillLevel = 0
                                            ; & EnableIRQ
BREAK_READ_RX_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_DFC_DIR

    JMP     ATA_spiTxBufferEnd_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>WRITE_REGISTER_SRAM</b>
    The spi command WriteSramRegister writtes x data bytes to the given sram /
    register address.

   \return none
*/
/* ----------------------------------------------------------------------------- */
WRITE_REGISTER_SRAM:              ; ID= 0x07
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_REGISTER_SRAM_LENGTH , 3

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_REGISTER_SRAM_LENGTH:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR              ; length
    STS     g_sSpiConfig + SPICONFIG_LENGTH, R30
    IN      R31 , SPDR              ; addr_high
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1, R31
    IN      R31 , SPDR              ; addr_low
    STS     g_sSpiConfig + SPICONFIG_PADDRESS, R31


    ; --> The following functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    ; SFIR = BM_SRIE | num_bytes -> generate interrupt if num_bytes bytes in rx fifo
    CPI     R30 , RX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_WRITE_REGISTER_SRAM_LENGTH
    LDI     R30 , RX_BUFFER_FIFO_SIZE

SKIP_WRITE_REGISTER_SRAM_LENGTH:
    ORI     R30 , (BM_SRIE)

    STS     SFIR , R30

    LDI     R30 , low(WRITE_REGISTER_SRAM_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(WRITE_REGISTER_SRAM_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
WRITE_REGISTER_SRAM_DATA:
; ------------------------------------------------------------------------------
    PUSH    R25
    PUSH    R24

    LDS     R24 , g_sSpiConfig + SPICONFIG_LENGTH
    LDS     R31 , g_sSpiConfig + SPICONFIG_PADDRESS + 1
    LDS     R30 , g_sSpiConfig + SPICONFIG_PADDRESS

LOOP_WRITE_REGISTER_SRAM_DATA:                  ; do{
    IN      R25 , SPDR                          ;   Load Data from SPI
    ST      Z+ , R25

    DEC     R24                                 ;   DataToWrite(R24)--;
    BREQ    BREAK_WRITE_REGISTER_SRAM_DATA      ; if( DataToWrite(R24) == 0 ) break;

    LDS     R25 , SFFR
    ANDI    R25 , (BM_RFL2|BM_RFL1|BM_RFL0)     ; }
    BRNE    LOOP_WRITE_REGISTER_SRAM_DATA       ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R24         ; Store remaing DataToWrite(R24)
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1 , R31    ; Store actual address pointer
    STS     g_sSpiConfig + SPICONFIG_PADDRESS , R30

    CPI     R24 , RX_BUFFER_FIFO_SIZE           ; if( DataToWrite(R24) > RX_BUFFER_FIFO_SIZE )
    BRLO    SKIP_WRITE_REGISTER_SRAM_DATA       ;    SFIR = RX_BUFFER_FIFO_SIZE
    LDI     R24 , RX_BUFFER_FIFO_SIZE           ; else
SKIP_WRITE_REGISTER_SRAM_DATA:                  ;    SFIR = DataToWrite(R24)
    ORI     R24 , (BM_SRIE)                     ; SFIR |= BM_SRIE -> Enable IRQ

BREAK_WRITE_REGISTER_SRAM_DATA:
    STS     SFIR , R24

    POP     R24
    POP     R25
    JMP     ATA_spiRxBufferEnd_ASM


/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>READ_REGISTER_SRAM</b>
    The spi command ReadRegisterSram reads x data bytes from the given sram /
    register address.

     \return none
*/
/* ----------------------------------------------------------------------------- */
READ_REGISTER_SRAM:               ; ID= 0x08
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_REGISTER_SRAM_LENGTH, 3

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
READ_REGISTER_SRAM_LENGTH:
; ------------------------------------------------------------------------------
    PUSH    R25

    IN      R30 , SPDR              ; length
    DEC     R30                            ; the first byte is written to the spi direct in this routine!
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    IN      R31, SPDR              ; addr_high
    IN      R30 , SPDR              ; addr_low

    LD      R25 , Z+                            ;   Write Data to SPI and increment write address
    OUT     SPDR , R25

    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1 , R31
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 0 , R30


    ENABLE_SPITXBUFFER READ_REGISTER_SRAM_DATA , 0

    POP     R25

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
READ_REGISTER_SRAM_DATA:
; ------------------------------------------------------------------------------
    PUSH    R25
    PUSH    R24

    LDS     R24 , g_sSpiConfig + SPICONFIG_LENGTH
    LDS     R30 , g_sSpiConfig + SPICONFIG_PADDRESS
    LDS     R31 , g_sSpiConfig + SPICONFIG_PADDRESS + 1

    CPI     R24 , 0
    BREQ    BREAK_READ_REGISTER_SRAM_DATA


LOOP_READ_REGISTER_SRAM_DATA:                   ; do{
    LD      R25 , Z+                            ;   Write Data to SPI
    OUT     SPDR , R25

    DEC     R24                                 ;   DataToWrite(R24)--;
    BREQ    BREAK_READ_REGISTER_SRAM_DATA       ;   if( DataToWrite(R24) == 0 ) break;

    LDS     R25 , SFFR
    SBRS    R25 , TFL2                          ; }
    BRNE    LOOP_READ_REGISTER_SRAM_DATA        ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R24         ; Store remaining DataToWrite(R24)
    STS     g_sSpiConfig + SPICONFIG_PADDRESS , R30    ; Store actual address pointer
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1 , R31

    LDI     R24 , (BM_STIE)                     ; Enable IRQ -> No attention to the data amount, always set the fifo level to 0.
                                                ; A next IRQ is only necessary if there are more Bytes to be written as sizeof Fifo.
                                                ; If there less Bytes to be written, the filling process will be stopped when the count
                                                ; of DataToWrite == 0.

BREAK_READ_REGISTER_SRAM_DATA:
    STS     SFIR , R24

    POP     R24
    POP     R25
    JMP     ATA_spiTxBufferEnd_ASM



/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>WRITE_EEPROM</b>
    The spi command WriteEeprom writtes one data byte to the given eeprom address.

    \return none
*/
/* ----------------------------------------------------------------------------- */
WRITE_EEPROM:                     ; ID= 0x09
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_EEPROM_DATA , 3
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_EEPROM_DATA:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR      ; addr_high
    OUT     EEARH ,R30      ; write EEPRom addrH

    IN      R30 , SPDR      ; addr_low
    OUT     EEARL ,R30      ; write EEPRom addrL

    IN      R30 , SPDR      ; EEProm data
    OUT     EEDR ,R30       ; write EEProm data register

    SBI     EECR , EEMWE
    SBI     EECR , EEWE
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>READ_EEPROM</b>
    The spi command ReadEeprom reads one data byte to the given eeprom address.
    \return none
*/
/* ----------------------------------------------------------------------------- */
READ_EEPROM:                      ; ID= 0x0A
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_EEPROM_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
EEPROM_BUSY:                   ; eep is busy
; ------------------------------------------------------------------------------
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
READ_EEPROM_DATA:
; ------------------------------------------------------------------------------
    SBIC    EECR , EEWE         ; check if busy
    RJMP    EEPROM_BUSY

    IN      R30 , SPDR          ; addr_high
    OUT     EEARH , R30         ; read EEPRom addrH

    IN      R30 , SPDR          ; addr_low
    OUT     EEARL , R30         ; write EEProm addrL

    SBI     EECR , EERE
    IN      R30 , EEDR          ; read EEProm content

    OUT     SPDR , R30

    JMP     ATA_spiRxBufferDisableInt_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>WRITE_TX_BUFFER</b>
    The spi command WriteTxBuffer writes n data bytes into the Tx Buffer of the D-Fifo.
    The count of data bytes is given in the length parameter. Access direction is switched
    automatically and restored to the origin value at the end of the command (direction
    temporarily stored in the T-Bit).

    \return none
*/
/* ----------------------------------------------------------------------------- */
WRITE_TX_BUFFER:                  ; ID= 0x0B
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_TX_BUFFER_LENGTH , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_TX_BUFFER_LENGTH:
; ------------------------------------------------------------------------------
    ; read length BYTE
    IN      R30 , SPDR
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    ; --> The follwoing functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    CPI     R30 , TX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_WRITE_TX_BUFFER_LENGTH
    LDI     R30 , TX_BUFFER_FIFO_SIZE

SKIP_WRITE_TX_BUFFER_LENGTH:
    ORI     R30 , (BM_SRIE)
    STS     SFIR , R30

    LDI     R30 , low(WRITE_TX_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(WRITE_TX_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
WRITE_TX_BUFFER_DATA:
; ------------------------------------------------------------------------------

    SET_RXTX_DFC_DIR TX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

LOOP_WRITE_TX_BUFFER_DATA:                      ; do{
    IN      R31 , SPDR                          ;   Load Data to DFD
    STS     DFD , R31

    DEC     R30                                 ;   DataToWrite(R30)--;
    BREQ    BREAK_WRITE_TX_BUFFER_DATA          ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    ANDI    R31 , (BM_RFL2|BM_RFL1|BM_RFL0)     ; }
    BRNE    LOOP_WRITE_TX_BUFFER_DATA           ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30         ; Store remaining DataToWrite(R30)

    CPI     R30 , TX_BUFFER_FIFO_SIZE           ; if( DataToWrite(R30) > TX_BUFFER_FIFO_SIZE )
    BRLT    SKIP_WRITE_TX_BUFFER_DATA           ;   SFIR = TX_BUFFER_FIFO_SIZE;
    LDI     R30 , TX_BUFFER_FIFO_SIZE           ; else
                                                ;   SFIR = DataToWrite(R30);
SKIP_WRITE_TX_BUFFER_DATA:
    ORI     R30 , (BM_SRIE)                     ; SFIR |= BM_SIRE -> Enable IRQ

BREAK_WRITE_TX_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_DFC_DIR

    JMP     ATA_spiRxBufferEnd_ASM


/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>WRITE_TX_PREAMBLE_BUFFER</b>
    The spi command WriteTxPreambleBuffer writes n data bytes into the Tx Buffer of the S-Fifo.
    The count of data bytes is given in the length parameter. Access direction is switched
    automatically and restored to the origin value at the end of the command (direction
    temporarily stored in the T-Bit).

    \return none
*/
/* ---------------------------------------------------------------------------*/
WRITE_TX_PREAMBLE_BUFFER:         ; ID= 0x0C
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_TX_PREAMBLE_BUFFER_LENGTH , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_TX_PREAMBLE_BUFFER_LENGTH:
; ------------------------------------------------------------------------------
    ; read length BYTE
    IN      R30 , SPDR
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    ; --> The follwoing functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    CPI     R30 , TX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_WRITE_TX_PREAMBLE_BUFFER_LENGTH
    LDI     R30 , TX_BUFFER_FIFO_SIZE

SKIP_WRITE_TX_PREAMBLE_BUFFER_LENGTH:
    ORI     R30 , (BM_SRIE)
    STS     SFIR , R30

    LDI     R30 , low(WRITE_TX_PREAMBLE_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(WRITE_TX_PREAMBLE_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM


; ------------------------------------------------------------------------------
WRITE_TX_PREAMBLE_BUFFER_DATA:
; ------------------------------------------------------------------------------

    SET_RXTX_SFC_DIR TX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

LOOP_WRITE_TX_PREAMBLE_BUFFER_DATA:                 ;do{
    IN      R31 , SPDR                              ;   Load Data to SFD
    STS     SFD , R31

    DEC     R30                                     ;   DataToWrite(R30)--;
    BREQ    BREAK_WRITE_TX_PREAMBLE_BUFFER_DATA     ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    ANDI    R31 , (BM_RFL2|BM_RFL1|BM_RFL0)         ; }
    BRNE    LOOP_WRITE_TX_PREAMBLE_BUFFER_DATA      ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30             ; Store remaining DataToWrite(R30)

    CPI     R30 , TX_BUFFER_FIFO_SIZE               ; if( DataToWrite(R30) > TX_BUFFER_FIFO_SIZE )
    BRLT    SKIP_WRITE_TX_PREAMBLE_BUFFER_DATA      ;   SFIR = TX_BUFFER_FIFO_SIZE
    LDI     R30 , TX_BUFFER_FIFO_SIZE               ; else
                                                    ;   SFIR = DataToWrite(R30)
SKIP_WRITE_TX_PREAMBLE_BUFFER_DATA:
    ORI     R30 , (BM_SRIE)                         ; SFIR |= BM_SRIE -> Enable IRQ

BREAK_WRITE_TX_PREAMBLE_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_SFC_DIR

    JMP     ATA_spiRxBufferEnd_ASM


/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>SET_SYSTEM_MODE</b>
    The spi command SetSystemMode writtes the systemModeConfig and serviceChannelConfig
    variable of the extReq structure.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SET_SYSTEM_MODE:                 ; ID= 0x0D
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    
    ENABLE_SPIRXBUFFER SET_SYSTEM_MODE_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
SET_SYSTEM_MODE_DATA:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR
    STS     extReq + EXT_REQ_SYSTEM_MODE_CONFIG , R30
    
    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ORI     R30 , BM_ATA5700_STATUS_UPDATE_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30

    ;Original SigmaX-Code
    ;SBI     GPIOR3 , SYS_STATUS_UPDATE

    IN      R30 , SPDR
    STS     extReq + EXT_REQ_SERVICE_CHANNEL_CONFIG , R30
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>CALIBRATE_AND_CHECK</b>
    The spi command CalibrateAndCheck writtes the tuneCheckConfig and
    serviceChannelConfig variable of the extReq structure.
    \return none
*/
/* ---------------------------------------------------------------------------*/
CALIBRATE_AND_CHECK:             ; ID= 0x0E
; ------------------------------------------------------------------------------

    ENABLE_SPIRXBUFFER CALIBRATE_AND_CHECK_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
CALIBRATE_AND_CHECK_DATA:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR
    STS     extReq + EXT_REQ_TUNE_CHECK_CONFIG , R30

    IN      R30 , SPDR
    STS     extReq + EXT_REQ_SERVICE_CHANNEL_CONFIG , R30

    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>PATCH_SPI</b>
    The Patch_Spi command is used to extend the SPI command set by the customer as follows:
    Patch_Spi jumps to the functions which is stored in patchSpi
    The parameter of Patch_Spi is located in SPDR register.
    The Patch SPI extension has no return and the customer has to finish with a jump
    to PATCH_SPI_READY (which is the same as SPIBUFRDY_DISABLERXBUFINT).

    \return none
*/
/* ---------------------------------------------------------------------------*/
PATCH_SPI:                        ; ID= 0x0F
; ------------------------------------------------------------------------------
    ENABLE_SPIRXBUFFER PATCH_SPI_DATA , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
PATCH_SPI_DATA:
; ------------------------------------------------------------------------------
    LDS     R31 , patchSpi                  ; Load addr H
    LDS     R30 , patchSpi + 1              ; Load addr L
    IJMP                                ; call pointed routine
    ;   routine has N cycles                                       41+N
    ;   routine has no return but an JMP to SPI_READY
    ;   IJMP and JMP saves 7 cycles compared to an ICALL
    ; ----Patch, IJMP to stored address [CMD,mode ]--

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>GET_ROM_VERSION</b>
    The command GetRomVersion returns the rom version.

    \return none
*/
/* ---------------------------------------------------------------------------*/
GET_ROM_VERSION:                  ; ID= 0x12
; ------------------------------------------------------------------------------
    LDI     R30 , low(romVersion)
    LDI     R31 , high(romVersion)
    LPM     R25 , Z
    OUT     SPDR , R25
    RJMP    SPI_READY

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>GET_FLASH_VERSION</b>
    The command GetFlashVersion returns the
    - Rom version
    - Flash version
    - Customer specific version

    \return none
*/
/* ---------------------------------------------------------------------------*/
GET_FLASH_VERSION:                ; ID= 0x13
; ------------------------------------------------------------------------------
    LDI     R30 , low(romVersion)
    LDI     R31 , high(romVersion)
    LPM     R25 , Z

    OUT     SPDR , R25

    ENABLE_SPIRXBUFFER GET_FLASH_VERSION_DATA , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
GET_FLASH_VERSION_DATA:
; ------------------------------------------------------------------------------
    LDI     R31 , 0xFF
    LDI     R30 , 0xF0

    PUSH    R24
    PUSH    R25
    LDI     R24 , 3

 CPYLOOPBUF:
    LPM     R25 , Z+
    OUT     SPDR , R25
    DEC     R24
    BRNE    CPYLOOPBUF

    POP     R25
    POP     R24
    JMP     ATA_spiRxBufferDisableInt_ASM


/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>SYSTEM_RESET</b>
    The SPI command System Resets configures the Watchdog and wait inside a
    endless loop until the watchdog triggers the system.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSTEM_RESET:                     ; ID= 0x15
; ------------------------------------------------------------------------------
    LDI     R31 , 0x18
    STS     WDTCR , R31
    LDI     R31 , 0x08
    STS     WDTCR , R31

ENDLESSLOOP:
    RJMP    ENDLESSLOOP        ; wait until WDT reset triggers the system

/* ===========================================================================*/
/**  \brief SPI Command <b>SET_VOLTAGE_MONITOR</b>
    The command Set_Voltage_Monitor configures the Voltage Monitor in Primus2+.

    \return none
*/
; ------------------------------------------------------------------------------
SET_VOLTAGE_MONITOR:              ; ID= 0x17
; ------------------------------------------------------------------------------
    ENABLE_SPIRXBUFFER SET_VOLTAGE_MONITOR_DATA , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
SET_VOLTAGE_MONITOR_DATA:
; ------------------------------------------------------------------------------
;TODO: Implement the same way as the API function
    IN      R31 , SPDR
    LDI     R30 , 0x00               ; disable Voltage Monitor Interrupt
    OUT     VMSR, R30
    
    ; TODO: R31 needs to be saved as it will be written to VMCR completely

    ANDI    R31 , 0x0F
    CPI     R31 , 0x00               ; 0x00 VM is disabled
    BRNE    VOLTAGE_MONITOR_ENABLED
    
    SBI     PRR0 , PRVM
    
    JMP     ATA_spiRxBufferDisableInt_ASM

VOLTAGE_MONITOR_ENABLED:
    
    CBI     PRR0 , PRVM
    
    STS     VMCR , R31             /* NOP count is based on the Voltage Monitor WCET of 1.8us and the register update time
                                       => 14 cycles (including safety margin) when AVR is running with 6 MHZ. */
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ORI     R31 , BM_VMF
    OUT     VMSR , R31
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ORI     R31 , BM_VMIM
    STS     VMCR , R31
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>OFF_COMMAND</b>
    This command sets the SigmaX in OFF Mode

    \return none
*/
/* ---------------------------------------------------------------------------*/
OFF_COMMAND:                      ; ID= 0x18
; ------------------------------------------------------------------------------

    CLR     R31
    OUT     DDRB , R31
    OUT     DDRC , R31
    OUT     DDRD , R31

    SER     R30
    OUT     PORTB , R30
    OUT     PORTC , R30
    CBI     PORTC , PORTC2
    OUT     PORTD , R30

OFF_COMMAND_WAIT_NVMBSY:
    SBIC    EECR , NVMBSY
    RJMP    OFF_COMMAND_WAIT_NVMBSY

    IN      R30, SMCR
    ORI     R30, (BM_SM2 | BM_SM0 | BM_SE)
    OUT     SMCR, R30 
    SLEEP

    RJMP    SPI_READY


/* ===========================================================================*/
/** \brief SPI Command <b>INIT_SRAM_SERVICE</b>
    The spi command Init_SRAM_Service initializes the service sramServices[sramServiceNumber]
    with the service eepService[eepromServiceNumber].

    \return none
*/
; ------------------------------------------------------------------------------
INIT_SRAM_SERVICE:               ; ID= 0x1A
; ------------------------------------------------------------------------------

    ENABLE_SPIRXBUFFER INIT_SRAM_SERVICE_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
INIT_SRAM_SERVICE_DATA:
; ------------------------------------------------------------------------------
    IN      R31 , SPDR   ; sramServiceNumber 0..1
    IN      R30 , SPDR   ; eepServiceNumber  0..2
    LSL     R30
    OR      R31 , R30
    ORI     R31 , BM_EXT_REQ_SERVICE_INIT_CONFIG_UPDATE_FLAG

    STS     extReq + EXT_REQ_SERVICE_INIT_CONFIG , R31

    JMP     ATA_spiRxBufferDisableInt_ASM


/* ---------------------------------------------------------------------------*/
/** \brief <b>INVALIDCMD</b>
    If there is a invalid CMD (CMD Id > than MAXCOMMANDS) received, the INVALIDCMD
    function is called.

    \return none
*/
/* ---------------------------------------------------------------------------*/
INVALIDCMD:
; ------------------------------------------------------------------------------
    RJMP    SPI_READY
/* stopDoxyExclude */

/* ---------------------------------------------------------------------------*/
/**  \brief <b>ATA_interrupt0Handler_ASM</b>
    triggers each time when the int0 flag is set. To ensure the synchronism of
    the sended events bytes and the copied events byte this interrupt has not
    to be interrupted by an other interrupt! (the blocking mechanism is done
    via the SREG.I).

    \return none
*/
/* ---------------------------------------------------------------------------*/
#pragma vector=INT0_vect
RSEG CODE:CODE:ROOT(1)
ATA_interrupt0Handler_ASM:
; ----Save Register contents----
    PUSH    R31
    PUSH    R30
    IN      R31 , SREG
    PUSH    R31

    SBIS    PINB , PINB4
    RJMP    SPI_SS_LOW

    ; ---- slave select is high -> end of spi command
SPI_SS_HIGH:

    LDS     R31 , SFFR
    ORI     R31 , (BM_RFC | BM_TFC)
    STS     SFFR , R31

    LDS     R31 , SFIR
    ANDI    R31 , ~(BM_SRIE | BM_STIE)
    STS     SFIR , R31

    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ORI     R30 , BM_ATA5700_STATUS_TRIGGER_MAIN_LOOP_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30
    
    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ANDI    R30 , ~BM_ATA5700_STATUS_SPI_CMD_IN_PROGRESS_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30

    RJMP    INT0_END

SPI_SS_LOW:
    ; ---- slave select is low -> beginning of spi command
    LDS     R31 , SFFR
    ORI     R31 ,(BM_RFC | BM_TFC)
    STS     SFFR , R31

    NOP    ; NOP necessary because of execution time of reseting RxFifo -> without this NOP the following OUT instruction don't work correct!

    ; --- send the actual events_system & events_events to the SPI fifo
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31

    IN      R31 , SPCR  ; enable SPI interrupt
    ORI     R31 ,(BM_SPIE)
    OUT     SPCR , R31

    ; at NSS falling edge disable sleep enable in SMCR register
    IN      R31 , SMCR
    ANDI    R31 , 0xFE
    OUT     SMCR , R31

    ; set GPIOR1 = sysStatus SPI command in progress to disable SLEEP mode during SPI commands in main loop
    
    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ORI     R30 , BM_ATA5700_STATUS_SPI_CMD_IN_PROGRESS_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30
   
INT0_END:

    POP     R31
    OUT     SREG , R31
    POP     R30
    POP     R31

    RETI


/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_LF_TP_INIT</b>
    This spi command initializes all LF and TP related registers with the 
    corresponding EEPROM settings defined at EEPROM start address 
    0x0280 (SigmaX Customer Section).

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_LF_TP_INIT:        ; ID= 0x20
; ------------------------------------------------------------------------------
    PUSH    R26
    PUSH    R27

    CLI                                         ; disable IRQs
    
    ; Start EEPROM burst read access
    LDI     R31 , low(SYSVER_EEP_START_ADDR)    
    OUT     EEARL , R31                         ; set low byte address
    LDI     R31 , high(SYSVER_EEP_START_ADDR)
    OUT     EEARH , R31                         ; set high byte address
    LDS     R31 , EECR2
    ORI     R31 , BM_EEBRE
    STS     EECR2 , R31
    
    ; Registers as laid out in document 
    ; "http://svnservulm.corp.atmel.com/svn/CDB/02_AutoRF/Primus2P/Trunk/Dev/04_test_verification/system_verification/01_Verification_testbench_concept/sw_eeprom_initialize.xlsx"

    IN      R31 , EEDR      ; EEPROM address 0x280
    OUT     PRR0 , R31
    IN      R31 , EEDR      ; EEPROM address 0x281
    OUT     PRR1 , R31
    IN      R31 , EEDR      ; EEPROM address 0x282
    OUT     PRR2 , R31
    IN      R31 , EEDR      ; EEPROM address 0x283
    OUT     LFCR0 , R31
    IN      R31 , EEDR      ; EEPROM address 0x284
    OUT     LFCR1 , R31
    IN      R31 , EEDR      ; EEPROM address 0x285
    OUT     LFCR2 , R31
    IN      R31 , EEDR      ; EEPROM address 0x286
    STS     LFIMR , R31
    IN      R31 , EEDR      ; EEPROM address 0x287
    ; OUT     LFFR , R31
    IN      R31 , EEDR      ; EEPROM address 0x288
    STS     LFDSR1 , R31
    IN      R31 , EEDR      ; EEPROM address 0x289
    STS     LFDSR2 , R31
    IN      R31 , EEDR      ; EEPROM address 0x28A
    STS     LFDSR3 , R31
    IN      R31 , EEDR      ; EEPROM address 0x28B
    STS     LFDSR4 , R31
    IN      R31 , EEDR      ; EEPROM address 0x28C
    STS     LFDSR5 , R31
    IN      R31 , EEDR      ; EEPROM address 0x28D
    STS     LFDSR6 , R31
    IN      R31 , EEDR      ; EEPROM address 0x28E
    STS     LFDSR7 , R31
    IN      R31 , EEDR      ; EEPROM address 0x28F
    STS     LFDSR8 , R31
    IN      R31 , EEDR      ; EEPROM address 0x290
    STS     LFDSR9 , R31
    IN      R31 , EEDR      ; EEPROM address 0x291
    STS     LFDSR10 , R31
    IN      R31 , EEDR      ; EEPROM address 0x292
    STS     LFDSR11 , R31
    IN      R31 , EEDR      ; EEPROM address 0x293
    ; STS     LFDSRR , R31
    IN      R31 , EEDR      ; EEPROM address 0x294
    STS     LFSYSY3 , R31
    IN      R31 , EEDR      ; EEPROM address 0x295
    STS     LFSYSY2 , R31
    IN      R31 , EEDR      ; EEPROM address 0x296
    STS     LFSYSY1 , R31
    IN      R31 , EEDR      ; EEPROM address 0x297
    STS     LFSYSY0 , R31
    IN      R31 , EEDR      ; EEPROM address 0x298
    STS     LFSYLE , R31
    IN      R31 , EEDR      ; EEPROM address 0x299
    STS     LFSTOP , R31
    IN      R31 , EEDR      ; EEPROM address 0x29A
    STS     LFQC1 , R31
    IN      R31 , EEDR      ; EEPROM address 0x29B
    STS     LFQC2 , R31
    IN      R31 , EEDR      ; EEPROM address 0x29C
    STS     LFQC3 , R31
    IN      R31 , EEDR      ; EEPROM address 0x29D
    ; LDI     R30 , 0x80
    ; STS     LFCPR , R30
    ; STS     LFCPR , R31
    
    ; LF RSSI Control
    IN      R31, EEDR       ; EEPROM address 0x29E
    STS     LFRSCR , R31
    
    ; LF RSSI Mode
    IN      R31, EEDR       ; EEPROM address 0x29F
    STS     LFRSMR, R31
    
    ; LF RSSI Setting_1
    IN      R31, EEDR       ; EEPROM address 0x2A0
    STS     LFRSS1R , R31
    
    ; LF RSSI Setting_1
    IN      R31, EEDR       ; EEPROM address 0x2A1
    STS     LFRSS2R , R31
    
    ; Reset LF RSSI internal port address
    LDI     R31, 0x40
    STS     LFRSISR , R31
    
    ; Write eight values from 
    IN      R31 , EEDR      ; EEPROM address 0x2A2
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A3
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A4
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A5
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A6
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A7
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A8
    STS     LFRSISR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2A9
    STS     LFRSISR , R31

    ; Switch clock from PH clock to AVR clock
    LDI     R31 , 0x01
    STS     PHCKCR , R31

SYSVER_SPI_LF_TP_INIT_LOOP_CLOCK_SWITCH_PH_TO_AVR:
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x01
    BRNE    SYSVER_SPI_LF_TP_INIT_LOOP_CLOCK_SWITCH_PH_TO_AVR

    ; CRC Init
    IN      R31 , EEDR      ; EEPROM address 0x2AA
    STS     PHCRPH , R31
    IN      R31 , EEDR      ; EEPROM address 0x2AB
    STS     PHCRPL , R31
    IN      R31 , EEDR      ; EEPROM address 0x2AC
    ; STS     PHCSRH , R31
    IN      R31 , EEDR      ; EEPROM address 0x2AD
    ; STS     PHCSRL , R31
    IN      R31 , EEDR      ; EEPROM address 0x2AE
    STS     PHCSTH , R31
    IN      R31 , EEDR      ; EEPROM address 0x2AF
    STS     PHCSTL , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B0
    STS     PHCRCR , R31
    
    ; FIFO Init
    IN      R31 , EEDR      ; EEPROM address 0x2B1
    STS     PHFC , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B2
    STS     PHFI , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B3
    ; STS     PHFL , R31
    
    ; LF init
    IN      R31 , EEDR      ; EEPROM address 0x2B4
    STS     PHID03 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B5
    STS     PHID02 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B6
    STS     PHID01 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B7
    STS     PHID00 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B8
    STS     PHID0L , R31
    IN      R31 , EEDR      ; EEPROM address 0x2B9
    STS     PHID13 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2BA
    STS     PHID12 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2BB
    STS     PHID11 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2BC
    STS     PHID10 , R31
    IN      R31 , EEDR      ; EEPROM address 0x2BD
    STS     PHID1L , R31
    IN      R31 , EEDR      ; EEPROM address 0x2BE
    STS     PHIDFR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2BF
    STS     PHTBLR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C0
    STS     PHDFR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C1
    ; STS     PHBCRR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C2
    ; STS     PHFR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C3
    STS     PHIMR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C4
    STS     PHTCMR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C5
    STS     PHTCOR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C6
    STS     PHTEMR , R31
    
    ; TP init
    IN      R31 , EEDR      ; EEPROM address 0x2C7
    STS     TPIMR , R31
    IN      R31 , EEDR      ; EEPROM address 0x2C8
    STS     TPCR1, R31
    IN      R31 , EEDR      ; EEPROM address 0x2C9
    OUT     TPCR2, R31
    IN      R31 , EEDR      ; EEPROM address 0x2CA
    STS     TPCR3, R31
    IN      R31 , EEDR      ; EEPROM address 0x2CB
    STS     TPCR4, R31
    IN      R31 , EEDR      ; EEPROM address 0x2CC
    STS     TPCR5, R31
    IN      R31 , EEDR      ; EEPROM address 0x2CD
    STS     TPDCR1, R31
    IN      R31 , EEDR      ; EEPROM address 0x2CE
    STS     TPDCR2, R31
    IN      R31 , EEDR      ; EEPROM address 0x2CF
    STS     TPDCR3, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D0
    STS     TPDCR4, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D1
    STS     TPDCR5, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D2
    STS     TPECMR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D3
    STS     TPECR1, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D4
    STS     TPECR2, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D5
    STS     TPECR3, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D6
    STS     TPECR4, R31
    
    ;
    ; Timer 0 configuration
    ;
    IN      R31 , EEDR      ; EEPROM address 0x2D7
    STS     T0CR, R31
    
    ;
    ; Timer 1 configuration
    ;
    IN      R31 , EEDR      ; EEPROM address 0x2D8
    OUT     T1CR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2D9
    STS     T1COR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2DA
    STS     T1IMR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2DB
    STS     T1MR, R31

    ;
    ; Timer 2 configuration
    ;
    IN      R31 , EEDR      ; EEPROM address 0x2DC
    OUT     T2CR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2DD
    STS     T2COR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2DE
    STS     T2IMR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2DF
    STS     T2MR, R31
    
    ;
    ; Timer 3 configuration
    ;
    IN      R31 , EEDR      ; EEPROM address 0x2E0
    OUT     T3CR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E1
    STS     T3CORL, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E2
    STS     T3CORH, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E3
    STS     T3IMR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E4
    STS     T3MRA, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E5
    STS     T3MRB, R31

    ;
    ; Init Timer 3 variable (capture interrupt)
    ;
    LDI     R31 , low(ATA_timer3CaptureEvents_flash_ASM/2)
    STS     g_sTimer3 + TMR3CONFIG_CAPISR, R31
    
    LDI     R31 , high(ATA_timer3CaptureEvents_flash_ASM/2)
    STS     g_sTimer3 + TMR3CONFIG_CAPISR + 1, R31

    ;
    ; Timer 4 configuration
    ;
    IN      R31 , EEDR      ; EEPROM address 0x2E6
    OUT     T4CR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E7
    STS     T4CORL, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E8
    STS     T4CORH, R31
    IN      R31 , EEDR      ; EEPROM address 0x2E9
    STS     T4IMR, R31
    IN      R31 , EEDR      ; EEPROM address 0x2EA
    STS     T4MRA, R31
    IN      R31 , EEDR      ; EEPROM address 0x2EB
    STS     T4MRB, R31

    ;
    ; Init Timer 4 variable (capture interrupt)
    ;
    LDI     R31 , low(ATA_timer4CaptureEvents_flash_ASM/2)
    STS     g_sTimer4 + TMR4CONFIG_CAPISR, R31
    
    LDI     R31 , high(ATA_timer4CaptureEvents_flash_ASM/2)
    STS     g_sTimer4 + TMR4CONFIG_CAPISR + 1, R31

    ; Switch clock from AVR clock back to PH clock
    LDI     R31 , 0x00
    STS     PHCKCR , R31

SYSVER_SPI_LF_TP_INIT_LOOP_CLOCK_SWITCH_AVR_TO_PH:
    ; Wait until clock switch has been completed    
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x00
    BRNE    SYSVER_SPI_LF_TP_INIT_LOOP_CLOCK_SWITCH_AVR_TO_PH
    
    
    ; Configure EEPROM address to point to LF continuous receive data
    LDI     R31 , low(SYSVER_EEP_LF_CONT_START_ADDR)    
    OUT     EEARL , R31                         ; set low byte address
    LDI     R31 , high(SYSVER_EEP_LF_CONT_START_ADDR)
    OUT     EEARH , R31                         ; set high byte address
    LDS     R31 , EECR2
    ORI     R31 , BM_EEBRE
    STS     EECR2 , R31


    ; Load ID0 shadow register values for future use
    LDI     R30, 0x10
    LDI     R26 , low(g_sLfRxIdShadowValues_flash)
    LDI     R27 , high(g_sLfRxIdShadowValues_flash)
    
ID0_SHADOW_LOOP_START:
    IN      R31 , EEDR      ; EEPROM address 0x340
    ST      X+ , R31
    DEC     R30
    BRNE    ID0_SHADOW_LOOP_START


    ; Load ID0 shadow register values for future use (0x04 * 0x10)
    LDI     R30, 0x40
    LDI     R26 , low(g_sLfRxEotShadowValues_flash)
    LDI     R27 , high(g_sLfRxEotShadowValues_flash)
    
EOT_SHADOW_LOOP_START:
    IN      R31 , EEDR      ; EEPROM address 0x350
    ST      X+ , R31
    DEC     R30
    BRNE    EOT_SHADOW_LOOP_START
    
    ; Reset continuous LF receive mode status variables
    CLR     R31
    STS     g_bLfRxEotShadowIndex_flash, R31

    ; Disable EEPROM burst read mode (due to higher current consumption)
    LDI     R31 , 0x00
    STS     EECR2 , R31

    SEI                                         ; enable IRQs

    POP     R27
    POP     R26
    
    RJMP    SPI_READY


/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_LF_ENABLE</b>
    This spi command enables the 3D LF Receiver.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_LF_ENABLE:        ; ID= 0x21
; ------------------------------------------------------------------------------

    IN  R31 , LFCR1
    ORI R31 , BM_LFRE
    OUT LFCR1 , R31

    RJMP    SPI_READY
    
    
/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_TP_START_RX</b>
    This SPI command starts the TP Rx corresponding 
    corresponding EEPROM settings defined at EEPROM start address 
    0x0280 (SigmaX Customer Section).

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_TP_START_RX:        ; ID= 0x22
; ------------------------------------------------------------------------------
       
    ; Set Direct Read Access to AVR read, respectively Protocol Handler write
    LDS  R31 , PHFC
    ANDI R31 , ~BM_DRA
    STS PHFC , R31

    ; Start Transponder Rx
    LDS R31 , TPCR3
    ORI R31 , BM_TPRD
    STS TPCR3 , R31

    RJMP    SPI_READY
    
/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_TP_START_TX</b>
    This SPI command starts the TP Tx corresponding 
    corresponding EEPROM settings defined at EEPROM start address 
    0x0280 (SigmaX Customer Section).

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_TP_START_TX:        ; ID = 0x23
; ------------------------------------------------------------------------------

    ; Set Direct Read Access to AVR write, respectively Protocol Handler read
    LDS R31 , PHFC
    ORI R31 , BM_DRA
    STS PHFC , R31
    
    ; Start Transponder Tx
    LDS R31 , TPCR3
    ORI R31 , BM_TPTD
    STS TPCR3 , R31

    RJMP    SPI_READY


/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_PH_FIFO_READ_FL</b>
    This SPI command returns the Protocol Handler FIFO fill level.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_PH_FIFO_READ_FL:    ; ID = 0x24

; Switch clock from PH clock to AVR clock
    LDI     R31 , 0x01
    STS     PHCKCR , R31

PH_FIFO_READ_FILL_LEVEL_LOOP_CLOCK_SWITCH_PH_TO_AVR:
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x01
    BRNE    PH_FIFO_READ_FILL_LEVEL_LOOP_CLOCK_SWITCH_PH_TO_AVR
    
    LDS     R31 , PHFL       ;   SPDR = PHFL
    OUT     SPDR , R31

    ; Switch clock from AVR clock back to PH clock
    LDI     R31 , 0x00
    STS     PHCKCR , R31

PH_FIFO_READ_FILL_LEVEL_LOOP_CLOCK_SWITCH_AVR_TO_PH:
    ; Wait until clock switch has been completed    
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x03
    CPI     R31 , 0x00
    BRNE    PH_FIFO_READ_FILL_LEVEL_LOOP_CLOCK_SWITCH_AVR_TO_PH

    ; End of SPI command SYSVER_SPI_PH_FIFO_READ_FL
    RJMP    SPI_READY


/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_PH_FIFO_READ_DATA</b>
    This SPI command returns the content of the Protocol Handler FIFO.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_PH_FIFO_READ_DATA:  ; ID = 0x25

    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER PH_FIFO_READ_BUFFER_LEN, 1

    ; End of SPI command SYSVER_SPI_PH_FIFO_READ_DATA
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
PH_FIFO_READ_BUFFER_LEN:
; ------------------------------------------------------------------------------
    SET_RXTX_PHFC_DIR RX_DIR
    
    ; write first BYTE to spi
    LDS     R31 , PHFD
    OUT     SPDR , R31

    RESTORE_RXTX_PHFC_DIR

    ; read length BYTE
    IN      R30 , SPDR
    DEC     R30             ; first byte is already written
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30
    ENABLE_SPITXBUFFER PH_FIFO_READ_BUFFER_DATA , 0
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
PH_FIFO_READ_BUFFER_DATA:
; ------------------------------------------------------------------------------
    ;SET_RXTX_PHFC_DIR RX_DIR (just a comment for the next lines)
    
    ; Set Direct Access Direction for Protocol Handler FIFO
    LDS     R30 , PHFC
    BST     R30 , DRA        ; Store the actual direction of the PH FIFO in the T-bit
    CBR     R30 , BM_DRA     ; PHFC.DRA = 0
    STS     PHFC , R30

    ; Switch clock from PH clock to AVR clock
    LDI     R31 , 0x01
    STS     PHCKCR , R31

PH_FIFO_READ_BUFFER_DATA_LOOP_CLOCK_SWITCH_PH_TO_AVR:
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x01
    BRNE    PH_FIFO_READ_BUFFER_DATA_LOOP_CLOCK_SWITCH_PH_TO_AVR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

    CPI     R30 , 0
    BREQ    BREAK_PH_FIFO_READ_BUFFER_DATA

LOOP_PH_FIFO_READ_BUFFER_DATA:              ; do{
    LDS     R31 , PHFD                      ;   Load Data from PHFD
    OUT     SPDR , R31

    DEC     R30                             ;   DataToWrite(R30)--;
    BREQ    BREAK_PH_FIFO_READ_BUFFER_DATA  ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    SBRS    R31 , TFL2                      ; }
    BRNE    LOOP_PH_FIFO_READ_BUFFER_DATA   ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30     ; Store remaining DataToWrite(R30)

    LDI     R30 , (BM_STIE)                 ; Set next IRQ when FillLevel = 0
                                            ; & EnableIRQ
BREAK_PH_FIFO_READ_BUFFER_DATA:
    STS     SFIR , R30

    ; RESTORE_RXTX_PHFC_DIR (just a comment for the next lines)
    
    ; Set Direct Access Direction for Protocol Handler FIFO
    LDS     R30 , PHFC
    BLD     R30 , DRA        ; restore the former direction of the PH FIFO
    STS     PHFC , R30
    
    ; Switch clock from AVR clock back to PH clock
    LDI     R31 , 0x00
    STS     PHCKCR , R31

PH_FIFO_READ_BUFFER_DATA_LOOP_CLOCK_SWITCH_AVR_TO_PH:
    ; Wait until clock switch has been completed    
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x03
    CPI     R31 , 0x00
    BRNE    PH_FIFO_READ_BUFFER_DATA_LOOP_CLOCK_SWITCH_AVR_TO_PH

    JMP     ATA_spiTxBufferEnd_ASM

/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_PH_FIFO_WRITE_DATA</b>
    This SPI command writes the given bytes into the Protocol Handler FIFO.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_PH_FIFO_WRITE_DATA: ; ID = 0x26

    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER PH_FIFO_WRITE_BUFFER_LENGTH , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
PH_FIFO_WRITE_BUFFER_LENGTH:
; ------------------------------------------------------------------------------
    ; read length BYTE
    IN      R30 , SPDR
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    ; --> The following functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    CPI     R30 , TX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_PH_FIFO_WRITE_BUFFER_LENGTH
    LDI     R30 , TX_BUFFER_FIFO_SIZE

SKIP_PH_FIFO_WRITE_BUFFER_LENGTH:
    ORI     R30 , (BM_SRIE)
    STS     SFIR , R30

    LDI     R30 , low(PH_FIFO_WRITE_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(PH_FIFO_WRITE_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
PH_FIFO_WRITE_BUFFER_DATA:
; ------------------------------------------------------------------------------

    ;SET_RXTX_PHFC_DIR TX_DIR (just a comment for the next lines)

    ; Set Direct Access Direction for Protocol Handler FIFO
    LDS     R30 , PHFC
    BST     R30 , DRA        ; Store the actual direction of the PH FIFO in the T-bit
    SBR     R30 , BM_DRA     ; PHFC.DRA = 1
    STS     PHFC , R30

    ; Switch clock from PH clock to AVR clock
    LDI     R31 , 0x01
    STS     PHCKCR , R31

PH_FIFO_WRITE_BUFFER_DATA_LOOP_CLOCK_SWITCH_PH_TO_AVR:
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x01
    CPI     R31 , 0x01
    BRNE    PH_FIFO_WRITE_BUFFER_DATA_LOOP_CLOCK_SWITCH_PH_TO_AVR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

PH_FIFO_LOOP_WRITE_BUFFER_DATA:                 ; do{
    IN      R31 , SPDR                          ;   Load Data to DFD
    STS     PHFD , R31

    DEC     R30                                 ;   DataToWrite(R30)--;
    BREQ    PH_FIFO_BREAK_WRITE_BUFFER_DATA     ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    ANDI    R31 , (BM_RFL2|BM_RFL1|BM_RFL0)     ; }
    BRNE    PH_FIFO_LOOP_WRITE_BUFFER_DATA      ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30         ; Store remaining DataToWrite(R30)

    CPI     R30 , TX_BUFFER_FIFO_SIZE           ; if( DataToWrite(R30) > TX_BUFFER_FIFO_SIZE )
    BRLT    PH_FIFO_SKIP_WRITE_BUFFER_DATA      ;     SFIR = TX_BUFFER_FIFO_SIZE;
    LDI     R30 , TX_BUFFER_FIFO_SIZE           ; else
                                                ;   SFIR = DataToWrite(R30);
PH_FIFO_SKIP_WRITE_BUFFER_DATA:
    ORI     R30 , (BM_SRIE)                     ; SFIR |= BM_SIRE -> Enable IRQ

PH_FIFO_BREAK_WRITE_BUFFER_DATA:
    STS     SFIR , R30

    ; RESTORE_RXTX_PHFC_DIR (just a comment for the next lines)

    ; Set Direct Access Direction for Protocol Handler FIFO
    LDS     R30 , PHFC
    BLD     R30 , DRA        ; restore the former direction of the PH FIFO
    STS     PHFC , R30

    ; Switch clock from AVR clock back to PH clock
    LDI     R31 , 0x00
    STS     PHCKCR , R31

PH_FIFO_WRITE_BUFFER_DATA_LOOP_CLOCK_SWITCH_AVR_TO_PH:
    ; Wait until clock switch has been completed    
    LDS     R31 , PHCKSR
    ANDI    R31 , 0x03
    CPI     R31 , 0x00
    BRNE    PH_FIFO_WRITE_BUFFER_DATA_LOOP_CLOCK_SWITCH_AVR_TO_PH

    JMP     ATA_spiRxBufferEnd_ASM

/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_LF_ENABLE_CONT</b>
    This SPI command starts the LF continuous receive mode.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_LF_ENABLE_CONT:        ; ID = 0x27
; ------------------------------------------------------------------------------
    ; Enable continuous LF receive mode
    LDS  R31 , PHCKCR
    ORI  R31 , BM_CSM
    STS  PHCKCR , R31
    
    ; Reset continuous LF receive mode status variables again to allow for
    ; multiple LF continuous sequences to be carried out without having to
    ; reinitialize all registers
    CLR     R31
    STS     g_bLfRxEotShadowIndex_flash, R31
    
    ; Start LF Receiver
    IN   R31 , LFCR1
    ORI  R31 , BM_LFRE
    OUT  LFCR1 , R31

    RJMP SPI_READY


/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_LF_RSSI_MEAS</b>
    This SPI command starts a LF RSSI measurement based on the 2 additional
    bytes received.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_LF_RSSI_MEAS:  ; ID = 0x28
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER LF_RSSI_MEAS_START, 3

    ; End of SPI command SYSVER_SPI_PH_FIFO_READ_DATA
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
LF_RSSI_MEAS_START:
; ------------------------------------------------------------------------------

    ; read incoming LFCR1 byte and store it to the corresponding register
    IN      R30 , SPDR
    OUT     LFCR1, R30

    ; read incoming LFRSMR byte and store it to the corresponding register
    IN      R30 , SPDR
    STS     LFRSMR, R30

    ; read incoming LFRSCR byte and store it to the corresponding register
    IN      R30 , SPDR
    STS     LFRSCR, R30

    ; End of SPI command SYSVER_SPI_PH_FIFO_READ_DATA
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_LF_TRANSP_ENABLE</b>
    This SPI command starts a LF transparent reception sequence with Timer 3
    and/or Timer 4 used as capture timers (includes reset of both timers).
    
    \return none
*/
; ------------------------------------------------------------------------------
SYSVER_SPI_LF_TRANSP_ENABLE:    ; ID = 0x29
; ------------------------------------------------------------------------------

    ; Reset continuous LF receive mode status variables again to allow for
    ; multiple LF continuous sequences to be carried out without having to
    ; reinitialize all registers
    CLR     R31
    STS     g_bTimer3CaptureIndex_flash, R31
    STS     g_bTimer4CaptureIndex_flash, R31
    
    ; Disable Timer 3
    IN   R31, T3CR
    ANDI R31, ~BM_T3ENA
    OUT  T3CR, R31
    
    ; Reset Timer 3
    IN   R31, T3CR
    ORI  R31, BM_T3RES
    OUT  T3CR, R31
    
    ; Enable Timer 3
    IN   R31, T3CR
    ORI  R31, BM_T3ENA
    OUT  T3CR, R31

    ; Disable Timer 4
    IN   R31, T4CR
    ANDI R31, ~BM_T4ENA
    OUT  T4CR, R31
    
    ; Reset Timer 4
    IN   R31, T4CR
    ORI  R31, BM_T4RES
    OUT  T4CR, R31
    
    ; Enable Timer 4
    IN   R31, T4CR
    ORI  R31, BM_T4ENA
    OUT  T4CR, R31

    ; Start LF Receiver
    IN   R31 , LFCR1
    ORI  R31 , BM_LFRE
    OUT  LFCR1 , R31

    ; End of SPI command SYSVER_SPI_LF_TRANSP_ENABLE
    RJMP    SPI_READY


/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_SWITCH_AVR_TO_MRC</b>
    This SPI command switches the AVR core clock to MRC

    \return none
*/
; ------------------------------------------------------------------------------
SYSVER_SPI_SWITCH_AVR_TO_MRC:    ; ID = 0x2A
; ------------------------------------------------------------------------------

    ; Set AVR core to MRC
    CLI
    LDS     R30, CMCR
    SEI

    ANDI    R30 , (BM_CMCCE | BM_CMONEN)
    LDI     R31 , BM_CMCCE

    CLI
    STS     CMCR , R31
    STS     CMCR , R30
    SEI

    ; set divider to 1
    LDI     R30 , BM_CLPCE
    LDI     R31 , BM_CLTPS0

    CLI
    STS     CLPR , R30
    STS     CLPR , R31
    SEI

    ; End of SPI command SYSVER_SPI_SWITCH_AVR_TO_MRC
    RJMP    SPI_READY

/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_LFRX_RFTX_TP</b>
    This SPI command starts a LF initialization to receive LF telegrams based
    on the transponder protocol.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSVER_SPI_LFRX_RFTX_TP:  ; ID = 0x2B
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    
    ENABLE_SPIRXBUFFER LFRX_RFTX_TP, 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
LFRX_RFTX_TP:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR
    STS     extReq + EXT_REQ_LFRCRFTX_CONFIG, R30

    JMP     ATA_spiRxBufferDisableInt_ASM



/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_ENABLE_EM_MODE</b>
    This SPI command shall enable EM Transponder Mode

    \return none
*/
; ------------------------------------------------------------------------------
SYSVER_SPI_START_EM_MODE:    ; ID = 0x2C
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    
    ENABLE_SPIRXBUFFER START_EM_MODE, 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
START_EM_MODE:
; ------------------------------------------------------------------------------
    ; Set internal variable to EM mode selected
    IN      R30 , SPDR
    STS     extReq + EXT_REQ_TP_EM_MODE_CONFIG, R30

    ; Set EM mode in TPCR1 if enabled via SPI (TPCR1 |= BM_TPMODE)
    TST     R30
    BREQ    START_EM_MODE_DISABLE
    LDS     R30 , TPCR1
    ORI     R30 , 0x80
    STS     TPCR1 , R30
    JMP     START_EM_MODE_CONTINUE
    
START_EM_MODE_DISABLE:
    LDS     R30 , TPCR1
    ANDI    R30 , 0x7F
    STS     TPCR1 , R30

START_EM_MODE_CONTINUE:
    ; Set em status variable to init
    LDI     R30 , EM_MODE_STATE_INIT
    STS     g_bTpEmTransponderStateIndex_flash , R30

    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/**  \brief System Verification SPI Command <b>SYSVER_SPI_REMOTE_KEYLESS_ENTRY</b>
    This SPI command trigger one Remote Keyless Entry sequence using the
    Rolling Code Counter algorithm

    \return none
*/
; ------------------------------------------------------------------------------
SYSVER_SPI_REMOTE_KEYLESS_ENTRY:    ; ID = 0x2D
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    
    ENABLE_SPIRXBUFFER REMOTE_KEYLESS_ENTRY, 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
REMOTE_KEYLESS_ENTRY:
; ------------------------------------------------------------------------------
    ; Set internal variable to Remote Keyless Entry
    LDI     R30 , 0x01
    STS     extReq + EXT_REQ_RF_REMOTE_KEYLESS_ENTRY, R30

    ; Set selected key for Rolling Code Counter
    IN      R30 , SPDR
    STS     g_sRfRemoteKeylessEntryConf + 0, R30
    
    ; Set command ID for Rolling Code Counter
    IN      R30 , SPDR
    STS     g_sRfRemoteKeylessEntryConf + 1, R30

    JMP     ATA_spiRxBufferDisableInt_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>MODIFY_VAR_REGISTER_SRAM</b>
    writes the given data byte to the given SRAM/Register address starting from
    the given start bit and bit length indication

   \return none
*/
/* ----------------------------------------------------------------------------- */
MODIFY_VAR_REGISTER_SRAM:              ; ID= 0x2E
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER MODIFY_VAR_REGISTER_SRAM_DATA , RX_BUFFER_FIFO_SIZE

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
MODIFY_VAR_REGISTER_SRAM_DATA:
; ------------------------------------------------------------------------------
    PUSH    R25     ; Start and end bit mask
    PUSH    R24     ; Copy of start and end bit / Spare register
    PUSH    R23     ; Bit mask for start bit
    PUSH    R22     ; Bit mask for end bit / Original value from SRAM/Register

    ; Bit mask start bit
    LDI     R23, 0xFF

    ; Read data from SPI RX FIFO (4 bytes of SPI command payload)
    IN      R31 , SPDR              ; addr_high
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1, R31
    IN      R30 , SPDR              ; addr_low
    STS     g_sSpiConfig + SPICONFIG_PADDRESS, R31
    IN      R25 , SPDR              ; bit start (low nibble) and bit end (high nibble)
    IN      R22 , SPDR              ; Get data byte
    
    ; Compute bit frame to be modified from given bit start and end position 
    MOV     R24, R25
    ANDI    R25, 0x07               ; Start bit position range goes from [0-7]
    BREQ    SKIP_MODIFY_VAR_REGISTER_SRAM_DATA_START_BIT
    
MODIFY_VAR_REGISTER_SRAM_DATA_START_BIT:
    LSL     R23                     ; Shift start bit mask
    LSL     R22                     ; Shift data byte
    DEC     R25                     ; Decrement number of remaining shifts
    BRNE    MODIFY_VAR_REGISTER_SRAM_DATA_START_BIT

SKIP_MODIFY_VAR_REGISTER_SRAM_DATA_START_BIT:
    ; Prepare end bit mask computation
    SWAP    R24
    ANDI    R24, 0x07
    LDI     R25, 0x07
    SUB     R25, R24

    ; End bit mask
    LDI     R24, 0xFF

    TST     R25
    BREQ    SKIP_MODIFY_VAR_REGISTER_SRAM_DATA_END_BIT
    
MODIFY_VAR_REGISTER_SRAM_DATA_END_BIT:
    LSR     R24
    DEC     R25                     ; Decrement number of remaining shifts
    BRNE    MODIFY_VAR_REGISTER_SRAM_DATA_END_BIT

SKIP_MODIFY_VAR_REGISTER_SRAM_DATA_END_BIT:
    AND     R23, R24                ; Bit mask to apply data with
    AND     R22, R23                ; Data to be written to register
    LD      R24, Z                  ; Get original values from SRAM/Register
    COM     R23                     ; Reverse mask to clear bits to be modified
    AND     R24, R23                ; Set values to be modified to 0 to be able
                                    ; to use a single OR instruction

    OR      R24, R22                ; Store new data to given bit locations
    ST      Z , R24

    ; End
    POP     R22
    POP     R23
    POP     R24
    POP     R25
    JMP     ATA_spiRxBufferDisableInt_ASM

    ; End of file
    END
