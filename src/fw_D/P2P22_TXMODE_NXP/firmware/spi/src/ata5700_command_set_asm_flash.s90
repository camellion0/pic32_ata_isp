/* *ASM************************************************************************
  Use of this software is subject to Atmel's Software License Agreement.
-------------------------------------------------------------------------------
  $URL: http://svnservulm.corp.atmel.com/svn/CDB/02_AutoRF/Primus2pSW/Branches/VB_PRIMUS2P_ROM_2.0/firmware/spi/src/ata5700_command_set_asm_flash.s90 $
  $LastChangedRevision: 288679 $
  $LastChangedDate: 2014-11-28 14:56:41 +0100 (Fr, 28 Nov 2014) $
  $LastChangedBy: florian.schweidler $
-------------------------------------------------------------------------------
  Project:      ATA5700
  Target MCU:   ATA5700
  Compiler:     IAR Assembler for AVR 6.30.1
-------------------------------------------------------------------------------

******************************************************************************
* Copyright 2011, Atmel Automotive GmbH                                       *
*                                                                             *
* This software is owned by the Atmel Automotive GmbH                         *
* and is protected by and subject to worldwide patent protection.             *
* Atmel hereby grants to licensee a personal,                                 *
* non-exclusive, non-transferable license to copy, use, modify, create        *
* derivative works of, and compile the Atmel Source Code and derivative       *
* works for the sole purpose of creating custom software in support of        *
* licensee product to be used only in conjunction with a Atmel integrated     *
* circuit as specified in the applicable agreement. Any reproduction,         *
* modification, translation, compilation, or representation of this           *
* software except as specified above is prohibited without the express        *
* written permission of Atmel.                                                *
*                                                                             *
* Disclaimer: ATMEL MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,         *
* WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
* Atmel reserves the right to make changes without further notice to the      *
* materials described herein. Atmel does not assume any liability arising     *
* out of the application or use of any product or circuit described herein.   *
* Atmel does not authorize its products for use as critical components in     *
* life-support systems where a malfunction or failure may reasonably be       *
* expected to result in significant injury to the user. The inclusion of      *
* Atmel products in a life-support systems application implies that the       *
* manufacturer assumes all risk of such use and in doing so indemnifies       *
* Atmel against all charges.                                                  *
*                                                                             *
* Use may be limited by and subject to the applicable Atmel software          *
* license agreement.                                                          *
*******************************************************************************/
/* \file ata5700_command_set_asm.s90
*/
    NAME ata5700_command_set_asm

    PUBLIC ATA_interrupt0Handler_ASM
    PUBLIC ATA_spiSerialTransferCompleteHandler_ASM

    EXTERN g_sAta5700_flash
    EXTERN extReq

    EXTERN romVersion

    EXTERN ATA_spiRxBufferDisableInt_ASM
    EXTERN ATA_spiRxBufferEnd_ASM

    EXTERN ATA_spiTxBufferDisableInt_ASM
    EXTERN ATA_spiTxBufferEnd_ASM

    EXTERN g_sSpiConfig
    
/* ===========================================================================*/
/*   INCLUDES                                                                 */
/* ===========================================================================*/
#include "regs.inc"
#include "globals.h"
#include "spi.h"
#include "ata5700_command_set_flash.h"
#include "../../../firmware/tp/src/tp_flash.h"

/* ===========================================================================*/
/*  DEFINES                                                                   */
/* ===========================================================================*/
MAXCOMMANDS                     EQU 0x1B

TX_DIR                  EQU 1
RX_DIR                  EQU 0
/* ===========================================================================*/
/*   Modul Globals                                                            */
/* ===========================================================================*/
/* ===========================================================================*/
/*   Macros                                                                   */
/* ===========================================================================*/

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>SET_RXTX_DFC_DIR</b>
    This macro stores the actual access direction of the DFC to the T-Bit and sets
    the desired access direction (via dir parameter).

    \param address: Direction of access. (TX_DIR or RX_DIR)

    \return none
*/
/* ----------------------------------------------------------------------------- */
SET_RXTX_DFC_DIR MACRO     dir
    LDI     R31 , dir
    LDS     R30 , DFC
    BST     R30 , DFDRA        ; Store the actual direction of the D FIFO in the T-bit

    CBR     R30 , BM_DFDRA     ; DFC.DRA = 0

    SBRC    R31 , BIT_0        ; if (dir == RX_DIR)
                               ; else
    SBR     R30 , BM_DFDRA     ;     DFC.DRA = 1

    STS     DFC , R30
    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>RESTORE_RXTX_DFC_DIR</b>
    This macro restores the former (stored in the T-Bit) access direction of the D Fifo.

    \param address: none

    \return none
*/
/* ----------------------------------------------------------------------------- */
RESTORE_RXTX_DFC_DIR MACRO
    LDS     R30 , DFC
    BLD     R30 , DFDRA        ; restore the former direction of the D FIFO
    STS     DFC , R30
    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>SET_RXTX_SFC_DIR</b>
    This macro stores the actual access direction of the SFC to the T-Bit and sets
    the desired access direction (via dir parameter).

    \param address: Direction of access. (TX_DIR or RX_DIR)

    \return none
*/
/* ----------------------------------------------------------------------------- */
SET_RXTX_SFC_DIR MACRO     dir
    LDI     R31 , dir
    LDS     R30 , SFC
    BST     R30 , SFDRA        ; Store the actual direction of the S FIFO in the T-bit

    CBR     R30 , BM_SFDRA     ; SFC.DRA = 0

    SBRC    R31 , BIT_0         ; if (dir == RX_DIR)
                                ; else
    SBR     R30 , BM_SFDRA     ;    SFC.DRA = 1

    STS     SFC , R30
    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>RESTORE_RXTX_DFC_DIR</b>
    This macro restores the former (stored in the T-Bit) access direction of the S Fifo.

    \param address: none

    \return none
*/
/* ----------------------------------------------------------------------------- */
RESTORE_RXTX_SFC_DIR MACRO
    LDS     R30 , SFC
    BLD     R30 , SFDRA        ; restore the former direction of the S FIFO
    STS     SFC , R30
    ENDM
/* stopDoxyExclude */


/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>SET_RXTX_LDFC_DIR</b>
    This macro stores the actual access direction of the LDFD to the T-Bit and sets
    the desired access direction (via dir parameter).

    \param address: Direction of access. (TX_DIR or RX_DIR)

    \return none
*/
/* ----------------------------------------------------------------------------- */
SET_RXTX_LDFC_DIR MACRO     dir     
    ; Switch clock from PH clock to AVR clock
     LDI     R31 , BM_FIFSCSW   
     STS     LDFCKSW , R31
     
SET_RXTX_LDFC_DIR_LOOP_CLOCK_SWITCH_PH_TO_AVR:
    LDS     R31 , LDFCKSW
    SBRS    R31 , FIFO_SW
    RJMP    SET_RXTX_LDFC_DIR_LOOP_CLOCK_SWITCH_PH_TO_AVR

    ENDM
/* stopDoxyExclude */

/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/** \brief <b>RESTORE_RXTX_LDFC_DIR</b>
    This macro restores the former (stored in the T-Bit) access direction of the
    PH Fifo.

    \param address: none

    \return none
*/
/* ----------------------------------------------------------------------------- */
RESTORE_RXTX_LDFC_DIR MACRO
    
   
    ; Switch clock from AVR clock back to PH clock
    LDI     R31 , 0x00    
    STS     LDFCKSW , R31

RESTORE_RXTX_LDFC_DIR_LOOP_CLOCK_SWITCH_AVR_TO_PH:
    ; Wait until clock switch has been completed    
    LDS     R31 , LDFCKSW
    SBRC    R31 , FIFO_SW
    RJMP    RESTORE_RXTX_LDFC_DIR_LOOP_CLOCK_SWITCH_AVR_TO_PH

    ENDM
/* stopDoxyExclude */

/* ===========================================================================*/
/*   IMPLEMENTATION                                                           */
/* ===========================================================================*/
/* startDoxyExclude */
/* ----------------------------------------------------------------------------- */
/**  \brief <b>JMPTABLE</b>
    used for SPI commands. Backward compatibility to SigmaX is ensured by inserting
    wholes ("INVALIDCMD") for SPI commands not used for Primus2P.

    \return none
*/
/* ----------------------------------------------------------------------------- */
RSEG CODE:CODE:ROOT(7)
; ****************
; *  JMP  Table  *
; ****************
JMPTABLE:                                       ; Must be aligned to 0xXX00-0xXXXX
    RJMP    SPI_READY                           ; in order to be able to not include
    RJMP    INVALIDCMD                          ; the carry into the calculation of
    RJMP    READ_FILL_LEVEL_TX_BUFFER           ; ijmp to the jump table.
    RJMP    READ_FILL_LEVEL_RSSI_BUFFER         ; 0x03
    RJMP    INVALIDCMD                          ; 0x04
    RJMP    READ_RSSI_BUFFER                    ; 0x05
    RJMP    READ_RX_BUFFER                      ; 0x06
    RJMP    WRITE_REGISTER_SRAM                 ; 0x07
    RJMP    READ_REGISTER_SRAM                  ; 0x08
    RJMP    WRITE_EEPROM                        ; 0x09
    RJMP    READ_EEPROM                         ; 0x0A
    RJMP    WRITE_TX_BUFFER                     ; 0x0B
    RJMP    WRITE_TX_PREAMBLE_BUFFER            ; 0x0C
    RJMP    SET_SYSTEM_MODE                     ; 0x0D
    RJMP    CALIBRATE_AND_CHECK                 ; 0x0E
    RJMP    PATCH_SPI                           ; 0x0F
    RJMP    INVALIDCMD                          ; 0x10
    RJMP    INVALIDCMD                          ; 0x11
    RJMP    GET_ROM_VERSION                     ; 0x12
    RJMP    GET_FLASH_VERSION                   ; 0x13
    RJMP    INVALIDCMD                          ; 0x14
    RJMP    SYSTEM_RESET                        ; 0x15
    RJMP    INVALIDCMD                          ; 0x16
    RJMP    SET_VOLTAGE_MONITOR                 ; 0x17
    RJMP    OFF_COMMAND                         ; 0x18
    RJMP    INVALIDCMD                          ; 0x19
    RJMP    INIT_SRAM_SERVICE                   ; 0x1A
    RJMP    INVALIDCMD                          ; 0x1B must be value of MAXCOMMANDS!! (last command in JMP table)

/* stopDoxyExclude */


/* ----------------------------------------------------------------------------- */
/**  \brief <b>ATA_spiSerialTransferCompleteHandler_ASM</b>
    triggers each complete Byte transmission/reception

    \return none
*/
/* ----------------------------------------------------------------------------- */
#pragma vector=SPI_STC_vect
RSEG CODE:CODE:ROOT(1)
ATA_spiSerialTransferCompleteHandler_ASM:
    PUSH    R25
    PUSH    R30
    PUSH    R31

    IN      R31 , SREG
    PUSH    R31

    ; ------------------------------------------
    IN      R25 , SPDR

    CPI     R25 , MAXCOMMANDS
    BRLO    VALIDSPICMD
    RJMP    INVALIDCMD

VALIDSPICMD:
    LDI     R30 , low(JMPTABLE/2)
    ADD     R30 , R25
    LDI     R31 , high(JMPTABLE/2)
    IJMP
    ; ------------------------------------------

SPI_READY:
    IN      R25 , SPCR  ; disable SPI interrupt
    ANDI    R25 , ~(BM_SPIE)
    OUT     SPCR , R25

    POP     R31
    OUT     SREG , R31

    POP     R31
    POP     R30
    POP     R25
    RETI


/* startDoxyExclude */

/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>READ_FILL_LEVEL_TX_BUFFER</b>
    This spi command returns the fill level of the Tx buffer (D-Fifo).

    \return none
*/
/* ---------------------------------------------------------------------------*/
READ_FILL_LEVEL_TX_BUFFER:        ; ID= 0x02
; ------------------------------------------------------------------------------

    LDS     R31 , DFL       ;   SPDR = DFL
    OUT     SPDR , R31

    RJMP    SPI_READY

/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>READ_FILL_LEVEL_RSSI_BUFFER</b>
    The command ReadFillLevelRssiBuffer returns the fill level of the Rssi Buffer
    of the S-Fifo (Rx-Direction).

   \return none
*/
/* ---------------------------------------------------------------------------*/
READ_FILL_LEVEL_RSSI_BUFFER:      ; ID= 0x03
; ------------------------------------------------------------------------------

    LDS     R31 , SFL       ;   SPDR = SFL
    OUT     SPDR , R31

    RJMP    SPI_READY

/* ----------------------------------------------------------------------------- */
/**  \brief SPI Command <b>READ_RSSI_BUFFER</b>
    The command ReadRssiBuffer returns the content of the Rssi buffer which is
    implemented in the S-Fifo on Rx side.

    \return none
*/
; /* ----------------------------------------------------------------------------- */

READ_RSSI_BUFFER:                 ; ID= 0x05
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_RSSI_BUFFER_LEN , 1

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
READ_RSSI_BUFFER_LEN:
; ------------------------------------------------------------------------------
    ; write first BYTE to spi
    SET_RXTX_SFC_DIR RX_DIR
    LDS     R31 , SFD
    OUT     SPDR , R31
    RESTORE_RXTX_SFC_DIR

    ; read length BYTE
    IN      R30 , SPDR
    DEC     R30         ; first byte is already written
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30
    ENABLE_SPITXBUFFER READ_RSSI_BUFFER_DATA , 0
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
READ_RSSI_BUFFER_DATA:
; ------------------------------------------------------------------------------

    SET_RXTX_SFC_DIR RX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

    CPI     R30 , 0
    BREQ    BREAK_READ_RSSI_BUFFER_DATA

LOOP_READ_RSSI_BUFFER_DATA:                 ; do{

    LDS     R31 , SFD                       ;   Load Data from SFD
    OUT     SPDR , R31

    DEC     R30                             ;   DataToWrite(R30)--;
    BREQ    BREAK_READ_RSSI_BUFFER_DATA     ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    SBRS    R31 , TFL2                      ; }
    BRNE    LOOP_READ_RSSI_BUFFER_DATA      ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30     ; Store remaining DataToWrite(R30)
    LDI     R30 , (BM_STIE)                 ; Set next IRQ when FillLevel = 0
                                            ; & EnableIRQ

BREAK_READ_RSSI_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_SFC_DIR

    JMP     ATA_spiTxBufferEnd_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>READ_RX_BUFFER</b>
    The command ReadRxBuffer returns the content of the Rx buffer which is
    implemented in the D-Fifo.

  \return none
*/
/* ----------------------------------------------------------------------------- */
READ_RX_BUFFER:                   ; ID= 0x06
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_RX_BUFFER_LEN, 1

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
READ_RX_BUFFER_LEN:
; ------------------------------------------------------------------------------
    SET_RXTX_DFC_DIR RX_DIR
    ; write first BYTE to spi
    LDS     R31 , DFD
    OUT     SPDR , R31

    RESTORE_RXTX_DFC_DIR

    ; read length BYTE
    IN      R30 , SPDR
    DEC     R30             ; first byte is already written
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30
    ENABLE_SPITXBUFFER READ_RX_BUFFER_DATA , 0
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
READ_RX_BUFFER_DATA:
; ------------------------------------------------------------------------------
    SET_RXTX_DFC_DIR RX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

    CPI     R30 , 0
    BREQ    BREAK_READ_RX_BUFFER_DATA

LOOP_READ_RX_BUFFER_DATA:                   ; do{
    LDS     R31 , DFD                       ;   Load Data from DFD
    OUT     SPDR , R31

    DEC     R30                             ;   DataToWrite(R30)--;
    BREQ    BREAK_READ_RX_BUFFER_DATA       ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    SBRS    R31 , TFL2                      ; }
    BRNE    LOOP_READ_RX_BUFFER_DATA        ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30     ; Store remaining DataToWrite(R30)

    LDI     R30 , (BM_STIE)                 ; Set next IRQ when FillLevel = 0
                                            ; & EnableIRQ
BREAK_READ_RX_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_DFC_DIR

    JMP     ATA_spiTxBufferEnd_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>WRITE_REGISTER_SRAM</b>
    The spi command WriteSramRegister writtes x data bytes to the given sram /
    register address.

   \return none
*/
/* ----------------------------------------------------------------------------- */
WRITE_REGISTER_SRAM:              ; ID= 0x07
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_REGISTER_SRAM_LENGTH , 3

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_REGISTER_SRAM_LENGTH:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR              ; length
    STS     g_sSpiConfig + SPICONFIG_LENGTH, R30
    IN      R31 , SPDR              ; addr_high
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1, R31
    IN      R31 , SPDR              ; addr_low
    STS     g_sSpiConfig + SPICONFIG_PADDRESS, R31


    ; --> The following functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    ; SFIR = BM_SRIE | num_bytes -> generate interrupt if num_bytes bytes in rx fifo
    CPI     R30 , RX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_WRITE_REGISTER_SRAM_LENGTH
    LDI     R30 , RX_BUFFER_FIFO_SIZE

SKIP_WRITE_REGISTER_SRAM_LENGTH:
    ORI     R30 , (BM_SRIE)

    STS     SFIR , R30

    LDI     R30 , low(WRITE_REGISTER_SRAM_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(WRITE_REGISTER_SRAM_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
WRITE_REGISTER_SRAM_DATA:
; ------------------------------------------------------------------------------
    PUSH    R25
    PUSH    R24

    LDS     R24 , g_sSpiConfig + SPICONFIG_LENGTH
    LDS     R31 , g_sSpiConfig + SPICONFIG_PADDRESS + 1
    LDS     R30 , g_sSpiConfig + SPICONFIG_PADDRESS

LOOP_WRITE_REGISTER_SRAM_DATA:                  ; do{
    IN      R25 , SPDR                          ;   Load Data from SPI
    ST      Z+ , R25

    DEC     R24                                 ;   DataToWrite(R24)--;
    BREQ    BREAK_WRITE_REGISTER_SRAM_DATA      ; if( DataToWrite(R24) == 0 ) break;

    LDS     R25 , SFFR
    ANDI    R25 , (BM_RFL2|BM_RFL1|BM_RFL0)     ; }
    BRNE    LOOP_WRITE_REGISTER_SRAM_DATA       ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R24         ; Store remaing DataToWrite(R24)
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1 , R31    ; Store actual address pointer
    STS     g_sSpiConfig + SPICONFIG_PADDRESS , R30

    CPI     R24 , RX_BUFFER_FIFO_SIZE           ; if( DataToWrite(R24) > RX_BUFFER_FIFO_SIZE )
    BRLO    SKIP_WRITE_REGISTER_SRAM_DATA       ;    SFIR = RX_BUFFER_FIFO_SIZE
    LDI     R24 , RX_BUFFER_FIFO_SIZE           ; else
SKIP_WRITE_REGISTER_SRAM_DATA:                  ;    SFIR = DataToWrite(R24)
    ORI     R24 , (BM_SRIE)                     ; SFIR |= BM_SRIE -> Enable IRQ

BREAK_WRITE_REGISTER_SRAM_DATA:
    STS     SFIR , R24

    POP     R24
    POP     R25
    JMP     ATA_spiRxBufferEnd_ASM


/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>READ_REGISTER_SRAM</b>
    The spi command ReadRegisterSram reads x data bytes from the given sram /
    register address.

     \return none
*/
/* ----------------------------------------------------------------------------- */
READ_REGISTER_SRAM:               ; ID= 0x08
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_REGISTER_SRAM_LENGTH, 3

    RJMP    SPI_READY

; ------------------------------------------------------------------------------
READ_REGISTER_SRAM_LENGTH:
; ------------------------------------------------------------------------------
    PUSH    R25

    IN      R30 , SPDR              ; length
    DEC     R30                            ; the first byte is written to the spi direct in this routine!
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    IN      R31, SPDR              ; addr_high
    IN      R30 , SPDR              ; addr_low

    LD      R25 , Z+                            ;   Write Data to SPI and increment write address
    OUT     SPDR , R25

    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1 , R31
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 0 , R30


    ENABLE_SPITXBUFFER READ_REGISTER_SRAM_DATA , 0

    POP     R25

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
READ_REGISTER_SRAM_DATA:
; ------------------------------------------------------------------------------
    PUSH    R25
    PUSH    R24

    LDS     R24 , g_sSpiConfig + SPICONFIG_LENGTH
    LDS     R30 , g_sSpiConfig + SPICONFIG_PADDRESS
    LDS     R31 , g_sSpiConfig + SPICONFIG_PADDRESS + 1

    CPI     R24 , 0
    BREQ    BREAK_READ_REGISTER_SRAM_DATA


LOOP_READ_REGISTER_SRAM_DATA:                   ; do{
    LD      R25 , Z+                            ;   Write Data to SPI
    OUT     SPDR , R25

    DEC     R24                                 ;   DataToWrite(R24)--;
    BREQ    BREAK_READ_REGISTER_SRAM_DATA       ;   if( DataToWrite(R24) == 0 ) break;

    LDS     R25 , SFFR
    SBRS    R25 , TFL2                          ; }
    BRNE    LOOP_READ_REGISTER_SRAM_DATA        ; while( TxFifoLevel < 4 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R24         ; Store remaining DataToWrite(R24)
    STS     g_sSpiConfig + SPICONFIG_PADDRESS , R30    ; Store actual address pointer
    STS     g_sSpiConfig + SPICONFIG_PADDRESS + 1 , R31

    LDI     R24 , (BM_STIE)                     ; Enable IRQ -> No attention to the data amount, always set the fifo level to 0.
                                                ; A next IRQ is only necessary if there are more Bytes to be written as sizeof Fifo.
                                                ; If there less Bytes to be written, the filling process will be stopped when the count
                                                ; of DataToWrite == 0.

BREAK_READ_REGISTER_SRAM_DATA:
    STS     SFIR , R24

    POP     R24
    POP     R25
    JMP     ATA_spiTxBufferEnd_ASM



/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>WRITE_EEPROM</b>
    The spi command WriteEeprom writtes one data byte to the given eeprom address.

    \return none
*/
/* ----------------------------------------------------------------------------- */
WRITE_EEPROM:                     ; ID= 0x09
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_EEPROM_DATA , 3
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_EEPROM_DATA:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR      ; addr_high
    OUT     EEARH ,R30      ; write EEPRom addrH

    IN      R30 , SPDR      ; addr_low
    OUT     EEARL ,R30      ; write EEPRom addrL

    IN      R30 , SPDR      ; EEProm data
    OUT     EEDR ,R30       ; write EEProm data register

    SBI     EECR , EEMWE
    SBI     EECR , EEWE
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>READ_EEPROM</b>
    The spi command ReadEeprom reads one data byte to the given eeprom address.
    \return none
*/
/* ----------------------------------------------------------------------------- */
READ_EEPROM:                      ; ID= 0x0A
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER READ_EEPROM_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
EEPROM_BUSY:                   ; eep is busy
; ------------------------------------------------------------------------------
    JMP     ATA_spiRxBufferDisableInt_ASM

; ------------------------------------------------------------------------------
READ_EEPROM_DATA:
; ------------------------------------------------------------------------------
    SBIC    EECR , EEWE         ; check if busy
    RJMP    EEPROM_BUSY

    IN      R30 , SPDR          ; addr_high
    OUT     EEARH , R30         ; read EEPRom addrH

    IN      R30 , SPDR          ; addr_low
    OUT     EEARL , R30         ; write EEProm addrL

    SBI     EECR , EERE
    IN      R30 , EEDR          ; read EEProm content

    OUT     SPDR , R30

    JMP     ATA_spiRxBufferDisableInt_ASM

/* ----------------------------------------------------------------------------- */
/** \brief SPI Command <b>WRITE_TX_BUFFER</b>
    The spi command WriteTxBuffer writes n data bytes into the Tx Buffer of the D-Fifo.
    The count of data bytes is given in the length parameter. Access direction is switched
    automatically and restored to the origin value at the end of the command (direction
    temporarily stored in the T-Bit).

    \return none
*/
/* ----------------------------------------------------------------------------- */
WRITE_TX_BUFFER:                  ; ID= 0x0B
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_TX_BUFFER_LENGTH , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_TX_BUFFER_LENGTH:
; ------------------------------------------------------------------------------
    ; read length BYTE
    IN      R30 , SPDR
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    ; --> The follwoing functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    CPI     R30 , TX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_WRITE_TX_BUFFER_LENGTH
    LDI     R30 , TX_BUFFER_FIFO_SIZE

SKIP_WRITE_TX_BUFFER_LENGTH:
    ORI     R30 , (BM_SRIE)
    STS     SFIR , R30

    LDI     R30 , low(WRITE_TX_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(WRITE_TX_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM

; ------------------------------------------------------------------------------
WRITE_TX_BUFFER_DATA:
; ------------------------------------------------------------------------------

    SET_RXTX_DFC_DIR TX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

LOOP_WRITE_TX_BUFFER_DATA:                      ; do{
    IN      R31 , SPDR                          ;   Load Data to DFD
    STS     DFD , R31

    DEC     R30                                 ;   DataToWrite(R30)--;
    BREQ    BREAK_WRITE_TX_BUFFER_DATA          ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    ANDI    R31 , (BM_RFL2|BM_RFL1|BM_RFL0)     ; }
    BRNE    LOOP_WRITE_TX_BUFFER_DATA           ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30         ; Store remaining DataToWrite(R30)

    CPI     R30 , TX_BUFFER_FIFO_SIZE           ; if( DataToWrite(R30) > TX_BUFFER_FIFO_SIZE )
    BRLT    SKIP_WRITE_TX_BUFFER_DATA           ;   SFIR = TX_BUFFER_FIFO_SIZE;
    LDI     R30 , TX_BUFFER_FIFO_SIZE           ; else
                                                ;   SFIR = DataToWrite(R30);
SKIP_WRITE_TX_BUFFER_DATA:
    ORI     R30 , (BM_SRIE)                     ; SFIR |= BM_SIRE -> Enable IRQ

BREAK_WRITE_TX_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_DFC_DIR

    JMP     ATA_spiRxBufferEnd_ASM


/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>WRITE_TX_PREAMBLE_BUFFER</b>
    The spi command WriteTxPreambleBuffer writes n data bytes into the Tx Buffer of the S-Fifo.
    The count of data bytes is given in the length parameter. Access direction is switched
    automatically and restored to the origin value at the end of the command (direction
    temporarily stored in the T-Bit).

    \return none
*/
/* ---------------------------------------------------------------------------*/
WRITE_TX_PREAMBLE_BUFFER:         ; ID= 0x0C
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    ENABLE_SPIRXBUFFER WRITE_TX_PREAMBLE_BUFFER_LENGTH , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
WRITE_TX_PREAMBLE_BUFFER_LENGTH:
; ------------------------------------------------------------------------------
    ; read length BYTE
    IN      R30 , SPDR
    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30

    ; --> The follwoing functionality is normally called in ENABLE_SPIRXBUFFER MACRO    address, num_bytes
    CPI     R30 , TX_BUFFER_FIFO_SIZE       ; how many bytes are to receive?
    BRLO    SKIP_WRITE_TX_PREAMBLE_BUFFER_LENGTH
    LDI     R30 , TX_BUFFER_FIFO_SIZE

SKIP_WRITE_TX_PREAMBLE_BUFFER_LENGTH:
    ORI     R30 , (BM_SRIE)
    STS     SFIR , R30

    LDI     R30 , low(WRITE_TX_PREAMBLE_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP , R30

    LDI     R30 , high(WRITE_TX_PREAMBLE_BUFFER_DATA/2)
    STS     g_sSpiConfig + SPICONFIG_PTMP + 1 , R30
    ; <-- normally end of macro

    JMP     ATA_spiRxBufferEnd_ASM


; ------------------------------------------------------------------------------
WRITE_TX_PREAMBLE_BUFFER_DATA:
; ------------------------------------------------------------------------------

    SET_RXTX_SFC_DIR TX_DIR

    LDS     R30 , g_sSpiConfig + SPICONFIG_LENGTH

LOOP_WRITE_TX_PREAMBLE_BUFFER_DATA:                 ;do{
    IN      R31 , SPDR                              ;   Load Data to SFD
    STS     SFD , R31

    DEC     R30                                     ;   DataToWrite(R30)--;
    BREQ    BREAK_WRITE_TX_PREAMBLE_BUFFER_DATA     ;   if( DataToWrite(R30) == 0 ) break;

    LDS     R31 , SFFR
    ANDI    R31 , (BM_RFL2|BM_RFL1|BM_RFL0)         ; }
    BRNE    LOOP_WRITE_TX_PREAMBLE_BUFFER_DATA      ; while( RxFifoLevel > 0 )

    STS     g_sSpiConfig + SPICONFIG_LENGTH , R30             ; Store remaining DataToWrite(R30)

    CPI     R30 , TX_BUFFER_FIFO_SIZE               ; if( DataToWrite(R30) > TX_BUFFER_FIFO_SIZE )
    BRLT    SKIP_WRITE_TX_PREAMBLE_BUFFER_DATA      ;   SFIR = TX_BUFFER_FIFO_SIZE
    LDI     R30 , TX_BUFFER_FIFO_SIZE               ; else
                                                    ;   SFIR = DataToWrite(R30)
SKIP_WRITE_TX_PREAMBLE_BUFFER_DATA:
    ORI     R30 , (BM_SRIE)                         ; SFIR |= BM_SRIE -> Enable IRQ

BREAK_WRITE_TX_PREAMBLE_BUFFER_DATA:
    STS     SFIR , R30

    RESTORE_RXTX_SFC_DIR

    JMP     ATA_spiRxBufferEnd_ASM


/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>SET_SYSTEM_MODE</b>
    The spi command SetSystemMode writtes the systemModeConfig and serviceChannelConfig
    variable of the extReq structure.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SET_SYSTEM_MODE:                 ; ID= 0x0D
; ------------------------------------------------------------------------------
    CLR     R31
    OUT     SPDR , R31
    
    ENABLE_SPIRXBUFFER SET_SYSTEM_MODE_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
SET_SYSTEM_MODE_DATA:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR
    STS     extReq + EXT_REQ_SYSTEM_MODE_CONFIG , R30
    
    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ORI     R30 , BM_ATA5700_STATUS_UPDATE_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30

    ;Original SigmaX-Code
    ;SBI     GPIOR3 , SYS_STATUS_UPDATE

    IN      R30 , SPDR
    STS     extReq + EXT_REQ_SERVICE_CHANNEL_CONFIG , R30
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>CALIBRATE_AND_CHECK</b>
    The spi command CalibrateAndCheck writtes the tuneCheckConfig and
    serviceChannelConfig variable of the extReq structure.
    \return none
*/
/* ---------------------------------------------------------------------------*/
CALIBRATE_AND_CHECK:             ; ID= 0x0E
; ------------------------------------------------------------------------------

    ENABLE_SPIRXBUFFER CALIBRATE_AND_CHECK_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
CALIBRATE_AND_CHECK_DATA:
; ------------------------------------------------------------------------------
    IN      R30 , SPDR
    STS     extReq + EXT_REQ_TUNE_CHECK_CONFIG , R30

    IN      R30 , SPDR
    STS     extReq + EXT_REQ_SERVICE_CHANNEL_CONFIG , R30

    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>PATCH_SPI</b>
    The Patch_Spi command is used to extend the SPI command set by the customer as follows:
    Patch_Spi jumps to the functions which is stored in patchSpi
    The parameter of Patch_Spi is located in SPDR register.
    The Patch SPI extension has no return and the customer has to finish with a jump
    to PATCH_SPI_READY (which is the same as SPIBUFRDY_DISABLERXBUFINT).

    \return none
*/
/* ---------------------------------------------------------------------------*/
PATCH_SPI:                        ; ID= 0x0F
; ------------------------------------------------------------------------------
    ENABLE_SPIRXBUFFER PATCH_SPI_DATA , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
PATCH_SPI_DATA:
; ------------------------------------------------------------------------------
    LDS     R31 , patchSpi                  ; Load addr H
    LDS     R30 , patchSpi + 1              ; Load addr L
    IJMP                                ; call pointed routine
    ;   routine has N cycles                                       41+N
    ;   routine has no return but an JMP to SPI_READY
    ;   IJMP and JMP saves 7 cycles compared to an ICALL
    ; ----Patch, IJMP to stored address [CMD,mode ]--

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>GET_ROM_VERSION</b>
    The command GetRomVersion returns the rom version.

    \return none
*/
/* ---------------------------------------------------------------------------*/
GET_ROM_VERSION:                  ; ID= 0x12
; ------------------------------------------------------------------------------
    LDI     R30 , low(romVersion)
    LDI     R31 , high(romVersion)
    LPM     R25 , Z
    OUT     SPDR , R25
    RJMP    SPI_READY

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>GET_FLASH_VERSION</b>
    The command GetFlashVersion returns the
    - Rom version
    - Flash version
    - Customer specific version

    \return none
*/
/* ---------------------------------------------------------------------------*/
GET_FLASH_VERSION:                ; ID= 0x13
; ------------------------------------------------------------------------------
    LDI     R30 , low(romVersion)
    LDI     R31 , high(romVersion)
    LPM     R25 , Z

    OUT     SPDR , R25

    ENABLE_SPIRXBUFFER GET_FLASH_VERSION_DATA , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
GET_FLASH_VERSION_DATA:
; ------------------------------------------------------------------------------
    LDI     R31 , 0xFF
    LDI     R30 , 0xF0

    PUSH    R24
    PUSH    R25
    LDI     R24 , 3

 CPYLOOPBUF:
    LPM     R25 , Z+
    OUT     SPDR , R25
    DEC     R24
    BRNE    CPYLOOPBUF

    POP     R25
    POP     R24
    JMP     ATA_spiRxBufferDisableInt_ASM


/* ---------------------------------------------------------------------------*/
/**  \brief SPI Command <b>SYSTEM_RESET</b>
    The SPI command System Resets configures the Watchdog and wait inside a
    endless loop until the watchdog triggers the system.

    \return none
*/
/* ---------------------------------------------------------------------------*/
SYSTEM_RESET:                     ; ID= 0x15
; ------------------------------------------------------------------------------
    LDI     R31 , 0x18
    STS     WDTCR , R31
    LDI     R31 , 0x08
    STS     WDTCR , R31

ENDLESSLOOP:
    RJMP    ENDLESSLOOP        ; wait until WDT reset triggers the system

/* ===========================================================================*/
/**  \brief SPI Command <b>SET_VOLTAGE_MONITOR</b>
    The command Set_Voltage_Monitor configures the Voltage Monitor in Primus2+.

    \return none
*/
; ------------------------------------------------------------------------------
SET_VOLTAGE_MONITOR:              ; ID= 0x17
; ------------------------------------------------------------------------------
    ENABLE_SPIRXBUFFER SET_VOLTAGE_MONITOR_DATA , 1
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
SET_VOLTAGE_MONITOR_DATA:
; ------------------------------------------------------------------------------
;TODO: Implement the same way as the API function
    IN      R31 , SPDR
    LDI     R30 , 0x00               ; disable Voltage Monitor Interrupt
    OUT     VMSCR, R30
    
    ; TODO: R31 needs to be saved as it will be written to VMCR completely

    ANDI    R31 , 0x0F
    CPI     R31 , 0x00               ; 0x00 VM is disabled
    BRNE    VOLTAGE_MONITOR_ENABLED
    
    SBI     PRR0 , PRVM
    
    JMP     ATA_spiRxBufferDisableInt_ASM

VOLTAGE_MONITOR_ENABLED:
    
    CBI     PRR0 , PRVM
    
    STS     VMCR , R31             /* NOP count is based on the Voltage Monitor WCET of 1.8us and the register update time
                                       => 14 cycles (including safety margin) when AVR is running with 6 MHZ. */
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ORI     R31 , BM_VMF
    OUT     VMSCR , R31
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ORI     R31 , BM_VMIM
    STS     VMCR , R31
    JMP     ATA_spiRxBufferDisableInt_ASM

/* ---------------------------------------------------------------------------*/
/** \brief SPI Command <b>OFF_COMMAND</b>
    This command sets the SigmaX in OFF Mode

    \return none
*/
/* ---------------------------------------------------------------------------*/
OFF_COMMAND:                      ; ID= 0x18
; ------------------------------------------------------------------------------

    CLR     R31
    OUT     DDRB , R31
    OUT     DDRC , R31
    OUT     DDRD , R31

    SER     R30
    OUT     PORTB , R30
    OUT     PORTC , R30
    CBI     PORTC , PORTC2
    OUT     PORTD , R30

OFF_COMMAND_WAIT_NVMBSY:
    SBIC    EECR , NVMBSY
    RJMP    OFF_COMMAND_WAIT_NVMBSY

    IN      R30, SMCR
    ORI     R30, (BM_SM2 | BM_SM0 | BM_SE)
    OUT     SMCR, R30 
    SLEEP

    RJMP    SPI_READY


/* ===========================================================================*/
/** \brief SPI Command <b>INIT_SRAM_SERVICE</b>
    The spi command Init_SRAM_Service initializes the service sramServices[sramServiceNumber]
    with the service eepService[eepromServiceNumber].

    \return none
*/
; ------------------------------------------------------------------------------
INIT_SRAM_SERVICE:               ; ID= 0x1A
; ------------------------------------------------------------------------------

    ENABLE_SPIRXBUFFER INIT_SRAM_SERVICE_DATA , 2
    RJMP    SPI_READY

; ------------------------------------------------------------------------------
INIT_SRAM_SERVICE_DATA:
; ------------------------------------------------------------------------------
    IN      R31 , SPDR   ; sramServiceNumber 0..1
    IN      R30 , SPDR   ; eepServiceNumber  0..2
    LSL     R30
    OR      R31 , R30
    ORI     R31 , BM_EXT_REQ_SERVICE_INIT_CONFIG_UPDATE_FLAG

    STS     extReq + EXT_REQ_SERVICE_INIT_CONFIG , R31

    JMP     ATA_spiRxBufferDisableInt_ASM


/* ---------------------------------------------------------------------------*/
/** \brief <b>INVALIDCMD</b>
    If there is a invalid CMD (CMD Id > than MAXCOMMANDS) received, the INVALIDCMD
    function is called.

    \return none
*/
/* ---------------------------------------------------------------------------*/
INVALIDCMD:
; ------------------------------------------------------------------------------
    RJMP    SPI_READY
/* stopDoxyExclude */

/* ---------------------------------------------------------------------------*/
/**  \brief <b>ATA_interrupt0Handler_ASM</b>
    triggers each time when the int0 flag is set. To ensure the synchronism of
    the sended events bytes and the copied events byte this interrupt has not
    to be interrupted by an other interrupt! (the blocking mechanism is done
    via the SREG.I).

    \return none
*/
/* ---------------------------------------------------------------------------*/
#pragma vector=INT0_vect
RSEG CODE:CODE:ROOT(1)
ATA_interrupt0Handler_ASM:
; ----Save Register contents----
    PUSH    R31
    PUSH    R30
    IN      R31 , SREG
    PUSH    R31

    SBIS    PIND , PIND1
    RJMP    SPI_SS_LOW

    ; ---- slave select is high -> end of spi command
SPI_SS_HIGH:

    LDS     R31 , SFFR
    ORI     R31 , (BM_RFC | BM_TFC)
    STS     SFFR , R31

    LDS     R31 , SFIR
    ANDI    R31 , ~(BM_SRIE | BM_STIE)
    STS     SFIR , R31

    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ANDI    R30 , ~BM_ATA5700_STATUS_SPI_CMD_IN_PROGRESS_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30

    RJMP    INT0_END

SPI_SS_LOW:
    
    ; ---- slave select is low -> beginning of spi command
    LDS     R31 , SFFR
    ORI     R31 ,(BM_RFC | BM_TFC)
    STS     SFFR , R31

    NOP    ; NOP necessary because of execution time of reseting RxFifo -> without this NOP the following OUT instruction don't work correct!

    ; --- send the actual events_system & events_events to the SPI fifo
    CLR     R31
    OUT     SPDR , R31
    OUT     SPDR , R31

    IN      R31 , SPCR  ; enable SPI interrupt
    ORI     R31 ,(BM_SPIE)
    OUT     SPCR , R31

    ; at NSS falling edge disable sleep enable in SMCR register
    IN      R31 , SMCR
    ANDI    R31 , 0xFE
    OUT     SMCR , R31

    ; set GPIOR1 = sysStatus SPI command in progress to disable SLEEP mode during SPI commands in main loop
    
    LDS     R30 , g_sAta5700_flash + ATA5700_STATUS
    ORI     R30 , BM_ATA5700_STATUS_SPI_CMD_IN_PROGRESS_FLAG
    STS     g_sAta5700_flash + ATA5700_STATUS , R30
   
INT0_END:

    POP     R31
    OUT     SREG , R31
    POP     R30
    POP     R31

    RETI

    ; End of file
    END
