///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V6.70.1.929 for Atmel AVR           05/Apr/2016  13:30:43
// Copyright 1996-2015 IAR Systems AB.
// Network license: DVRIAR01.corpp.atmel.com (STD)
//
//    Source file  =  
//        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\rftx\src\rftx.c
//    Command line =  
//        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\rftx\src\rftx.c
//        -v3 --enhanced_core -ms -o
//        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\Obj
//        -lC
//        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List
//        -lA
//        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List
//        --initializers_in_flash --no_cse --no_inline --no_code_motion
//        --no_cross_call --no_clustering --no_tbaa --debug --64k_flash
//        -DENABLE_BIT_DEFINITIONS -e -I "C:\Program Files (x86)\IAR
//        Systems\Embedded Workbench 6.0\avr\inc\" --eeprom_size 1152 --clib
//        -Ohz
//    List file    =  
//        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List\rftx.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME rftx

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__cpu", "3"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?ML_FLASH_SRAM_16EC_16_L07

        PUBLIC ATA_rfTxClose_C
        PUBLIC ATA_rfTxDFifoError_ISR_C
        PUBLIC ATA_rfTxDFifoFillLevelReached_ISR_C
        PUBLIC ATA_rfTxFillDFifo_C
        PUBLIC ATA_rfTxFillSFifo_C
        PUBLIC ATA_rfTxInitCurrentService_C
        PUBLIC ATA_rfTxInitFrontEnd_C
        PUBLIC ATA_rfTxInitTxSSM_C
        PUBLIC ATA_rfTxInit_C
        PUBLIC ATA_rfTxModulatorTelegramFinish_ISR_C
        PUBLIC ATA_rfTxProcessing_C
        PUBLIC ATA_rfTxSFifoError_ISR_C
        PUBLIC ATA_rfTxSFifoFillLevelReached_ISR_C
        PUBLIC ATA_rfTxShutdown_C
        PUBLIC ATA_rfTxSsmRdy_ISR_C
        PUBLIC ATA_rfTxStartSSM_C
        PUBLIC ATA_rfTxStartSsmWatchdog_C
        PUBLIC ATA_rfTxStartTxBufSSM_C
        PUBLIC ATA_rfTxStartTxModulator_C
        PUBLIC ATA_rfTxStartTxTransSSM_C
        PUBLIC ATA_rfTxStartTx_C
        PUBLIC ATA_rfTxStopSsmWatchdog_C
        PUBLIC ATA_rfTxStop_C
        PUBLIC ATA_rfTxTransparentMode_C
        PUBLIC ATA_rfTxWait4AVCC_C
        PUBLIC ATA_rfTxWait4FillLevel_C
        PUBLIC ATA_rfTxWait4SSMrdy_C
        PUBLIC ATA_rfTxWait4TransmissionComplete_C
        PUBLIC ATA_rfTxWait4XTO_C
        PUBWEAK _A_CMCR
        PUBWEAK _A_DDRD
        PUBWEAK _A_DFC
        PUBWEAK _A_DFD
        PUBWEAK _A_DFI
        PUBWEAK _A_DFL
        PUBWEAK _A_FEALR
        PUBWEAK _A_FEANT
        PUBWEAK _A_FEAT
        PUBWEAK _A_FEBT
        PUBWEAK _A_FECR
        PUBWEAK _A_FEEN1
        PUBWEAK _A_FEEN2
        PUBWEAK _A_FEMS
        PUBWEAK _A_FEPAC
        PUBWEAK _A_FESR
        PUBWEAK _A_FETN4
        PUBWEAK _A_FEVCO
        PUBWEAK _A_FEVCT
        PUBWEAK _A_FFREQ1H
        PUBWEAK _A_FFREQ1L
        PUBWEAK _A_FFREQ1M
        PUBWEAK _A_FFREQ2H
        PUBWEAK _A_FFREQ2L
        PUBWEAK _A_FFREQ2M
        PUBWEAK _A_FSCR
        PUBWEAK _A_FSEN
        PUBWEAK _A_FSFCR
        PUBWEAK _A_GACDIVH
        PUBWEAK _A_GACDIVL
        PUBWEAK _A_MSMCR1
        PUBWEAK _A_MSMCR2
        PUBWEAK _A_MSMCR3
        PUBWEAK _A_MSMCR4
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR0
        PUBWEAK _A_PRR1
        PUBWEAK _A_PRR2
        PUBWEAK _A_SFC
        PUBWEAK _A_SFD
        PUBWEAK _A_SFI
        PUBWEAK _A_SFL
        PUBWEAK _A_SREG
        PUBWEAK _A_SSMCR
        PUBWEAK _A_SSMFBR
        PUBWEAK _A_SSMIFR
        PUBWEAK _A_SSMIMR
        PUBWEAK _A_SSMRR
        PUBWEAK _A_SSMSR
        PUBWEAK _A_SUPCR
        PUBWEAK _A_SUPFR
        PUBWEAK _A_T2IFR
        PUBWEAK _A_T3CORH
        PUBWEAK _A_T3CORL
        PUBWEAK _A_T3CR
        PUBWEAK _A_T3IMR
        PUBWEAK _A_T3MRA
        PUBWEAK _A_T3MRB
        PUBWEAK _A_TMCIH
        PUBWEAK _A_TMCIL
        PUBWEAK _A_TMCPH
        PUBWEAK _A_TMCPL
        PUBWEAK _A_TMCR1
        PUBWEAK _A_TMCR2
        PUBWEAK _A_TMCSB
        PUBWEAK _A_TMSR
        PUBWEAK _A_TMSSC
        PUBWEAK _A_TMTLH
        PUBWEAK _A_TMTLL
        PUBWEAK _A_TRCDR
        PUBWEAK _A_TRCIDH
        PUBWEAK _A_TRCIDL
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC g_pRfTxBufStateMachine
        PUBLIC g_pRfTxTransStateMachine
        PUBLIC g_sRfTx
        PUBLIC g_sRfTxBufStateMachineLut
        PUBLIC g_sRfTxCurrentService
        PUBLIC g_sRfTxFlowCtrl
        PUBLIC g_sRfTxTransStateMachineLut
        
          CFI Names cfiNames0
          CFI StackFrame CFA_Y Y DATA
          CFI StackFrame CFA_SP SP DATA
          CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
          CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
          CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
          CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
          CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
          CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
          CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
          CFI ResourceParts SP SPH, SPL
          CFI ResourceParts Y R29, R28
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 Undefined
          CFI R17 Undefined
          CFI R18 Undefined
          CFI R19 Undefined
          CFI R20 Undefined
          CFI R21 Undefined
          CFI R22 Undefined
          CFI R23 Undefined
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 Undefined
          CFI R31 Undefined
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 SameValue
          CFI R17 SameValue
          CFI R18 SameValue
          CFI R19 SameValue
          CFI R20 SameValue
          CFI R21 SameValue
          CFI R22 SameValue
          CFI R23 SameValue
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 SameValue
          CFI R31 SameValue
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon1
        
        EXTERN ATA_eepReadBytes_C
        EXTERN ATA_globalsClkSwitchExt_C
        EXTERN ATA_globalsClkSwitchFrc_C
        EXTERN ATA_globalsClkSwitchMrc_C
        EXTERN ATA_globalsClkSwitchSrc_C
        EXTERN ATA_globalsClkSwitchXTO_C
        EXTERN ATA_globalsCopySramSpace_C
        EXTERN ATA_globalsWaitNus_ASM
        EXTERN ATA_timer2Close_C
        EXTERN ATA_timer2Open_C
        EXTERN ATA_timer3Close_C
        EXTERN g_bAntennaTuningResult
        EXTERN g_bVcoTuningResult
        EXTERN g_pRfTxAntTuneStateMachine
        EXTERN g_pRfTxVcoTuneStateMachine
        EXTERN g_sAtmelEEPromSection
        EXTERN g_sDebug
        EXTERN g_sRfTxAntTuneStateMachineLut
        EXTERN g_sRfTxVcoTuneStateMachineLut
        EXTERN g_sTimer3

// C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\rftx\src\rftx.c
//    1 //lint -e9059
//    2 /* *C**************************************************************************
//    3   Use of this software is subject to Atmel's Software License Agreement.
//    4 -------------------------------------------------------------------------------
//    5   $URL: http://svnservulm.corp.atmel.com/svn/CDB/Apps/SW_Lib/Car_Access/CARS_GEN2/ATAB5702A/Branches/P2_Gen2_Merge/firmware/rftx/src/rftx.c $
//    6   $LastChangedRevision: 328482 $
//    7   $LastChangedDate: 2015-07-22 13:17:23 -0600 (Wed, 22 Jul 2015) $
//    8   $LastChangedBy: grueter $
//    9 -------------------------------------------------------------------------------
//   10   Project:      ATA5700
//   11   Target MCU:   ATA5700
//   12   Compiler:     IAR C/C++ Compiler for AVR 6.30.1
//   13 -------------------------------------------------------------------------------
//   14 
//   15 ******************************************************************************
//   16 * Copyright 2011, Atmel Automotive GmbH                                       *
//   17 *                                                                             *
//   18 * This software is owned by the Atmel Automotive GmbH                         *
//   19 * and is protected by and subject to worldwide patent protection.             *
//   20 * Atmel hereby grants to licensee a personal,                                 *
//   21 * non-exclusive, non-transferable license to copy, use, modify, create        *
//   22 * derivative works of, and compile the Atmel Source Code and derivative       *
//   23 * works for the sole purpose of creating custom software in support of        *
//   24 * licensee product to be used only in conjunction with a Atmel integrated     *
//   25 * circuit as specified in the applicable agreement. Any reproduction,         *
//   26 * modification, translation, compilation, or representation of this           *
//   27 * software except as specified above is prohibited without the express        *
//   28 * written permission of Atmel.                                                *
//   29 *                                                                             *
//   30 * Disclaimer: ATMEL MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,         *
//   31 * WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
//   32 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
//   33 * Atmel reserves the right to make changes without further notice to the      *
//   34 * materials described herein. Atmel does not assume any liability arising     *
//   35 * out of the application or use of any product or circuit described herein.   *
//   36 * Atmel does not authorize its products for use as critical components in     *
//   37 * life-support systems where a malfunction or failure may reasonably be       *
//   38 * expected to result in significant injury to the user. The inclusion of      *
//   39 * Atmel products in a life-support systems application implies that the       *
//   40 * manufacturer assumes all risk of such use and in doing so indemnifies       *
//   41 * Atmel against all charges.                                                  *
//   42 *                                                                             *
//   43 * Use may be limited by and subject to the applicable Atmel software          *
//   44 * license agreement.                                                          *
//   45 ******************************************************************************/
//   46 /** \file rftx.c
//   47 */
//   48 //lint -restore
//   49 
//   50 /*---------------------------------------------------------------------------*/
//   51 /*  INCLUDES                                                                 */
//   52 /*---------------------------------------------------------------------------*/
//   53 #include "../../stdc/src/stdc.h"

        ASEGN ABSOLUTE:DATA:NOROOT,021H
// union <unnamed> volatile __io _A_PRR1
_A_PRR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,022H
// union <unnamed> volatile __io _A_PRR2
_A_PRR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02fH
// union <unnamed> volatile __io _A_FSCR
_A_FSCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,033H
// union <unnamed> volatile __io _A_T3CR
_A_T3CR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,03aH
// union <unnamed> volatile __io _A_PRR0
_A_PRR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,060H
// union <unnamed> volatile __io _A_FSEN
_A_FSEN:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,061H
// union <unnamed> volatile __io _A_FSFCR
_A_FSFCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,062H
// union <unnamed> volatile __io _A_GACDIVL
_A_GACDIVL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,063H
// union <unnamed> volatile __io _A_GACDIVH
_A_GACDIVH:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,064H
// union <unnamed> volatile __io _A_FFREQ1L
_A_FFREQ1L:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,065H
// union <unnamed> volatile __io _A_FFREQ1M
_A_FFREQ1M:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,066H
// union <unnamed> volatile __io _A_FFREQ1H
_A_FFREQ1H:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,067H
// union <unnamed> volatile __io _A_FFREQ2L
_A_FFREQ2L:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,068H
// union <unnamed> volatile __io _A_FFREQ2M
_A_FFREQ2M:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,069H
// union <unnamed> volatile __io _A_FFREQ2H
_A_FFREQ2H:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,079H
// union <unnamed> volatile __io _A_T3CORL
_A_T3CORL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,07aH
// union <unnamed> volatile __io _A_T3CORH
_A_T3CORH:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,07dH
// union <unnamed> volatile __io _A_T3MRA
_A_T3MRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,07eH
// union <unnamed> volatile __io _A_T3MRB
_A_T3MRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,07fH
// union <unnamed> volatile __io _A_T3IMR
_A_T3IMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0cbH
// union <unnamed> volatile __io _A_SUPFR
_A_SUPFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0ccH
// union <unnamed> volatile __io _A_SUPCR
_A_SUPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0d5H
// union <unnamed> volatile __io _A_DFL
_A_DFL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0d8H
// union <unnamed> volatile __io _A_DFD
_A_DFD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0d9H
// union <unnamed> volatile __io _A_DFI
_A_DFI:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0daH
// union <unnamed> volatile __io _A_DFC
_A_DFC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0dcH
// union <unnamed> volatile __io _A_SFL
_A_SFL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0dfH
// union <unnamed> volatile __io _A_SFD
_A_SFD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e0H
// union <unnamed> volatile __io _A_SFI
_A_SFI:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e1H
// union <unnamed> volatile __io _A_SFC
_A_SFC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e2H
// union <unnamed> volatile __io _A_SSMCR
_A_SSMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e4H
// union <unnamed> volatile __io _A_SSMFBR
_A_SSMFBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e5H
// union <unnamed> volatile __io _A_SSMRR
_A_SSMRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e6H
// union <unnamed> volatile __io _A_SSMSR
_A_SSMSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e7H
// union <unnamed> volatile __io _A_SSMIFR
_A_SSMIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0e8H
// union <unnamed> volatile __io _A_SSMIMR
_A_SSMIMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0ecH
// union <unnamed> volatile __io _A_MSMCR1
_A_MSMCR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0edH
// union <unnamed> volatile __io _A_MSMCR2
_A_MSMCR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0eeH
// union <unnamed> volatile __io _A_MSMCR3
_A_MSMCR3:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0efH
// union <unnamed> volatile __io _A_MSMCR4
_A_MSMCR4:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0fcH
// union <unnamed> volatile __io _A_TRCIDL
_A_TRCIDL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0fdH
// union <unnamed> volatile __io _A_TRCIDH
_A_TRCIDH:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0ffH
// union <unnamed> volatile __io _A_TRCDR
_A_TRCDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0100H
// union <unnamed> volatile __ext_io _A_FESR
_A_FESR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0101H
// union <unnamed> volatile __ext_io _A_FEEN1
_A_FEEN1:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0102H
// union <unnamed> volatile __ext_io _A_FEEN2
_A_FEEN2:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0104H
// union <unnamed> volatile __ext_io _A_FEAT
_A_FEAT:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0105H
// union <unnamed> volatile __ext_io _A_FEPAC
_A_FEPAC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0106H
// union <unnamed> volatile __ext_io _A_FEVCT
_A_FEVCT:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0107H
// union <unnamed> volatile __ext_io _A_FEBT
_A_FEBT:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0108H
// union <unnamed> volatile __ext_io _A_FEMS
_A_FEMS:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0109H
// union <unnamed> volatile __ext_io _A_FETN4
_A_FETN4:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,010aH
// union <unnamed> volatile __ext_io _A_FECR
_A_FECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,010bH
// union <unnamed> volatile __ext_io _A_FEVCO
_A_FEVCO:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,010cH
// union <unnamed> volatile __ext_io _A_FEALR
_A_FEALR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,010dH
// union <unnamed> volatile __ext_io _A_FEANT
_A_FEANT:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0123H
// union <unnamed> volatile __ext_io _A_TMCSB
_A_TMCSB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0124H
// union <unnamed> volatile __ext_io _A_TMCIL
_A_TMCIL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0125H
// union <unnamed> volatile __ext_io _A_TMCIH
_A_TMCIH:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0126H
// union <unnamed> volatile __ext_io _A_TMCPL
_A_TMCPL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0127H
// union <unnamed> volatile __ext_io _A_TMCPH
_A_TMCPH:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0129H
// union <unnamed> volatile __ext_io _A_TMTLL
_A_TMTLL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,012aH
// union <unnamed> volatile __ext_io _A_TMTLH
_A_TMTLH:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,012bH
// union <unnamed> volatile __ext_io _A_TMSSC
_A_TMSSC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,012cH
// union <unnamed> volatile __ext_io _A_TMSR
_A_TMSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,012dH
// union <unnamed> volatile __ext_io _A_TMCR2
_A_TMCR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,012eH
// union <unnamed> volatile __ext_io _A_TMCR1
_A_TMCR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0159H
// union <unnamed> volatile __ext_io _A_T2IFR
_A_T2IFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,01e3H
// union <unnamed> volatile __ext_io _A_CMCR
_A_CMCR:
        DS8 1
//   54 #include "rftx.h"
//   55 #include "rftx_vco.h"
//   56 #include "rftx_ant.h"
//   57 
//   58 #include "..\..\eep\src\eep.h"
//   59 #include "..\..\timer2\src\timer2.h"
//   60 #include "..\..\timer3\src\timer3.h"
//   61 #include "..\..\globals\src\globals.h"
//   62 /*---------------------------------------------------------------------------*/
//   63 /*  DEFINES                                                                  */
//   64 /*---------------------------------------------------------------------------*/
//   65 /*---------------------------------------------------------------------------*/
//   66 /*  Modul Globals                                                            */
//   67 /*---------------------------------------------------------------------------*/
//   68 
//   69 static VOIDFUNC  ATA_rfTxOpenTimer3forTxing_C(void);
//   70 static VOIDFUNC  ATA_rfTxFrequencySettings_C(void);
//   71 static VOIDFUNC  ATA_rfTxSetupTxModulator_C(void);
//   72 static VOIDFUNC  ATA_rfTxConfigureTxSSM_C(void);
//   73 static UINT8FUNC ATA_rfTxFevcoCalculation_C(void);
//   74 static VOIDFUNC  ATA_rfTxEnd_C(void);
//   75 static VOIDFUNC  ATA_rfTxStartSendTelegramSSM_C(void);
//   76 static VOIDFUNC  ATA_rfTxStartShutDownSSM_C(void);
//   77 
//   78 /** \brief <b>g_sRfTx</b>
//   79     contains the configuration and status information for module RF Tx.
//   80  */
//   81 #pragma location = ".rftx"

        RSEG `.rftx`:DATA:ROOT(0)
//   82 __root __no_init sRfTxConfig g_sRfTx;
g_sRfTx:
        DS8 7
//   83 
//   84 /** \brief <b>g_sRfTxCurrentService</b>
//   85     contains the service configuration of the currently used service/channel
//   86     configuration. The selected configuration is copied to
//   87     ::ATA_rfTxInitCurrentService_C at startup of RFTX.
//   88  */
//   89 #pragma location = ".rftx"

        RSEG `.rftx`:DATA:ROOT(0)
//   90 __root __no_init sRfTxCurrentServiceChannelConfiguration g_sRfTxCurrentService;
g_sRfTxCurrentService:
        DS8 33
//   91 
//   92 /** \brief <b>flowCtrl</b>
//   93     is used for software state machine control.
//   94     The complete SW state machine flow is controlled with this variable.
//   95 */
//   96 #pragma location = ".flowctrl"

        RSEG `.flowctrl`:DATA:ROOT(0)
//   97 __root __no_init sSystemFlowCtrl g_sRfTxFlowCtrl;
g_sRfTxFlowCtrl:
        DS8 3
//   98 
//   99 /** \brief <b>g_pRfTxBufStateMachine</b>
//  100     points to look up table of the SW state machine used for
//  101     TXMode(Buffered).
//  102     \details
//  103     This pointer is initialized at RFTX module initialization
//  104     in function ::ATA_rfTxInit_C. If the user wants to change this flow,
//  105     the pointer should be modified after initialization.
//  106 */
//  107 #pragma location = ".flowctrl"

        RSEG `.flowctrl`:DATA:ROOT(0)
//  108 __root __no_init sysFlowStateMachineFuncLut_t *g_pRfTxBufStateMachine;
g_pRfTxBufStateMachine:
        DS8 2
//  109 
//  110 //lint -esym(9003, g_sRfTxBufStateMachineLut) FlSc (26.05.2014)
//  111 /* disable lint note 9003 - could define variable 'g_sRfTxBufStateMachineLut' at block scope
//  112  * variable shall be accessible from outside via flash software or other library
//  113  * modules
//  114  */
//  115 /** <b>g_sRfTxBufStateMachineLut</b>
//  116     look up table of the SW state machine used for TXMode (Buffered only).
//  117     \details
//  118     \li ATA_rfTxInitTxSSM_C:
//  119         this sw state does the register initialization according to the selected
//  120         service channel configuration. Note: FE register are initialized after AVCC
//  121         is stable in SW state ::ATA_rfTxInitFrontEnd_C
//  122     \li ATA_rfTxWait4AVCC_C:
//  123         waits until AVCC is stable and switches to next sw state if AVCC is stable.
//  124     \li ATA_rfTxInitFrontEnd_C:
//  125         initializes the frontend registers according to the selected service channel
//  126         configuration
//  127     \li ATA_rfTxWait4XTO_C:
//  128         waits until XTO is ready. If AVR is not running with CLKXTO4 the
//  129         core clock is switched to CLKXTO4
//  130     \li ATA_rfTxStartSSM_C:
//  131         starts the sequencer state machine
//  132     \li ATA_rfTxWait4SSMrdy_C:
//  133         waits until the sequencer state machine is ready
//  134     \li ATA_rfTxWait4FillLevel_C:
//  135         checks the fill levels of S-FIFO and D-FIFO
//  136     \li ATA_rfTxStartTxModulator_C:
//  137         configures the fill level interrupts, starts the TX Modulator and
//  138         SendTelegramSSM
//  139     \li ATA_rfTxWait4TransmissionComplete_C:
//  140         waits until Transmission has completed
//  141     \li ATA_rfTxShutdown_C:
//  142         shut down the RFTX module related state machine for TXMode(buffered and transparent),
//  143         VCO tuning and antenna tuning.
//  144 
//  145  */

        RSEG NEAR_F:CODE:ROOT(0)
//  146 __root sysFlowStateMachineFuncLut_t g_sRfTxBufStateMachineLut[] = {
g_sRfTxBufStateMachineLut:
        DC16 ATA_rfTxInitTxSSM_C/2, ATA_rfTxWait4AVCC_C/2
        DC16 ATA_rfTxInitFrontEnd_C/2, ATA_rfTxWait4XTO_C/2
        DC16 ATA_rfTxStartTxBufSSM_C/2, ATA_rfTxWait4SSMrdy_C/2
        DC16 ATA_rfTxWait4FillLevel_C/2, ATA_rfTxStartTxModulator_C/2
        DC16 ATA_rfTxWait4TransmissionComplete_C/2, ATA_rfTxShutdown_C/2
//  147     ATA_rfTxInitTxSSM_C,
//  148     ATA_rfTxWait4AVCC_C,
//  149     ATA_rfTxInitFrontEnd_C,
//  150     ATA_rfTxWait4XTO_C,
//  151     ATA_rfTxStartTxBufSSM_C,
//  152     ATA_rfTxWait4SSMrdy_C,
//  153     ATA_rfTxWait4FillLevel_C,
//  154     ATA_rfTxStartTxModulator_C,
//  155     ATA_rfTxWait4TransmissionComplete_C,
//  156     ATA_rfTxShutdown_C
//  157 };
//  158 
//  159 /** \brief <b>g_pRfTxTransStateMachine</b>
//  160     points to look up table of the SW state machine used for
//  161     TXMode(Transparent mode only).
//  162     \details
//  163     This pointer is initialized at RFTX module initialization
//  164     in function ATA_rfTxInit_C. If the user wants to change this flow,
//  165     the pointer should be modified after initialization.
//  166 */
//  167 #pragma location = ".flowctrl"

        RSEG `.flowctrl`:DATA:ROOT(0)
//  168 __root __no_init sysFlowStateMachineFuncLut_t *g_pRfTxTransStateMachine;
g_pRfTxTransStateMachine:
        DS8 2
//  169 
//  170 
//  171 //lint -esym(9003, g_sRfTxTransStateMachineLut) FlSc (26.05.2014)
//  172 /* disable lint note 9003 - could define variable 'g_sRfTxTransStateMachineLut' at block scope
//  173  * variable shall be accessible from outside via flash software or other library
//  174  * modules
//  175  */
//  176 /** <b>g_sRfTxTransStateMachineLut</b>
//  177     look up table of the SW state machine used for TXMode (Transparent mode only).
//  178     \details
//  179     \li ATA_rfTxInitTxSSM_C:
//  180         this SW state does the register initialization according to the selected
//  181         service channel configuration. Note: FE register are initialized after AVCC
//  182         is stable in SW state ::ATA_rfTxInitFrontEnd_C
//  183     \li ATA_rfTxWait4AVCC_C:
//  184         waits until AVCC is stable and switches to next sw state if AVCC is stable.
//  185     \li ATA_rfTxInitFrontEnd_C:
//  186         initializes the frontend registers according to the selected service channel
//  187         configuration
//  188     \li ATA_rfTxWait4XTO_C:
//  189         waits until XTO is ready. If AVR is not running with CLKXTO4 the
//  190         core clock is switched to CLKXTO4
//  191     \li ATA_rfTxStartSSM_C:
//  192         starts the sequencer state machine
//  193     \li ATA_rfTxWait4SSMrdy_C:
//  194         waits until the sequencer state machine is ready
//  195     \li ATA_rfTxTransparentMode_C:
//  196         is an empty function. This sw state is reached after TXMode(transparent)
//  197         has started correctly
//  198     \li ATA_rfTxShutdown_C:
//  199         shut down the RFTX module related state machine for TXMode(buffered and transparent),
//  200         VCO tuning and antenna tuning.
//  201 
//  202  */

        RSEG NEAR_F:CODE:ROOT(0)
//  203 __root sysFlowStateMachineFuncLut_t g_sRfTxTransStateMachineLut[] = {
g_sRfTxTransStateMachineLut:
        DC16 ATA_rfTxInitTxSSM_C/2, ATA_rfTxWait4AVCC_C/2
        DC16 ATA_rfTxInitFrontEnd_C/2, ATA_rfTxWait4XTO_C/2
        DC16 ATA_rfTxStartTxTransSSM_C/2, ATA_rfTxWait4SSMrdy_C/2
        DC16 ATA_rfTxTransparentMode_C/2, ATA_rfTxShutdown_C/2
//  204     ATA_rfTxInitTxSSM_C,
//  205     ATA_rfTxWait4AVCC_C,
//  206     ATA_rfTxInitFrontEnd_C,
//  207     ATA_rfTxWait4XTO_C,
//  208     ATA_rfTxStartTxTransSSM_C,
//  209     ATA_rfTxWait4SSMrdy_C,
//  210     ATA_rfTxTransparentMode_C,
//  211     ATA_rfTxShutdown_C
//  212 };
//  213 
//  214 
//  215 /*---------------------------------------------------------------------------*/
//  216 /*  IMPLEMENTATION                                                           */
//  217 /*---------------------------------------------------------------------------*/
//  218 /*---------------------------------------------------------------------------*/
//  219 /** \brief <b>ATA_rfTxInit_C</b>
//  220     initializes the RFTX module. This function should be executed before
//  221     starting RFTX.
//  222 
//  223     Variable Usage:
//  224     \li [out] ::g_sRfTx Global RF Tx component data
//  225     \li [out] ::g_pRfTxBufStateMachine Global RF Tx (buffered) statemachine
//  226     \li [out] ::g_pRfTxTransStateMachine Global RF Tx (transparent) statemachine
//  227     \li [out] ::g_pRfTxVcoTuneStateMachine Global RF Tx (VCO tuning) statemachine
//  228     \li [out] ::g_pRfTxAntTuneStateMachine Global RF Tx (Antenna tuning) statemachine
//  229     \li [out] ::g_bVcoTuningResult Global RF Tx VCO tuning component data
//  230     \li [out] ::g_bAntennaTuningResult Global RF Tx Antenna tuning component data
//  231     \li [in] ::g_sRfTxBufStateMachineLut Global RF Tx (buffered) statemachine lookup table
//  232     \li [in] ::g_sRfTxTransStateMachineLut Global RF Tx (transparent) statemachine lookup table
//  233     \li [in] ::g_sRfTxVcoTuneStateMachineLut Global RF Tx (VCO tuning) statemachine lookup table
//  234     \li [in] ::g_sRfTxAntTuneStateMachineLut Global RF Tx (Antenna tuning) statemachine lookup table
//  235 
//  236     \image html ATA_rfTxInit_C.png
//  237 
//  238     \internal
//  239     \li 010: Power-up/initialize D-FIFO and S-FIFO used for data bufferint in RFTX
//  240     \li 020: Enable overflow/underflow interrupts for D-FIFO and S-FIFO to signal
//  241               errorneous usage of D-FIFO and S-FIFO to the customer application
//  242     \li 030: Initialize the state machine pointers for controlling
//  243                  - TXMode buffered (::g_pRfTxBufStateMachine)
//  244                  - TXMode transparent (::g_pRfTxTransStateMachine)
//  245                  - VCO Tuning (::g_pRfTxVcoTuneStateMachine)
//  246                  - Antenna Tuning (::g_pRfTxAntTuneStateMachine)
//  247     \li 040: Initialize RFTX Module global variables which contains
//  248                  - VCO tuning result (::g_bVcoTuningResult)
//  249                  - Antenna tuning result (::g_bAntennaTuningResult)
//  250     \li 050: Initialize RFTX Module configuration ::g_sRfTx
//  251 
//  252     \Derived{No}
//  253 
//  254     \Rationale{N/A}
//  255 
//  256     \Traceability{Primus2P-844}
//  257     \endinternal
//  258 \n
//  259 */
//  260 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
//  261 VOIDFUNC ATA_rfTxInit_C()
ATA_rfTxInit_C:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function ATA_rfTxInit_C
          CFI NoCalls
//  262 {
//  263     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxInit_C, 0x00);
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxInit_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxInit_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
//  264 
//  265     /* LLR-Ref: 010 */
//  266     ATA_POWERON_C(PRR2, PRDF)
        CBI     0x02, 0x03
//  267     ATA_POWERON_C(PRR2, PRSF)
        CBI     0x02, 0x02
//  268 
//  269     /* LLR-Ref: 020 */
//  270     ATA_SETBITMASK_C(DFI,BM_DFERIM)
        LDS     R16, 217
        ORI     R16, 0x02
        STS     217, R16
//  271     ATA_SETBITMASK_C(SFI,BM_SFERIM)
        LDS     R16, 224
        ORI     R16, 0x02
        STS     224, R16
//  272 
//  273     /* LLR-Ref: 030 */
//  274     g_pRfTxBufStateMachine     = g_sRfTxBufStateMachineLut;
        LDI     R16, LOW(g_sRfTxBufStateMachineLut)
        LDI     R17, (g_sRfTxBufStateMachineLut) >> 8
        STS     g_pRfTxBufStateMachine, R16
        STS     (g_pRfTxBufStateMachine + 1), R17
//  275     g_pRfTxTransStateMachine   = g_sRfTxTransStateMachineLut;
        LDI     R16, LOW(g_sRfTxTransStateMachineLut)
        LDI     R17, (g_sRfTxTransStateMachineLut) >> 8
        STS     g_pRfTxTransStateMachine, R16
        STS     (g_pRfTxTransStateMachine + 1), R17
//  276     g_pRfTxVcoTuneStateMachine = g_sRfTxVcoTuneStateMachineLut;
        LDI     R16, LOW(g_sRfTxVcoTuneStateMachineLut)
        LDI     R17, (g_sRfTxVcoTuneStateMachineLut) >> 8
        STS     g_pRfTxVcoTuneStateMachine, R16
        STS     (g_pRfTxVcoTuneStateMachine + 1), R17
//  277     g_pRfTxAntTuneStateMachine = g_sRfTxAntTuneStateMachineLut;
        LDI     R16, LOW(g_sRfTxAntTuneStateMachineLut)
        LDI     R17, (g_sRfTxAntTuneStateMachineLut) >> 8
        STS     g_pRfTxAntTuneStateMachine, R16
        STS     (g_pRfTxAntTuneStateMachine + 1), R17
//  278 
//  279     /* LLR-Ref: 040 */
//  280     g_bVcoTuningResult = 0U;
          CFI EndBlock cfiBlock0
        REQUIRE ?Subroutine0
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_PRR2
        REQUIRE _A_DFI
        REQUIRE _A_SFI
        ;               // Fall through to label ?Subroutine0
//  281     g_bAntennaTuningResult = 0U;
//  282 
//  283     /* LLR-Ref: 050 */
//  284     g_sRfTx.bFlags      = 0x00U;
//  285     g_sRfTx.bTuneFlags  = 0x00U;
//  286     g_sRfTx.bStatus     = 0x00U;
//  287     g_sRfTx.bConfig     = 0x00U;
//  288     g_sRfTx.pAddress   = 0x0000U;
//  289 
//  290 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI NoFunction
        LDI     R16, 0
        STS     g_bVcoTuningResult, R16
        STS     g_bAntennaTuningResult, R16
        STS     g_sRfTx, R16
        STS     (g_sRfTx + 1), R16
        STS     (g_sRfTx + 2), R16
        STS     (g_sRfTx + 3), R16
        STS     (g_sRfTx + 4), R16
        STS     (g_sRfTx + 5), R16
        RET
          CFI EndBlock cfiBlock1
//  291 
//  292 /*---------------------------------------------------------------------------*/
//  293 /** \brief <b>ATA_rfTxClose_C</b>
//  294     closes the RFTX module by disabling RFTX specific parts.
//  295     
//  296     Variable Usage:
//  297     \li [out] ::g_sRfTx Global RF Tx component data
//  298     \li [out] ::g_bVcoTuningResult Global RF Tx VCO tuning component data
//  299     \li [out] ::g_bAntennaTuningResult Global RF Tx Antenna tuning component data
//  300 
//  301     \image html ATA_rfTxClose_C.png
//  302 
//  303     \internal
//  304     \li 010: Close Timer2 by calling function ::ATA_timer2Close_C and Timer3 by
//  305              calling function ::ATA_timer3Close_C to allow usage in customer
//  306              application
//  307     \li 020: Remove power from the following HW IPs
//  308                  - TXDSP module
//  309                  - CRC module
//  310                  - D-FIFO
//  311                  - S-FIFO
//  312                  - Sequencer State Machine
//  313                  - TX Modulator module
//  314     \li 030: Reset RFTX Module global variables which contains
//  315                  - VCO tuning result (::g_bVcoTuningResult)
//  316                  - Antenna tuning result (::g_bAntennaTuningResult)
//  317     \li 040: Reset RFTX Module configuration ::g_sRfTx
//  318 
//  319     \Derived{No}
//  320 
//  321     \Rationale{N/A}
//  322 
//  323     \Traceability{Primus2P-846}
//  324     \endinternal
//  325 \n
//  326  */
//  327 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
//  328 VOIDFUNC ATA_rfTxClose_C(void)
ATA_rfTxClose_C:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function ATA_rfTxClose_C
//  329 {
//  330     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxClose_C, 0x00);
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxClose_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxClose_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
//  331 
//  332     /* LLR-Ref: 010 */
//  333     ATA_timer2Close_C();
          CFI FunCall ATA_timer2Close_C
        CALL    ATA_timer2Close_C
//  334     ATA_timer3Close_C();
          CFI FunCall ATA_timer3Close_C
        CALL    ATA_timer3Close_C
//  335 
//  336     /* LLR-Ref: 020 */
//  337     ATA_POWEROFF_C(PRR0, PRTXDC)
        SBI     0x1A, 0x02
//  338     ATA_POWEROFF_C(PRR0, PRCRC)
        SBI     0x1A, 0x03
//  339 
//  340     ATA_POWEROFF_C(PRR2, PRDF)
        SBI     0x02, 0x03
//  341     ATA_POWEROFF_C(PRR2, PRSF)
        SBI     0x02, 0x02
//  342     ATA_POWEROFF_C(PRR2, PRSSM)
        SBI     0x02, 0x07
//  343     ATA_POWEROFF_C(PRR2, PRTM)
        SBI     0x02, 0x06
//  344 
//  345     /* LLR-Ref: 030 */
//  346     g_bVcoTuningResult = 0U;
        RJMP    ?Subroutine0
          CFI EndBlock cfiBlock2
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_PRR0
        REQUIRE _A_PRR2
//  347     g_bAntennaTuningResult = 0U;
//  348 
//  349     /* LLR-Ref: 040 */
//  350     g_sRfTx.bFlags      = 0x00U;
//  351     g_sRfTx.bTuneFlags  = 0x00U;
//  352     g_sRfTx.bStatus     = 0x00U;
//  353     g_sRfTx.bConfig     = 0x00U;
//  354     g_sRfTx.pAddress   = 0x0000U;
//  355 }
//  356 
//  357 /*---------------------------------------------------------------------------*/
//  358 /** \brief <b>ATA_rfTxFillDFifo_C</b>
//  359     writes payload data to the D-FIFO.
//  360 
//  361     \param[in]      bLen     Number of payload bytes to be written to D-FIFO
//  362     \param[in]      pData    Pointer to the start of payload bytes
//  363 
//  364     \image html ATA_rfTxFillDFifo_C.png
//  365 
//  366     \internal
//  367     \li 010: Set data direction of D-FIFO to TX and store previous setting
//  368     \li 020: Copy length payload bytes starting from address pData to DFD
//  369               register of D-FIFO.
//  370     \li 030: Restore data direction of D-FIFO
//  371 
//  372     \Derived{No}
//  373 
//  374     \Rationale{N/A}
//  375 
//  376     \Traceability{Primus2P-845}
//  377     \endinternal
//  378 \n
//  379 */
//  380 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
//  381 VOIDFUNC ATA_rfTxFillDFifo_C(uint8_t bLen, uint8_t *pData)
ATA_rfTxFillDFifo_C:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function ATA_rfTxFillDFifo_C
          CFI NoCalls
//  382 {
//  383     /* LLR-Ref: 010 */
//  384     uint8_t tmp = DFC & BM_DFDRA;
        LDS     R20, _A_DFC
//  385     ATA_SETBITMASK_C(DFC,BM_DFDRA)
        LDS     R17, 218
        ORI     R17, 0x80
        STS     218, R17
//  386 
//  387     /* LLR-Ref: 020 */
//  388     for(uint8_t i=0; i<bLen;i++){
        LDI     R17, 0
        RJMP    ??ATA_rfTxFillDFifo_C_0
//  389         DFD = *pData++;
??ATA_rfTxFillDFifo_C_1:
        MOVW    R31:R30, R19:R18
        LD      R21, Z+
        MOVW    R19:R18, R31:R30
        STS     _A_DFD, R21
//  390     }
        INC     R17
??ATA_rfTxFillDFifo_C_0:
        CP      R17, R16
        BRCS    ??ATA_rfTxFillDFifo_C_1
//  391 
//  392     /* LLR-Ref: 030 */
//  393     if (!tmp) {
        BST     R20, 7
        BRTS    ??ATA_rfTxFillDFifo_C_2
//  394         ATA_CLEARBITMASK_C(DFC,BM_DFDRA)
        LDS     R16, 218
        ANDI    R16, 0x7F
        STS     218, R16
//  395     }
//  396 }
??ATA_rfTxFillDFifo_C_2:
        RET
          CFI EndBlock cfiBlock3
        REQUIRE _A_DFC
        REQUIRE _A_DFD
//  397 
//  398 /*---------------------------------------------------------------------------*/
//  399 /** \brief <b>ATA_rfTxFillSFifo_C</b>
//  400     writes preamble data to the S-FIFO.
//  401 
//  402     \param[in]      bLen     Number of payload bytes to be written to S-FIFO
//  403     \param[in]      pData    Pointer to the start of preamble bytes
//  404 
//  405     \image html ATA_rfTxFillSFifo_C.png
//  406 
//  407     \internal
//  408     \li 010: Set data direction of S-FIFO to TX and store previous setting
//  409     \li 020: Copy length preamble bytes starting from address pData to SFD
//  410               register of S-FIFO
//  411     \li 030: Restore data direction of S-FIFO
//  412 
//  413     \Derived{No}
//  414 
//  415     \Rationale{N/A}
//  416 
//  417     \Traceability{Primus2P-845}
//  418     \endinternal
//  419 \n
//  420 */
//  421 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
//  422 VOIDFUNC ATA_rfTxFillSFifo_C(uint8_t bLen, uint8_t *pData)
ATA_rfTxFillSFifo_C:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function ATA_rfTxFillSFifo_C
          CFI NoCalls
//  423 {
//  424     /* LLR-Ref: 010 */
//  425     uint8_t tmp = SFC & BM_SFDRA;
        LDS     R20, _A_SFC
//  426     ATA_SETBITMASK_C(SFC,BM_SFDRA)
        LDS     R17, 225
        ORI     R17, 0x80
        STS     225, R17
//  427 
//  428     /* LLR-Ref: 020 */
//  429     for(uint8_t i=0; i<bLen;i++){
        LDI     R17, 0
        RJMP    ??ATA_rfTxFillSFifo_C_0
//  430         SFD = *pData++;
??ATA_rfTxFillSFifo_C_1:
        MOVW    R31:R30, R19:R18
        LD      R21, Z+
        MOVW    R19:R18, R31:R30
        STS     _A_SFD, R21
//  431     }
        INC     R17
??ATA_rfTxFillSFifo_C_0:
        CP      R17, R16
        BRCS    ??ATA_rfTxFillSFifo_C_1
//  432 
//  433     /* LLR-Ref: 030 */
//  434     if (!tmp) {
        BST     R20, 7
        BRTS    ??ATA_rfTxFillSFifo_C_2
//  435         ATA_CLEARBITMASK_C(SFC,BM_SFDRA)
        LDS     R16, 225
        ANDI    R16, 0x7F
        STS     225, R16
//  436     }
//  437 }
??ATA_rfTxFillSFifo_C_2:
        RET
          CFI EndBlock cfiBlock4
        REQUIRE _A_SFC
        REQUIRE _A_SFD

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxInitCurrentService_C:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function ATA_rfTxInitCurrentService_C
        ST      -Y, R25
          CFI R25 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R24
          CFI R24 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        LDS     R16, (g_sRfTx + 3)
        LDS     R24, (g_sRfTx + 4)
        LDS     R25, (g_sRfTx + 5)
        LDI     R20, 8
        MOVW    R19:R18, R25:R24
        SBRS    R16, 3
        RJMP    ??ATA_rfTxInitCurrentService_C_0
        LDI     R16, LOW(g_sRfTxCurrentService)
        LDI     R17, (g_sRfTxCurrentService) >> 8
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        TST     R16
        BREQ    ??ATA_rfTxInitCurrentService_C_1
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 63
        STS     g_sDebug, R16
??ATA_rfTxInitCurrentService_C_1:
        ADIW    R25:R24, 8
        LDI     R20, 20
        MOVW    R19:R18, R25:R24
        LDI     R16, LOW((g_sRfTxCurrentService + 8))
        LDI     R17, HIGH((g_sRfTxCurrentService + 8))
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        TST     R16
        BREQ    ??ATA_rfTxInitCurrentService_C_2
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 63
        STS     g_sDebug, R16
??ATA_rfTxInitCurrentService_C_2:
        ADIW    R25:R24, 20
        LDI     R16, LOW((g_sRfTxCurrentService + 28))
        LDI     R17, HIGH((g_sRfTxCurrentService + 28))
        LDS     R18, (g_sRfTx + 3)
        ANDI    R18, 0x03
        BREQ    ??ATA_rfTxInitCurrentService_C_3
        ADIW    R25:R24, 5
        CPI     R18, 2
        BRCS    ??ATA_rfTxInitCurrentService_C_3
        ADIW    R25:R24, 5
??ATA_rfTxInitCurrentService_C_3:
        LDI     R20, 5
        MOVW    R19:R18, R25:R24
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        TST     R16
        BREQ    ??ATA_rfTxInitCurrentService_C_4
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 63
        STS     g_sDebug, R16
        RJMP    ??ATA_rfTxInitCurrentService_C_4
??ATA_rfTxInitCurrentService_C_0:
        LDI     R16, LOW(g_sRfTxCurrentService)
        LDI     R17, (g_sRfTxCurrentService) >> 8
          CFI FunCall ATA_globalsCopySramSpace_C
        CALL    ATA_globalsCopySramSpace_C
        ADIW    R25:R24, 8
        LDI     R20, 20
        MOVW    R19:R18, R25:R24
        LDI     R16, LOW((g_sRfTxCurrentService + 8))
        LDI     R17, HIGH((g_sRfTxCurrentService + 8))
          CFI FunCall ATA_globalsCopySramSpace_C
        CALL    ATA_globalsCopySramSpace_C
        ADIW    R25:R24, 20
        LDI     R16, LOW((g_sRfTxCurrentService + 28))
        LDI     R17, HIGH((g_sRfTxCurrentService + 28))
        LDS     R18, (g_sRfTx + 3)
        ANDI    R18, 0x03
        BREQ    ??ATA_rfTxInitCurrentService_C_5
        ADIW    R25:R24, 5
        CPI     R18, 2
        BRCS    ??ATA_rfTxInitCurrentService_C_5
        ADIW    R25:R24, 5
??ATA_rfTxInitCurrentService_C_5:
        LDI     R20, 5
        MOVW    R19:R18, R25:R24
          CFI FunCall ATA_globalsCopySramSpace_C
        CALL    ATA_globalsCopySramSpace_C
??ATA_rfTxInitCurrentService_C_4:
        LD      R24, Y+
          CFI R24 SameValue
          CFI CFA_Y Y+1
        LD      R25, Y+
          CFI R25 SameValue
          CFI CFA_Y Y+0
        RET
          CFI EndBlock cfiBlock5
//  438 
//  439 /*---------------------------------------------------------------------------*/
//  440 /** \brief <b>ATA_rfTxStartTx_C</b>
//  441     this function should be called to start RFTX.
//  442 
//  443     \param[in]      bConfig     Configuration of selected RFTXMode. For details see ::g_sRfTx .bConfig
//  444     \param[in]      pAddress    Pointer to Service/Channel configuration in EEPROM/SRAM
//  445 
//  446     Variable Usage:
//  447     \li [in,out] ::g_sRfTx Global RF Tx component data
//  448     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  449     \li [in] ::g_pRfTxBufStateMachine Global RF Tx (buffered) statemachine
//  450     \li [in] ::g_pRfTxTransStateMachine Global RF Tx (transparent) statemachine
//  451 
//  452     \image html ATA_rfTxStartTx_C.png
//  453 
//  454     \internal
//  455     \li 010: Stop currently running sequencer state machines to avoid
//  456              resource conflicts of sequencer state machine hardware\n\n
//  457              Note: Frontend register initialization is done in SW state
//  458              ::ATA_rfTxInitFrontEnd_C for all state machines in module RFTX
//  459 
//  460     \li 020: Enable AVCC to access the Frontend register after AVCC is stable
//  461 
//  462     \li 030: Initialize ::g_sRfTx with content of function arguments config and
//  463              pAddress. Signal RFTX Module active via flag ::g_sRfTx .bStatus[4]
//  464 
//  465     \li 040: Initialize ::g_sRfTxCurrentService by calling function
//  466              ::ATA_rfTxInitCurrentService_C
//  467 
//  468     \li 050: IF an error occured during initialization of the current RF Tx service,
//  469              THEN\n
//  470                 Deactivate active signal of RF Tx module via flag ::g_sRfTx
//  471                 .bStatus[4] being set to 0, AND Disable AVCC since it is not needed.
//  472 
//  473     \li 060: ELSE\n
//  474                Signal Direct Switching if possible, AND
//  475                Initialize SW state machine by setting SW state machine index to 0
//  476                and apply correct sw state machine to SW state machine pointer
//  477                in case of TXMode(transparent) set TMDI pin to input.\n
//  478              ENDIF
//  479 
//  480     \Derived{No}
//  481 
//  482     \Rationale{N/A}
//  483 
//  484     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
//  485     \endinternal
//  486 \n
//  487 */
//  488 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
//  489 VOIDFUNC ATA_rfTxStartTx_C(uint8_t bConfig, uint8_t *pAddress)
ATA_rfTxStartTx_C:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function ATA_rfTxStartTx_C
//  490 {
        ST      -Y, R24
          CFI R24 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        MOV     R20, R16
//  491     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxStartTx_C, bConfig);
        IN      R21, 0x3F
        CLI
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxStartTx_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxStartTx_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R21
//  492 
//  493     uint8_t bDirectSwitching = 0U;
//  494 
//  495     /* LLR-Ref: 010 */
//  496     SSMRR = BM_SSMST;
        LDI     R16, 2
        STS     _A_SSMRR, R16
//  497     bDirectSwitching = g_sRfTx.bFlags & BM_RFTXCONFIG_BFLAGS_RDY4TX;
        LDS     R24, g_sRfTx
//  498 
//  499     /* LLR-Ref: 020 */
//  500     ATA_SETBITMASK_C(SUPCR,BM_AVEN)
        LDS     R16, 204
        ORI     R16, 0x10
        STS     204, R16
//  501 
//  502     /* LLR-Ref: 030 */
//  503     g_sRfTx.bFlags = 0x00U;
        LDI     R16, 0
        STS     g_sRfTx, R16
//  504     g_sRfTx.bStatus = BM_RFTXCONFIG_BSTATUS_ACTIVE;
        LDI     R16, 16
        STS     (g_sRfTx + 2), R16
//  505     g_sRfTx.bConfig = bConfig;
        STS     (g_sRfTx + 3), R20
//  506     g_sRfTx.pAddress = pAddress;
        STS     (g_sRfTx + 4), R18
        STS     (g_sRfTx + 5), R19
//  507     /* --P2P-3655-- */
//  508     g_sRfTx.bCmcrSetting = CMCR;
        LDS     R16, _A_CMCR
        STS     (g_sRfTx + 6), R16
//  509 
//  510     /* LLR-Ref: 040 */
//  511     ATA_rfTxInitCurrentService_C();
          CFI FunCall ATA_rfTxInitCurrentService_C
        RCALL   ATA_rfTxInitCurrentService_C
//  512 
//  513     if (g_sRfTx.bFlags & BM_RFTXCONFIG_BFLAGS_ERROR)
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        SBRS    R16, 7
        RJMP    ??ATA_rfTxStartTx_C_0
//  514     {
//  515         /* LLR-Ref: 050 */
//  516         ATA_CLEARBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_ACTIVE)
        LDD     R16, Z+2
        ANDI    R16, 0xEF
        STD     Z+2, R16
//  517         ATA_CLEARBITMASK_C(SUPCR,BM_AVEN)
        LDS     R16, 204
        ANDI    R16, 0xEF
        STS     204, R16
        RJMP    ??ATA_rfTxStartTx_C_1
//  518     }
//  519     else
//  520     {
//  521         /* LLR-Ref: 060 */
//  522         if(bDirectSwitching)
??ATA_rfTxStartTx_C_0:
        BST     R24, 6
        BRTC    ??ATA_rfTxStartTx_C_2
//  523         {
//  524             ATA_SETBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_DIRECT_SWITCH)
        LDD     R16, Z+2
        ORI     R16, 0x80
        STD     Z+2, R16
//  525         }
//  526 
//  527         g_sRfTxFlowCtrl.bIndex = 0U;
??ATA_rfTxStartTx_C_2:
        LDI     R16, 0
        STS     g_sRfTxFlowCtrl, R16
//  528 
//  529         if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_TRANSPARENT_MODE)
        LDD     R16, Z+3
        SBRS    R16, 5
        RJMP    ??ATA_rfTxStartTx_C_3
//  530         {
//  531             /* TXMode(transparent) */
//  532             g_sRfTxFlowCtrl.fpLut  = g_pRfTxTransStateMachine;
        LDS     R16, g_pRfTxTransStateMachine
        LDS     R17, (g_pRfTxTransStateMachine + 1)
        STS     (g_sRfTxFlowCtrl + 1), R16
        STS     (g_sRfTxFlowCtrl + 2), R17
//  533             
//  534             ATA_CLEARBITMASK_C(DDRD,BM_TMDI)
        CBI     0x0A, 0x04
//  535             ATA_CLEARBITMASK_C(PORTD,BM_TMDI)
        CBI     0x0B, 0x04
        RJMP    ??ATA_rfTxStartTx_C_1
//  536         }
//  537         else
//  538         {
//  539             /* TXMode(buffered) */
//  540             g_sRfTxFlowCtrl.fpLut  = g_pRfTxBufStateMachine;
??ATA_rfTxStartTx_C_3:
        LDS     R16, g_pRfTxBufStateMachine
        LDS     R17, (g_pRfTxBufStateMachine + 1)
        STS     (g_sRfTxFlowCtrl + 1), R16
        STS     (g_sRfTxFlowCtrl + 2), R17
//  541         }
//  542     }
//  543 }
??ATA_rfTxStartTx_C_1:
          CFI EndBlock cfiBlock6
        REQUIRE ?Subroutine3
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SSMRR
        REQUIRE _A_SUPCR
        REQUIRE _A_CMCR
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        ;               // Fall through to label ?Subroutine3

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI NoFunction
          CFI CFA_Y Y+1
          CFI R24 Frame(CFA_Y, -1)
//  544 
//  545 /*---------------------------------------------------------------------------*/
//  546 /** \brief <b>ATA_rfTxStop_C</b>
//  547     is used as API function to shutdown a currently running TXMode
//  548     
//  549     \image html ATA_rfTxStop_C.png
//  550 
//  551     \internal
//  552     \li 010: Shutdown currently running TXMode by calling function
//  553              ::ATA_rfTxShutdown_C
//  554 
//  555     \Derived{No}
//  556 
//  557     \Rationale{N/A}
//  558 
//  559     \Traceability{Primus2P-895}
//  560     \endinternal
//  561 \n
//  562 */
//  563 /*---------------------------------------------------------------------------*/
//  564 VOIDFUNC ATA_rfTxStop_C(void)
//  565 {
//  566     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxStop_C, 0x00);
//  567     /* LLR-Ref: 010 */
//  568     ATA_rfTxShutdown_C();
//  569 }
//  570 
//  571 /*---------------------------------------------------------------------------*/
//  572 /** \brief <b>ATA_rfTxProcessing_C</b>
//  573     triggers the active SW state of currently running SW state machine. This
//  574     function should be placed in main loop context or should be run periodically
//  575     to ensure RFTX functionality.
//  576 
//  577     Variable Usage:
//  578     \li [in] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  579 
//  580     \image html ATA_rfTxProcessing_C.png
//  581 
//  582     \internal
//  583     \li 010: Decode and execute currently active SW state
//  584 
//  585     \Derived{No}
//  586 
//  587     \Rationale{N/A}
//  588 
//  589     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
//  590     \endinternal
//  591 \n
//  592 */
//  593 /*---------------------------------------------------------------------------*/
//  594 VOIDFUNC ATA_rfTxProcessing_C(void)
//  595 {
//  596     sysFlowStateMachineFunc_t fpFunc;
//  597 
//  598     /* LLR-Ref: 010 */
//  599     fpFunc = *(sysFlowStateMachineFunc_t)g_sRfTxFlowCtrl.fpLut[g_sRfTxFlowCtrl.bIndex];
//  600     fpFunc();
//  601 }
//  602 
//  603 /*---------------------------------------------------------------------------*/
//  604 /** \brief <b>ATA_rfTxInitTxSSM_C</b>
//  605     this sw state does the register initialization according to the selected
//  606     service channel configuration. Note: FE register are initialized after AVCC
//  607     is stable in sw state ::ATA_rfTxInitFrontEnd_C
//  608 
//  609     Variable Usage:
//  610     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  611     \li [in] ::g_sRfTx Global RF Tx component data
//  612     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
//  613 
//  614     \image html ATA_rfTxInitTxSSM_C.png
//  615 
//  616     \internal
//  617     \li 010: Power up the TX DSP HW block and the Sequencer State Machine HW block
//  618     \li 020: Initialize the frequency registers with selected Service/Channel
//  619              configuration via function ::ATA_rfTxFrequencySettings_C
//  620     \li 030: Enable the Sigma-Delta Modulator by accessing FSEN.SDEN
//  621     \li 040: Set FSCR.TXMS[1..0] according to selected TXMode
//  622                  - TXMode(buffered)      FSCR.TXMS = 10 - Tx Modulator serial output
//  623                  - TXMode(transparent)   FSCR.TXMS = 01 - TMDI input pin
//  624     \li 050: Set FSCR.TXMOD according to selected modulation type
//  625                  - ASK Modulation: FSCR.SFM   = 0
//  626                                    FSCR.TXMOD = 1
//  627                  - FSK Modulation: FSCR.SFM   = 1
//  628     \li 060: Initialize following register according to service channel configuration
//  629                  - FSFCR
//  630                  - GACDIVL/H
//  631     \li 070: Initialize TX Modulator registers by calling function
//  632              ::ATA_rfTxSetupTxModulator_C
//  633     \li 080: Initialize Sequencer State Machine registers by calling function
//  634              ::ATA_rfTxConfigureTxSSM_C
//  635     \li 090: Switch to next sw state by incrementing ::g_sRfTxFlowCtrl .bIndex
//  636 
//  637     \Derived{No}
//  638 
//  639     \Rationale{N/A}
//  640 
//  641     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
//  642     \endinternal
//  643 \n
//  644 */
//  645 /*---------------------------------------------------------------------------*/
//  646 VOIDFUNC ATA_rfTxInitTxSSM_C(void)
//  647 {
//  648     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxInitTxSSM_C, 0x00);
//  649     /* LLR-Ref: 010 */
//  650     ATA_POWERON_C(PRR0, PRTXDC)
//  651     ATA_POWERON_C(PRR2, PRSSM)
//  652 
//  653     /* LLR-Ref: 020 */
//  654     ATA_rfTxFrequencySettings_C();
//  655 
//  656     /* LLR-Ref: 030 */
//  657     ATA_SETBITMASK_C(FSEN,BM_SDEN)
//  658 
//  659     /* LLR-Ref: 040 */
//  660     ATA_CLEARBITMASK_C(FSCR,BM_TXMOD)
//  661 
//  662     if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_TRANSPARENT_MODE) {
//  663         /* Transparent mode */
//  664         ATA_SETBITMASK_C(FSCR,BM_TXMS0)
//  665     }
//  666     else {
//  667         /* Buffered mode */
//  668         ATA_SETBITMASK_C(FSCR,BM_TXMS1)
//  669     }
//  670 
//  671     /* LLR-Ref: 050 */
//  672     if( g_sRfTxCurrentService.sPath.bTxSetPath[1] & BM_RFTXSERVICE_BTXSETPATH_MODULATION ) {
//  673         /* ASK modulation */
//  674         ATA_SETBITMASK_C(FSCR,BM_TXMOD)
//  675     }
//  676     else {
//  677         /* FSK modulation */
//  678         ATA_SETBITMASK_C(FSCR,BM_SFM)
//  679     }
//  680 
//  681     /* LLR-Ref: 060 */
//  682     FSFCR   = g_sRfTxCurrentService.sPath.bFSFCR;
//  683     GACDIVL = g_sRfTxCurrentService.sPath.bGACDIV[0];
//  684     GACDIVH = g_sRfTxCurrentService.sPath.bGACDIV[1];
//  685 
//  686     /* LLR-Ref: 070 */
//  687     ATA_rfTxSetupTxModulator_C();
//  688 
//  689     /* LLR-Ref: 080 */
//  690     ATA_rfTxConfigureTxSSM_C();
//  691 
//  692     /* LLR-Ref: 090 */
//  693     g_sRfTxFlowCtrl.bIndex++;
//  694 }
//  695 
//  696 /*---------------------------------------------------------------------------*/
//  697 /** \brief <b>ATA_rfTxWait4AVCC_C</b>
//  698     waits until AVCC is stable and switches to next sw state if AVCC is stable.
//  699 
//  700     Variable Usage:
//  701     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  702     \li [in] ::g_sRfTx Global RF Tx component data
//  703     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
//  704 
//  705     \image html ATA_rfTxWait4AVCC_C.png
//  706 
//  707     \internal
//  708     \li 010: Clear AVCC related flags SUPFR.AVCCLF and SUPFR.AVCCRF
//  709     \li 020: IF AVCC is stable, indicated by both flags SUPFR.AVCCLF and
//  710              SUPFR.AVCCRF being set to 0,\n
//  711              switch to next sw state by incrementing ::g_sRfTxFlowCtrl .bIndex
//  712 
//  713     \Derived{No}
//  714 
//  715     \Rationale{N/A}
//  716 
//  717     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
//  718     \endinternal
//  719 \n
//  720 */
//  721 /*---------------------------------------------------------------------------*/
//  722 VOIDFUNC ATA_rfTxWait4AVCC_C(void)
//  723 {
//  724     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxWait4AVCC_C, 0x00);
//  725 
//  726     /* LLR-Ref: 010 */
//  727     ATA_SETBITMASK_C(SUPFR,(BM_AVCCLF | BM_AVCCRF))
//  728 
//  729     /* LLR-Ref: 020 */
//  730     if ( (SUPFR & (BM_AVCCLF|BM_AVCCRF)) == 0 )
//  731     {
//  732         g_sRfTxFlowCtrl.bIndex++;
//  733     }
//  734 }
//  735 
//  736 /*---------------------------------------------------------------------------*/
//  737 /** \brief <b>ATA_rfTxInitFrontEnd_C</b>
//  738     initializes the frontend registers according to the selected service channel
//  739     configuration.
//  740 
//  741     Variable Usage:
//  742     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  743     \li [out] ::g_sDebug Global Debug component data
//  744     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
//  745 
//  746     \image html ATA_rfTxInitFrontEnd_C.png
//  747 
//  748     \internal
//  749     \li 010: Initialize FETN4 register with EEPROM content ::g_sEepFacLockRfFrontend
//  750              .bFETN4
//  751     \li 020: Switch on XTO by setting FEEN1.XTOEN
//  752     \li 040: Initialize FEAT register
//  753     \li 050: Initialize FEBT register with with EEPROM content
//  754              ::g_sEepFacLockRfFrontend .bFEBT
//  755     \li 060: Initialize FEPAC register
//  756     \li 070: Initialize FEVCO register by calling function
//  757              ::ATA_rfTxFevcoCalculation_C
//  758     \li 080: Set FEEN2.SDTX to switch the antenna SPDT_ANT to the TX power
//  759              amplifier SPDT_TX
//  760     \li 090: Initialize FECR register
//  761     \li 100: Initialize FEMS register
//  762     \li 110: Initialize FEVCT register
//  763     \li 120: Increase the internal bias current of the AVCC regulator if FEPAC
//  764              setting is less than 0x2B
//  765     \li 130: Initialize FEANT register
//  766     \li 140: Initialize FEALR register
//  767     \li 150: Switch to next SW state by incrementing ::g_sRfTxFlowCtrl .bIndex
//  768 
//  769     \Derived{No}
//  770 
//  771     \Rationale{N/A}
//  772 
//  773     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868,\ 
//  774                   Primus2P-2443}
//  775     \endinternal
//  776 \n
//  777 */
//  778 /*---------------------------------------------------------------------------*/
//  779 VOIDFUNC ATA_rfTxInitFrontEnd_C(void)
//  780 {
//  781     uint8_t tmp;
//  782     eEepErrorCode sEepErrCode;
//  783 
//  784     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxInitFrontEnd_C, 0x00);
//  785 
//  786     /* LLR-Ref: 010 */
//  787     sEepErrCode = ATA_eepReadBytes_C(&tmp, (uint16_t)&g_sAtmelEEPromSection.eepFETN4, 1U);
//  788     if(sEepErrCode != EEC_NO_ERROR)
//  789     {
//  790         ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
//  791         g_sDebug.bErrorCode = DEBUG_ERROR_CODE_RFTX_EEPROM_READ_ERROR;
//  792     }
//  793     
//  794     FETN4 = tmp;
//  795 
//  796     /* LLR-Ref: 020 */
//  797     ATA_SETBITMASK_C(FEEN1,BM_XTOEN)
//  798 
//  799     /* LLR-Ref: 040 */
//  800     FEAT = g_sRfTxCurrentService.sService.bFEAT;
//  801 
//  802     /* LLR-Ref: 050 */
//  803     sEepErrCode = ATA_eepReadBytes_C(&tmp, (uint16_t)&g_sAtmelEEPromSection.eepFEBT, 1U);
//  804     if(sEepErrCode != EEC_NO_ERROR)
//  805     {
//  806         ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
//  807         g_sDebug.bErrorCode = DEBUG_ERROR_CODE_RFTX_EEPROM_READ_ERROR;
//  808     }
//  809 
//  810     FEBT = tmp;
//  811     
//  812     /* LLR-Ref: 060 */
//  813     FEPAC = g_sRfTxCurrentService.sService.bFEPAC;
//  814 
//  815     /* LLR-Ref: 070 */
//  816     FEVCO = ATA_rfTxFevcoCalculation_C();
//  817 
//  818     /* LLR-Ref: 090 */
//  819     FECR  = g_sRfTxCurrentService.sChannel.bFECR;
//  820     /* LLR-Ref: 100 */
//  821     FEMS  = g_sRfTxCurrentService.sChannel.bFEMS;
//  822     /* LLR-Ref: 110 */
//  823     FEVCT = g_sRfTxCurrentService.sService.bFEVCT;
//  824 
//  825     /* LLR-Ref: 120 */
//  826     if (g_sRfTxCurrentService.sService.bFEPAC < 0x2BU)
//  827     {}
//  828     else
//  829     {
//  830         ATA_SETBITMASK_C(SUPCR,BM_AVDIC)
//  831     }
//  832     /* setting of FEALR.RNGE necessary for Antenna tuning (SSM review 22jul2011) */
//  833     /* LLR-Ref: 130 */
//  834     FEANT = (g_sRfTxCurrentService.sService.bFEALR_FEANT & 0x0FU);
//  835     /* LLR-Ref: 140 */
//  836     FEALR = ((g_sRfTxCurrentService.sService.bFEALR_FEANT & 0x30U) >> 4U);
//  837 
//  838     /* LLR-Ref: 150 */
//  839     g_sRfTxFlowCtrl.bIndex++;
//  840 }
//  841 /*---------------------------------------------------------------------------*/
//  842 /** \brief <b>ATA_rfTxWait4XTO_C</b>
//  843     waits until XTO is ready. If AVR is not running with CLKXTO4 the
//  844     core clock is switched to CLKXTO4.
//  845 
//  846     Variable Usage:
//  847     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  848 
//  849     \image html ATA_rfTxWait4XTO_C.png
//  850 
//  851     \internal
//  852     \li 010: Check if XTO is available via flag FESR.XRDY
//  853              IF XTO is ready\n
//  854     \li 020:   Check if AVR core is running with other clock than CLKXTO4 via
//  855                flag CMCR.CMM2 and CMCR.CCS\n
//  856                IF AVR core is not running with CLKXTO4\n
//  857     \li 030:     Switch AVR core clock to CLKXTO4 by calling function
//  858                  ::ATA_globalsClkSwitchXTO_C
//  859     \li 040:     Switch to next SW state by incrementing ::g_sRfTxFlowCtrl .bIndex
//  860 
//  861     \Derived{No}
//  862 
//  863     \Rationale{N/A}
//  864 
//  865     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
//  866     \endinternal
//  867 \n
//  868 */
//  869 /*---------------------------------------------------------------------------*/
//  870 VOIDFUNC ATA_rfTxWait4XTO_C(void)
//  871 {
//  872     /* LLR-Ref: 010 */
//  873     if (FESR & BM_XRDY) {
//  874 
//  875         ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxWait4XTO_C, 0x00);
//  876 
//  877         /* LLR-Ref: 020 */
//  878         if (  ((CMCR & BM_CMM2) == 0)
//  879             ||((CMCR & BM_CCS ) == 0)
//  880            ){
//  881             /* LLR-Ref: 030 */
//  882             ATA_globalsClkSwitchXTO_C(0x07U);
//  883         }
//  884 
//  885         /* LLR-Ref: 040 */
//  886         g_sRfTxFlowCtrl.bIndex++;
//  887     }
//  888 }
//  889 
//  890 /*---------------------------------------------------------------------------*/
//  891 /** \brief <b>ATA_rfTxStartTxBufSSM_C</b>
//  892     starts the sequencer state machine for TxMode(buffered).
//  893 
//  894     \image html ATA_rfTxStartTxBufSSM_C.png
//  895 
//  896     \internal
//  897     \li 010: Call function ::ATA_rfTxStartSSM_C to configure the RF Tx statemachine
//  898              to execute the Tx buffered shutdown sequence
//  899 
//  900     \Derived{No}
//  901 
//  902     \Rationale{N/A}
//  903 
//  904     \Traceability{Primus2P-847}
//  905     \endinternal
//  906 \n
//  907 */
//  908 /*---------------------------------------------------------------------------*/
//  909 VOIDFUNC ATA_rfTxStartTxBufSSM_C(void)
//  910 {
//  911     /* LLR-Ref: 010 */
//  912     ATA_rfTxStartSSM_C(RFTX_BUF_STATE_SHUTDOWN);
//  913 }
//  914 
//  915 /*---------------------------------------------------------------------------*/
//  916 /** \brief <b>ATA_rfTxStartTxTransSSM_C</b>
//  917     starts the sequencer state machine for TxMode(transparent)
//  918 
//  919     \image html ATA_rfTxStartTxTransSSM_C.png
//  920 
//  921     \internal
//  922     \li 010: Call function ::ATA_rfTxStartSSM_C to configure the RF Tx statemachine
//  923              to execute the Tx transparent shutdown sequence
//  924 
//  925     \Derived{No}
//  926 
//  927     \Rationale{N/A}
//  928 
//  929     \Traceability{Primus2P-848}
//  930     \endinternal
//  931 \n
//  932 */
//  933 /*---------------------------------------------------------------------------*/
//  934 VOIDFUNC ATA_rfTxStartTxTransSSM_C(void)
//  935 {
//  936     /* LLR-Ref: 010 */
//  937     ATA_rfTxStartSSM_C(RFTX_TRANS_STATE_SHUTDOWN);
//  938 }
//  939 
//  940 /*---------------------------------------------------------------------------*/
//  941 /** \brief <b>ATA_rfTxStartSSM_C</b>
//  942     starts the sequencer state machine.
//  943 
//  944     \param[in]      bState              SW state to switch to in case of an immediate RF Tx shutdown
//  945 
//  946     Variable Usage:
//  947     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
//  948     \li [out] ::g_sRfTx Global RF Tx component data
//  949     \li [out] ::g_sDebug Global Debug component data
//  950 
//  951     \image html ATA_rfTxStartSSM_C.png
//  952 
//  953     \internal
//  954     \li 010: Clear SSM Interrupt Flag Register (SSMIFR)
//  955     \li 020: Clear SSM status register (SSMSR)
//  956     \li 030: Clear flag ::g_sRfTx .bStatus[6]
//  957     \li 040: Enable SSM finished interrupt by setting flag SSMIMR.SSMIM in
//  958              SSM Interrupt Mask Register (SSMIMR)
//  959     \li 050: Start Watchdog with timeout for SSM by calling function
//  960              ::ATA_rfTxStartSsmWatchdog_C\n
//  961              IF SSM Watchdog is locked
//  962     \li 060:     Signal error via flag ::g_sRfTx .bFlags[7]
//  963     \li 070:     Write error code to ::g_sDebug .bErrorCode and ::g_sDebug
//  964                  .bSsmErrorCode
//  965     \li 080:     Switch to shutdown sw state by setting ::g_sRfTxFlowCtrl .bIndex\n
//  966              IF SSM Watchdog has started correctly
//  967     \li 090:     Start SSM by setting flag SSMR in SSM Run Register (SSMRR)
//  968     \li 100:     Switch to next SW state by incrementing ::g_sRfTxFlowCtrl .bIndex
//  969 
//  970     \Derived{No}
//  971 
//  972     \Rationale{N/A}
//  973 
//  974     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
//  975     \endinternal
//  976 \n
//  977 */
//  978 /*---------------------------------------------------------------------------*/
//  979 VOIDFUNC ATA_rfTxStartSSM_C(uint8_t bState)
//  980 {
//  981     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxStartSSM_C, 0x00);
//  982 
//  983     /* LLR-Ref: 010 */
//  984     SSMIFR = 0x00U;
//  985 
//  986     /* LLR-Ref: 020 */
//  987     ATA_SETBITMASK_C(SSMSR,BM_SSMERR)
//  988 
//  989     /* LLR-Ref: 030 */
//  990     ATA_CLEARBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_SSMREADY)
//  991 
//  992     /* LLR-Ref: 040 */
//  993     SSMIMR = BM_SSMIM;
//  994 
//  995     /* LLR-Ref: 050 */
//  996     if( ATA_rfTxStartSsmWatchdog_C() )
//  997     {
//  998         /* LLR-Ref: 060 */
//  999         ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1000 
// 1001         /* LLR-Ref: 070 */
// 1002         g_sDebug.bErrorCode    = DEBUG_ERROR_CODE_RFTX_STARTSSM_TIMER_LOCKED;
// 1003         g_sDebug.bSsmErrorCode = 0U;
// 1004 
// 1005         /* LLR-Ref: 080 */
// 1006         g_sRfTxFlowCtrl.bIndex = bState;
// 1007     }
// 1008     else
// 1009     {
// 1010         /* LLR-Ref: 090 */
// 1011         SSMRR = BM_SSMR;
// 1012 
// 1013         /* LLR-Ref: 100 */
// 1014         g_sRfTxFlowCtrl.bIndex++;
// 1015     }
// 1016 }
        LD      R24, Y+
          CFI CFA_Y Y+0
          CFI R24 SameValue
        RET
          CFI EndBlock cfiBlock7
// 1017 
// 1018 /*---------------------------------------------------------------------------*/
// 1019 /** \brief <b>ATA_rfTxWait4SSMrdy_C</b>
// 1020     waits until the sequencer state machine is ready.
// 1021 
// 1022     Variable Usage:
// 1023     \li [in,out] ::g_sRfTx Global RF Tx component data
// 1024     \li [in,out] ::g_sRfTxCurrentService Global RF Tx current service data
// 1025     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
// 1026     \li [out] ::g_sDebug Global Debug component data
// 1027     \li [out] ::g_bVcoTuningResult Global RF Tx VCO tuning component data
// 1028     \li [out] ::g_bAntennaTuningResult Global RF Tx Antenna tuning component data
// 1029 
// 1030     \image html ATA_rfTxWait4SSMrdy_C.png
// 1031 
// 1032     \internal
// 1033             Note:
// 1034             The SSM watchdog is stopped, i.e. Timer 2 is closed in function 
// 1035             ATA_rfTxShutDown_C() in case the SSM watchdog has expired (ELSE-clause)
// 1036 
// 1037     \li 010: Check if SSM has finished with success via ::g_sRfTx .bStatus[6]
// 1038              and SSM status register SSMSR\n
// 1039              IF SSM has finished with success
// 1040     \li 020:   Stop SSM Watchdog
// 1041     \li 030:   Clear RF Tx SSM ready in ::g_sRfTx .bStatus[6]
// 1042     \li 040:   Signal RF Tx Module ready for transmission in ::g_sRfTx .bFlags[6]
// 1043     \li 045:   Store Antenna Tuning and VCO Tuning values in current service
// 1044                and dedicated tuning result variables
// 1045                (::g_bVcoTuningResult,::g_bAntennaTuningResult)
// 1046     \li 050:   IF TXMode(transparent) is selected, activate the power amplifier
// 1047                 by setting FSCR.PAOER
// 1048     \li 060:     Switch to next SW state by incrementing ::g_sRfTxFlowCtrl .bIndex\n
// 1049              ELSE (SSM has not finished)
// 1050     \li 070:   Check for
// 1051                  - SSM Watchdog timeout via flag T2IFR.T2COF
// 1052                  - SSM Error via register SSMSR\n
// 1053                  IF Watchdog timeout or SSM Error has occured
// 1054     \li 080:       Reset current running sequencer state machine
// 1055     \li 100:       Signal error via flag ::g_sRfTx .bFlags[7]
// 1056     \li 110:       Write error code to ::g_sDebug .bErrorCode and ::g_sDebug
// 1057                    .bSsmErrorCode
// 1058     \li 120:       Switch to shutdown SWstate by setting ::g_sRfTxFlowCtrl .bIndex
// 1059                      - to RFTX_TRANS_STATE_SHUTDOWN in TXMode(transparent)
// 1060                      - to RFTX_BUF_STATE_SHUTDOWN in TXMode(buffered)
// 1061 
// 1062     \Derived{No}
// 1063 
// 1064     \Rationale{N/A}
// 1065 
// 1066     \Traceability{Primus2P-849,Primus2P-848,Primus2P-847}
// 1067     \endinternal
// 1068 \n
// 1069 */
// 1070 /*---------------------------------------------------------------------------*/
// 1071 VOIDFUNC ATA_rfTxWait4SSMrdy_C(void)
// 1072 {
// 1073     /* LLR-Ref: 010 */
// 1074     if( (g_sRfTx.bStatus & BM_RFTXCONFIG_BSTATUS_SSMREADY) && (SSMSR == 0x00U) )
// 1075     {
// 1076         ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxWait4SSMrdy_C, 0x00);
// 1077 
// 1078         /* LLR-Ref: 020 */
// 1079         ATA_rfTxStopSsmWatchdog_C();
// 1080 
// 1081         /* LLR-Ref: 030 */
// 1082         ATA_CLEARBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_SSMREADY)
// 1083 
// 1084         /* LLR-Ref: 040 */
// 1085         ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_RDY4TX)
// 1086 
// 1087         /* LLR-Ref: 045 */
// 1088         g_sRfTxCurrentService.sService.bFEAT = FEAT;
// 1089         g_bAntennaTuningResult = g_sRfTxCurrentService.sService.bFEAT;
// 1090         g_sRfTxCurrentService.sService.bFEVCT = FEVCT;
// 1091         g_bVcoTuningResult = g_sRfTxCurrentService.sService.bFEVCT;
// 1092 
// 1093         /* LLR-Ref: 050 */
// 1094         if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_TRANSPARENT_MODE) {
// 1095             ATA_SETBITMASK_C(FSCR,BM_PAOER)
// 1096         }
// 1097 
// 1098         /* LLR-Ref: 060 */
// 1099         g_sRfTxFlowCtrl.bIndex++;
// 1100     }
// 1101     else {
// 1102         /* LLR-Ref: 070 */
// 1103         if( (T2IFR & BM_T2COF) || SSMSR )
// 1104         {
// 1105             /* LLR-Ref: 080 */
// 1106             SSMRR = BM_SSMST;       /* reset current state machine */
// 1107 
// 1108             /* LLR-Ref: 100 */
// 1109             ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1110 
// 1111             /* LLR-Ref: 110 */
// 1112             g_sDebug.bErrorCode    = DEBUG_ERROR_CODE_RFTX_WAIT4SSMRDY_TIMEOUT;
// 1113             g_sDebug.bSsmErrorCode = SSMSR;
// 1114 
// 1115             /* LLR-Ref: 120 */
// 1116             if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_TRANSPARENT_MODE) {
// 1117                 g_sRfTxFlowCtrl.bIndex = RFTX_TRANS_STATE_SHUTDOWN;
// 1118             }
// 1119             else {
// 1120                 g_sRfTxFlowCtrl.bIndex = RFTX_BUF_STATE_SHUTDOWN;
// 1121             }
// 1122         }
// 1123     }
// 1124 
// 1125 }
// 1126 
// 1127 /*---------------------------------------------------------------------------*/
// 1128 /** \brief <b>ATA_rfTxTransparentMode_C</b>
// 1129     is an empty function. This SW state is reached after TXMode(transparent)
// 1130     has started correctly.
// 1131 
// 1132     \image html ATA_rfTxTransparentMode_C.png
// 1133 
// 1134     \internal
// 1135     \Derived{Yes}
// 1136 
// 1137     \Rationale{This function is required as a placeholder to stay in Tx transparent
// 1138                mode until the Application SW shuts down Tx transparent mode}
// 1139 
// 1140     \Traceability   N/A
// 1141     \endinternal
// 1142 \n
// 1143 */
// 1144 /*---------------------------------------------------------------------------*/
// 1145 VOIDFUNC ATA_rfTxTransparentMode_C(void)
// 1146 {
// 1147     /* remove trace to avoid trace overflow
// 1148      * ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxTransparentMode_C, 0x00);
// 1149      * do nothing --> system in TXMode(transparent) */
// 1150 }
// 1151 
// 1152 /*---------------------------------------------------------------------------*/
// 1153 /** \brief <b>ATA_rfTxWait4FillLevel_C</b>
// 1154     checks the fill levels of S-FIFO and D-FIFO
// 1155 
// 1156     Variable Usage:
// 1157     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
// 1158     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 1159 
// 1160     \image html ATA_rfTxWait4FillLevel_C.png
// 1161 
// 1162     \internal
// 1163     \li 010:    read out start fill levels for S-FIFO (Preamble FIFO) and D-FIFO
// 1164                 (Data FIFO) from current service channel configuration
// 1165     \li 020:    check if S-FIFO and D-FIFO fill levels are greater or equal the
// 1166                 corresponding start fill levels
// 1167                 IF both fill level conditions are true
// 1168     \li 030:        switch to next sw state by incrementing variable g_sRfTxFlowCtrl.bIndex
// 1169 
// 1170     \Derived{No}
// 1171 
// 1172     \Rationale{N/A}
// 1173 
// 1174     \Traceability{Primus2P-847}
// 1175     \endinternal
// 1176 \n
// 1177 */
// 1178 /*---------------------------------------------------------------------------*/
// 1179 VOIDFUNC ATA_rfTxWait4FillLevel_C(void)
// 1180 {
// 1181     /* LLR-Ref: 010 */
// 1182     uint8_t bTxFifoStartFillLevel = g_sRfTxCurrentService.sPath.bTxSetPath[0] & 0x3F;
// 1183     uint8_t bPreambleFifoStartFillLevel = g_sRfTxCurrentService.sPath.bTxSetPath[1] & 0x1F;
// 1184 
// 1185     /* LLR-Ref: 020 */
// 1186     if(    ( bTxFifoStartFillLevel       <= (DFL & BM_DFFLS) )
// 1187         && ( bPreambleFifoStartFillLevel <= (SFL & BM_SFFLS) ) ) {
// 1188 
// 1189         ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxWait4FillLevel_C, 0x00);
// 1190 
// 1191         /* LLR-Ref: 030 */
// 1192         g_sRfTxFlowCtrl.bIndex++;
// 1193     }
// 1194 }
// 1195 
// 1196 /*---------------------------------------------------------------------------*/
// 1197 /** \brief <b>ATA_rfTxStartTxModulator_C</b>
// 1198     configures the fill level interrupts, starts the TX Modulator and
// 1199     SendTelegramSSM.
// 1200 
// 1201     Variable Usage:
// 1202     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
// 1203     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 1204 
// 1205     \image html ATA_rfTxStartTxModulator_C.png
// 1206 
// 1207     \internal
// 1208     \li 010: Configure the S-FIFO for data transmission by setting SFC.SFDRA 
// 1209              (TxMode for preamble FIFO)
// 1210     \li 020: Set the S-FIFO fill level configuration in SFC.SFFLC[4..0]
// 1211              according to current Service/Channel configuration
// 1212              ::g_sRfTxCurrentService
// 1213     \li 030: Enable S-FIFO fill level interrupt
// 1214     \li 040: Configure the D-FIFO for data transmission by setting DFC.DFDRA
// 1215              (TxMode for data FIFO)
// 1216     \li 050: Set the D-FIFO fill level configuration in DFC.DFFLC[5..0]
// 1217              according to current Service/Channel configuration
// 1218              ::g_sRfTxCurrentService
// 1219     \li 060: Enable D-FIFO fill level interrupt
// 1220     \li 070: Activate the power amplifier by setting FSCR.PAOER
// 1221     \li 080: Reset TX Modulator by toggling PRR2.PRTM
// 1222     \li 090: Configure Timer 3 for TXMode via function
// 1223              ::ATA_rfTxOpenTimer3forTxing_C
// 1224     \li 100: Switch to next SW state by incrementing ::g_sRfTxFlowCtrl .bIndex
// 1225 
// 1226     \Derived{No}
// 1227 
// 1228     \Rationale{N/A}
// 1229 
// 1230     \Traceability{Primus2P-847}
// 1231     \endinternal
// 1232 \n
// 1233 */
// 1234 /*---------------------------------------------------------------------------*/
// 1235 VOIDFUNC ATA_rfTxStartTxModulator_C(void)
// 1236 {
// 1237     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxStartTxModulator_C, 0x00);
// 1238     
// 1239     /* LLR-Ref: 010 */
// 1240     SFC = BM_SFDRA;
// 1241     
// 1242     /* LLR-Ref: 020 */
// 1243     ATA_SETBITMASK_C(SFC,g_sRfTxCurrentService.sPath.bTxPreambleSysEvent & 0x1F)
// 1244     
// 1245     /* LLR-Ref: 030 */
// 1246     ATA_SETBITMASK_C(SFI,BM_SFFLIM)
// 1247 
// 1248     /* LLR-Ref: 040 */
// 1249     DFC = BM_DFDRA;
// 1250     
// 1251     /* LLR-Ref: 050 */
// 1252     ATA_SETBITMASK_C(DFC,g_sRfTxCurrentService.sPath.bTxSysEvent & 0x3F)
// 1253     
// 1254     /* LLR-Ref: 060 */
// 1255     ATA_SETBITMASK_C(DFI,BM_DFFLIM)
// 1256 
// 1257     /* LLR-Ref: 070 */
// 1258     ATA_SETBITMASK_C(FSCR,BM_PAOER)
// 1259 
// 1260     /* LLR-Ref: 080 */
// 1261     ATA_POWEROFF_C(PRR2, PRTM)
// 1262     ATA_POWERON_C(PRR2, PRTM)
// 1263 
// 1264     /* LLR-Ref: 090 */
// 1265     ATA_rfTxOpenTimer3forTxing_C();
// 1266 
// 1267     /* LLR-Ref: 100 */
// 1268     ATA_rfTxStartSendTelegramSSM_C();
// 1269 
// 1270     /* LLR-Ref: 110 */
// 1271     g_sRfTxFlowCtrl.bIndex++;
// 1272 }
// 1273 
// 1274 /*---------------------------------------------------------------------------*/
// 1275 /** \brief <b>ATA_rfTxWait4TransmissionComplete_C</b>
// 1276     waits until Transmission has completed.
// 1277 
// 1278     Variable Usage:
// 1279     \li [in,out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
// 1280     \li [in,out] ::g_sRfTx Global RF Tx current service data
// 1281 
// 1282     \image html ATA_rfTxWait4TransmissionComplete_C.png
// 1283 
// 1284     \internal
// 1285     \li 010: Check if RFTX transmission is complete via ::g_sRfTx .bStatus[5]\n
// 1286              IF RFTX transmission is complete
// 1287     \li 020:   Clear transmission complete flag in ::g_sRfTx .bStatus[5]
// 1288     \li 030:   Clear fill level interrupts for S-FIFO and D-FIFO
// 1289     \li 040:   IF RFTX module shall stay in TXMode (configured in ::g_sRfTx .bConfig[2])
// 1290                  Switch to wait for fill level SW state by setting
// 1291                  ::g_sRfTxFlowCtrl .bIndex\n
// 1292                ELSE switch to next SW state by incrementing ::g_sRfTxFlowCtrl .bIndex
// 1293 
// 1294     \Derived{No}
// 1295 
// 1296     \Rationale{N/A}
// 1297 
// 1298     \Traceability{Primus2P-847}
// 1299     \endinternal
// 1300 \n
// 1301 */
// 1302 /*---------------------------------------------------------------------------*/
// 1303 VOIDFUNC ATA_rfTxWait4TransmissionComplete_C(void)
// 1304 {
// 1305     /* LLR-Ref: 010 */
// 1306     if(g_sRfTx.bStatus & BM_RFTXCONFIG_BSTATUS_TRANSMISSION_COMPLETE)
// 1307     {
// 1308         ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxWait4TransmissionComplete_C, 0x00);
// 1309 
// 1310         /* LLR-Ref: 020 */
// 1311         g_sRfTx.bStatus &= (uint8_t)~BM_RFTXCONFIG_BSTATUS_TRANSMISSION_COMPLETE;
// 1312 
// 1313         /* LLR-Ref: 030 */
// 1314         ATA_CLEARBITMASK_C(SFI,BM_SFFLIM)
// 1315         ATA_CLEARBITMASK_C(DFI,BM_DFFLIM)
// 1316 
// 1317         /* LLR-Ref: 040 */
// 1318         if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_STAY_TX) {
// 1319             g_sRfTxFlowCtrl.bIndex = RFTX_BUF_STATE_WAIT_FILLLEVEL;
// 1320         }
// 1321         else{
// 1322             g_sRfTxFlowCtrl.bIndex++;
// 1323         }
// 1324     }
// 1325 }
// 1326 
// 1327 /*---------------------------------------------------------------------------*/
// 1328 /** \brief <b>ATA_rfTxShutdown_C</b>
// 1329     shut down the RFTX module related state machine for TXMode(buffered and transparent),
// 1330     VCO tuning and antenna tuning.
// 1331 
// 1332     Variable Usage:
// 1333     \li [in,out] ::g_sRfTx Global RF Tx current service data
// 1334     \li [out] ::g_sDebug Global Debug component data
// 1335 
// 1336     \image html ATA_rfTxShutdown_C.png
// 1337 
// 1338     \internal
// 1339     \li 010: Clear SSM ready flag ::g_sRfTx .bStatus[6]
// 1340     \li 020: Start shutdown SSM by calling function ::ATA_rfTxStartShutDownSSM_C
// 1341     \li 030: Apply 5us wait time before checking that shutdown SSM has finished
// 1342               no SSM watchdog functionality implemented here, since timer startup phase
// 1343               extends SSM runtime
// 1344     \li 040: Check if SSM has finished with success via ::g_sRfTx .bStatus[6]
// 1345               and SSM status register SSMSR\n
// 1346              IF SSM has finished with success
// 1347     \li 050:   Clear SSM ready flag ::g_sRfTx .bStatus[6]\n
// 1348              ELSE (SMM has finished with error)
// 1349     \li 060:   Signal error via flag ::g_sRfTx .bFlags[7]
// 1350     \li 070:   Write error code to ::g_sDebug .bErrorCode and ::g_sDebug
// 1351                .bSsmErrorCode\n
// 1352              ENDIF
// 1353     \li 080: Clear S-FIFO and D-FIFO content by setting SFL.SFCLR and DFL.DFCLR
// 1354     \li 090: Remove power from RFTX module by calling function ::ATA_rfTxEnd_C
// 1355     \li 100: Clear RFTX module active flag ::g_sRfTx .bStatus[4]
// 1356     \li 110: Clear RFTX module ready for transmission flag ::g_sRfTx .bFlags[6]
// 1357 
// 1358     \Derived{No}
// 1359 
// 1360     \Rationale{N/A}
// 1361 
// 1362     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 1363     \endinternal
// 1364 \n
// 1365 */
// 1366 /*---------------------------------------------------------------------------*/
// 1367 VOIDFUNC ATA_rfTxShutdown_C(void)
// 1368 {
// 1369     ATA_SET_FUNCTION_TRACE_POINT_C(ATA_rfTxShutdown_C, 0x00);
// 1370     
// 1371     /* LLR-Ref: 010 */
// 1372     g_sRfTx.bStatus &= (uint8_t)~BM_RFTXCONFIG_BSTATUS_SSMREADY;
// 1373     
// 1374     /* LLR-Ref: 020 */
// 1375     ATA_rfTxStopSsmWatchdog_C();
// 1376     ATA_rfTxStartShutDownSSM_C();
// 1377 
// 1378     /* LLR-Ref: 030 */
// 1379     ATA_globalsWaitNus_ASM(5U);
// 1380 
// 1381     /* LLR-Ref: 040 */
// 1382     if (   (g_sRfTx.bStatus & BM_RFTXCONFIG_BSTATUS_SSMREADY)
// 1383         && (SSMSR == 0U) ) {
// 1384         /* LLR-Ref: 050 */
// 1385         ATA_CLEARBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_SSMREADY)
// 1386     }
// 1387     else {
// 1388         /* LLR-Ref: 060 */
// 1389         ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1390         
// 1391         /* LLR-Ref: 070 */
// 1392         g_sDebug.bErrorCode    = DEBUG_ERROR_CODE_RFTX_SHUTDOWN_ERROR;
// 1393         g_sDebug.bSsmErrorCode = SSMSR;
// 1394     }
// 1395 
// 1396     /* LLR-Ref: 080 */
// 1397     ATA_SETBITMASK_C(SFL,BM_SFCLR)
// 1398     ATA_SETBITMASK_C(DFL,BM_DFCLR)
// 1399 
// 1400     /* LLR-Ref: 090 */
// 1401     ATA_rfTxEnd_C();
// 1402 
// 1403     /* LLR-Ref: 100 */
// 1404     ATA_CLEARBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_ACTIVE)
// 1405 
// 1406     /* LLR-Ref: 110 */
// 1407     ATA_CLEARBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_RDY4TX)
// 1408 }
// 1409 
// 1410 /*----------------------------------------------------------------------------- */
// 1411 /** \brief <b>ATA_rfTxInitCurrentService_C</b>
// 1412     does the initialization of ::g_sRfTxCurrentService
// 1413 
// 1414     Variable Usage:
// 1415     \li [in,out] ::g_sRfTx Global RF Tx current service data
// 1416     \li [out] ::g_sDebug Global Debug component data
// 1417     \li [out] ::g_sRfTxCurrentService Global RF Tx current service data
// 1418 
// 1419     \image html ATA_rfTxInitCurrentService_C.png
// 1420 
// 1421     \internal
// 1422     \li 010: Check for EEPROM or SRAM service configuration via ::g_sRfTx .bConfig[3]\n
// 1423              IF service configuration is located in EEPROM,
// 1424              THEN
// 1425 
// 1426     \li 020: Copy service specific configuration from EEPROM to
// 1427              ::g_sRfTxCurrentService .sService
// 1428 
// 1429     \li 025: IF after the EEPROM read access to retrieve the requested data, an
// 1430                uncorrectable EEPROM error was detected, indicated by
// 1431                bit "E2FF" in register EECR2 being set 1,
// 1432              THEN
// 1433                Set an EEPROM read error indication in ::g_sRfTx .bFlags of and
// 1434                set ::g_sDebug .bErrorCode to the RF Tx module EEPROM read error\n
// 1435              ENDIF
// 1436 
// 1437     \li 030: Copy path specific configuration from EEPROM to
// 1438              ::g_sRfTxCurrentService .sPath
// 1439 
// 1440     \li 035: IF after the EEPROM read access to retrieve the requested data, an
// 1441               uncorrectable EEPROM error was detected, indicated by
// 1442               bit "E2FF" in register EECR2 being set 1,
// 1443              THEN
// 1444                Set an EEPROM read error indication in ::g_sRfTx .bFlags and
// 1445                set ::g_sDebug .bErrorCode to the RF Tx module EEPROM read error\n
// 1446              ENDIF
// 1447 
// 1448     \li 040: Copy channel specific configuration from EEPROM to
// 1449              ::g_sRfTxCurrentService .sChannel
// 1450 
// 1451     \li 045: IF after the EEPROM read access to retrieve the requested data, an
// 1452               uncorrectable EEPROM error was detected, indicated by
// 1453               bit "E2FF" in register EECR2 being set 1,\n
// 1454              THEN
// 1455                Set an EEPROM read error indication in ::g_sRfTx .bFlags and
// 1456                set ::g_sDebug .bErrorCode" to the RF Tx module EEPROM read error\n
// 1457              ENDIF
// 1458 
// 1459              ELSE (service configuration is located in SRAM)
// 1460     \li 050:   Copy service specific configuration from SRAM to
// 1461                ::g_sRfTxCurrentService .sService
// 1462 
// 1463     \li 060:   Copy path specific configuration from SRAM to
// 1464                ::g_sRfTxCurrentService .sPath
// 1465 
// 1466     \li 070:   Copy channel specific configuration from SRAM to
// 1467                ::g_sRfTxCurrentService .sChannel\n
// 1468              ENDIF
// 1469 
// 1470     \Derived{No}
// 1471 
// 1472     \Rationale{N/A}
// 1473 
// 1474     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868,\ 
// 1475                   Primus2P-2443}
// 1476     \endinternal
// 1477 \n
// 1478 */
// 1479 /*----------------------------------------------------------------------------- */
// 1480 VOIDFUNC ATA_rfTxInitCurrentService_C(void)
// 1481 {
// 1482     eEepErrorCode sEepErrCode;
// 1483     
// 1484     /* LLR-Ref: 010 */
// 1485     if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_SVC_LOCATION)
// 1486     {
// 1487         /* LLR-Ref: 020 */
// 1488         uint8_t *pSrcData = g_sRfTx.pAddress;
// 1489         uint8_t *pDstData = (uint8_t*)&g_sRfTxCurrentService.sService;
// 1490         sEepErrCode = ATA_eepReadBytes_C(pDstData, (uint16_t)pSrcData, sizeof(sRfTxServiceSpecificConfig));
// 1491 
// 1492         /* LLR-Ref: 025 */
// 1493         if(sEepErrCode != EEC_NO_ERROR)
// 1494         {
// 1495             ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1496             g_sDebug.bErrorCode = DEBUG_ERROR_CODE_RFTX_EEPROM_READ_ERROR;
// 1497         }
// 1498 
// 1499         /* LLR-Ref: 030 */
// 1500         pSrcData += sizeof(sRfTxServiceSpecificConfig);
// 1501         pDstData = (uint8_t*)&g_sRfTxCurrentService.sPath;
// 1502         sEepErrCode = ATA_eepReadBytes_C(pDstData, (uint16_t)pSrcData, sizeof(sRfTxServicePathConfig));
// 1503 
// 1504         /* LLR-Ref: 035 */
// 1505         if(sEepErrCode != EEC_NO_ERROR)
// 1506         {
// 1507             ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1508             g_sDebug.bErrorCode = DEBUG_ERROR_CODE_RFTX_EEPROM_READ_ERROR;
// 1509         }
// 1510 
// 1511         /* LLR-Ref: 040 */
// 1512         pSrcData += sizeof(sRfTxServicePathConfig);
// 1513         pDstData = (uint8_t*)&g_sRfTxCurrentService.sChannel;
// 1514 
// 1515         uint8_t channel = g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_CHANNEL;
// 1516 
// 1517         if (channel > 0) {
// 1518             pSrcData += sizeof(sRfTxChannelConfig);
// 1519         }
// 1520 
// 1521         if (channel > 1) {
// 1522             pSrcData += sizeof(sRfTxChannelConfig);
// 1523         }
// 1524 
// 1525         sEepErrCode = ATA_eepReadBytes_C(pDstData, (uint16_t)pSrcData, sizeof(sRfTxChannelConfig));
// 1526 
// 1527         /* LLR-Ref: 045 */
// 1528         if(sEepErrCode != EEC_NO_ERROR)
// 1529         {
// 1530             ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1531             g_sDebug.bErrorCode = DEBUG_ERROR_CODE_RFTX_EEPROM_READ_ERROR;
// 1532         }
// 1533     }
// 1534     else
// 1535     {
// 1536         /* LLR-Ref: 050 */
// 1537         uint8_t *pSrcData = g_sRfTx.pAddress;
// 1538         uint8_t *pDstData = (uint8_t*)&g_sRfTxCurrentService.sService;
// 1539         ATA_globalsCopySramSpace_C(pDstData, pSrcData, sizeof(sRfTxServiceSpecificConfig));
// 1540 
// 1541         /* LLR-Ref: 060 */
// 1542         pSrcData += sizeof(sRfTxServiceSpecificConfig);
// 1543         pDstData = (uint8_t*)&g_sRfTxCurrentService.sPath;
// 1544         ATA_globalsCopySramSpace_C(pDstData, pSrcData, sizeof(sRfTxServicePathConfig));
// 1545 
// 1546         /* LLR-Ref: 070 */
// 1547         pSrcData += sizeof(sRfTxServicePathConfig);
// 1548         pDstData = (uint8_t*)&g_sRfTxCurrentService.sChannel;
// 1549 
// 1550         uint8_t channel = g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_CHANNEL;
// 1551 
// 1552         if (channel > 0) {
// 1553             pSrcData += sizeof(sRfTxChannelConfig);
// 1554         }
// 1555 
// 1556         if (channel > 1) {
// 1557             pSrcData += sizeof(sRfTxChannelConfig);
// 1558         }
// 1559         ATA_globalsCopySramSpace_C(pDstData, pSrcData, sizeof(sRfTxChannelConfig));
// 1560     }
// 1561 }
// 1562 
// 1563 /*----------------------------------------------------------------------------- */
// 1564 /** \brief <b>ATA_rfTxFrequencySettings_C</b>
// 1565     does the Tx specific frequency settings according to the current
// 1566     Service/Channel configuration
// 1567 
// 1568     Variable Usage:
// 1569     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 1570 
// 1571     \image html ATA_rfTxFrequencySettings_C.png
// 1572 
// 1573     \internal
// 1574     \li 010: Calculate f_tx_ask = f_lo + f_if
// 1575                f_lo = ::g_sRfTxCurrentService .sChannel.FREQ[2..0]
// 1576                f_if = ::g_sRfTxCurrentService .sService.bIF[1..0]
// 1577     \li 020: Check modulation type via ::g_sRfTxCurrentService .sPath.bTxSetPath[1][7]\n
// 1578              IF ASK modulation is used
// 1579     \li 030:   Copy FFREQ1 settings to FFREQ2
// 1580     \li 040:   Switch to FFREQ2 to avoid PLL problems during programming of FFREQ1
// 1581     \li 050:   Program FFREQ1 registers with f_tx_ask
// 1582     \li 060:   Switch back to FFREQ1\n
// 1583              ELSE (FSK modulation is used)
// 1584     \li 070:   Copy FFREQ1 settings to FFREQ2
// 1585     \li 080:   Switch to FFREQ2 to avoid PLL problems during programming of FFREQ1
// 1586     \li 090:   Calculate f_tx_fsk1 = f_tx_ask - f_tx_dev / 2
// 1587                  f_tx_dev = ::g_sRfTxCurrentService .sPath.btxDev[1..0]
// 1588     \li 100:   Program FFREQ1 with f_tx_fsk1
// 1589     \li 110:   Switch back to FFREQ1
// 1590     \li 120:   Calculate f_tx_fsk2 = f_tx_fsk1 + f_tx_dev (= f_tx_ask + f_tx_dev / 2)
// 1591     \li 130:   Program FFREQ2 with f_tx_fsk2
// 1592 
// 1593     \Derived{No}
// 1594 
// 1595     \Rationale{N/A}
// 1596 
// 1597     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 1598     \endinternal
// 1599 \n
// 1600 */
// 1601 /*----------------------------------------------------------------------------- */
// 1602 static VOIDFUNC ATA_rfTxFrequencySettings_C(void)
// 1603 {
// 1604     /* LLR-Ref: 010 */
// 1605     uint32_t dwFrequency = ((uint32_t)g_sRfTxCurrentService.sChannel.bFFREQ[2] << 16U)
// 1606                         |((uint32_t)g_sRfTxCurrentService.sChannel.bFFREQ[1] <<  8U)
// 1607                         |((uint32_t)g_sRfTxCurrentService.sChannel.bFFREQ[0] <<  0U);
// 1608     /* --- F_TX = F_LO + F_IF --- */
// 1609     dwFrequency +=  ((uint32_t)g_sRfTxCurrentService.sService.bIF[1] <<  8U)
// 1610                    |((uint32_t)g_sRfTxCurrentService.sService.bIF[0] <<  0U);
// 1611 
// 1612     /* LLR-Ref: 020 */
// 1613     if (g_sRfTxCurrentService.sPath.bTxSetPath[1] & BM_RFTXSERVICE_BTXSETPATH_MODULATION) {
// 1614         /* ASK Modulation */
// 1615         /* --- F_TX_ASK = F_LO + F_IF --- */
// 1616         /* LLR-Ref: 030 */
// 1617         FFREQ2H = FFREQ1H;
// 1618         FFREQ2M = FFREQ1M;
// 1619         FFREQ2L = FFREQ1L;
// 1620 
// 1621         /* LLR-Ref: 040 */
// 1622         FSCR    = BM_TXMOD | BM_SFM;
// 1623 
// 1624         /* LLR-Ref: 050 */
// 1625         FFREQ1H = (uint8_t)(dwFrequency >> 16U);
// 1626         FFREQ1M = (uint8_t)(dwFrequency >>  8U);
// 1627         FFREQ1L = (uint8_t)(dwFrequency >>  0U);
// 1628 
// 1629         /* LLR-Ref: 060 */
// 1630         FSCR    = 0x00U;
// 1631     }
// 1632     else {   /* FSK Modulation */
// 1633         uint32_t dwFreqdev = (  ((uint32_t)g_sRfTxCurrentService.sPath.btxDev[1] <<  8U)
// 1634                                |((uint32_t)g_sRfTxCurrentService.sPath.btxDev[0] <<  0U));
// 1635         /* LLR-Ref: 070 */
// 1636         FFREQ2H = FFREQ1H;
// 1637         FFREQ2M = FFREQ1M;
// 1638         FFREQ2L = FFREQ1L;
// 1639 
// 1640         /* LLR-Ref: 080 */
// 1641         FSCR    = BM_TXMOD | BM_SFM;
// 1642 
// 1643         /* LLR-Ref: 090 */
// 1644         dwFrequency -= dwFreqdev/2U;
// 1645 
// 1646         /* LLR-Ref: 100 */
// 1647         FFREQ1H = (uint8_t)(dwFrequency >> 16U);
// 1648         FFREQ1M = (uint8_t)(dwFrequency >>  8U);
// 1649         FFREQ1L = (uint8_t)(dwFrequency >>  0U);
// 1650 
// 1651         /* LLR-Ref: 110 */
// 1652         FSCR    = 0x00U;
// 1653 
// 1654         /* LLR-Ref: 120 */
// 1655         dwFrequency += dwFreqdev;
// 1656 
// 1657         /* LLR-Ref: 130 */
// 1658         FFREQ2H = (uint8_t)(dwFrequency >> 16U);
// 1659         FFREQ2M = (uint8_t)(dwFrequency >>  8U);
// 1660         FFREQ2L = (uint8_t)(dwFrequency >>  0U);
// 1661     }
// 1662 }
// 1663 
// 1664 /*---------------------------------------------------------------------------*/
// 1665 /** \brief <b>ATA_rfTxSetupTxModulator_C</b>
// 1666     this function initializes the TX modulator according to the settings in
// 1667     variable ::g_sRfTxCurrentService .sPath.
// 1668 
// 1669     Variable Usage:
// 1670     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 1671 
// 1672     \image html ATA_rfTxSetupTxModulator_C.png
// 1673 
// 1674     \internal
// 1675     \li 010: Initialize the following registers
// 1676                  - TMCR1
// 1677                  - TMCR2
// 1678                  - TMSR
// 1679                  - TMSSC
// 1680                  - TMTLL
// 1681                  - TMTLH
// 1682                  - TMCPL
// 1683                  - TMCPH
// 1684                  - TMCIL
// 1685                  - TMCIH
// 1686                  - TMCSB
// 1687 
// 1688     \Derived{No}
// 1689 
// 1690     \Rationale{N/A}
// 1691 
// 1692     \Traceability{Primus2P-847}
// 1693     \endinternal
// 1694 \n
// 1695  */
// 1696 /*---------------------------------------------------------------------------*/
// 1697 static VOIDFUNC ATA_rfTxSetupTxModulator_C(void)
// 1698 {
// 1699     /* LLR-Ref: 010 */
// 1700     TMCR1 = BM_TMCIM | BM_TMSCS;
// 1701     TMCR2 = g_sRfTxCurrentService.sPath.bTMCR2;
// 1702     TMSR  = BM_TMTCF;
// 1703     TMSSC = g_sRfTxCurrentService.sPath.bTMSSC;
// 1704     TMTLL = g_sRfTxCurrentService.sPath.bTMTL[0];
// 1705     TMTLH = g_sRfTxCurrentService.sPath.bTMTL[1];
// 1706     TMCPL = g_sRfTxCurrentService.sPath.bTMCP[0];
// 1707     TMCPH = g_sRfTxCurrentService.sPath.bTMCP[1];
// 1708     TMCIL = g_sRfTxCurrentService.sPath.bTMCI[0];
// 1709     TMCIH = g_sRfTxCurrentService.sPath.bTMCI[1];
// 1710     TMCSB = g_sRfTxCurrentService.sPath.bTMCSB;
// 1711 }
// 1712 
// 1713 /*----------------------------------------------------------------------------- */
// 1714 /** \brief <b>ATA_rfTxConfigureTxSSM_C</b>
// 1715     this function configures the Sequencer State Machine for TxMode(buffered).
// 1716 
// 1717     Variable Usage:
// 1718     \li [in] ::g_sRfTx Global RF Tx component data
// 1719     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 1720 
// 1721     \image html ATA_rfTxConfigureTxSSM_C.png
// 1722 
// 1723     \internal
// 1724     \li 010: Check SSM configuration via ::g_sRfTx .bConfig[7..6]
// 1725     \li 020: Stop current running SSM via SSMRR.SSMST\n
// 1726              IF no tuning is selected
// 1727     \li 030:   Write following configuration to MSMCR1..4
// 1728                    - SSM_PLL_EN_STATE
// 1729                    - SSM_PLL_LOCK_STATE
// 1730                    - SSM_TX_DSP_EN_STATE
// 1731                    - SSM_END_STATE\n
// 1732              IF only VCO tuning is selected
// 1733     \li 040:   Write following configuration to MSMCR1..4
// 1734                    - SSM_PLL_EN_STATE
// 1735                    - SSM_VCO_TUNING_STATE
// 1736                    - SSM_PLL_LOCK_STATE
// 1737                    - SSM_TX_DSP_EN_STATE
// 1738                    - SSM_END_STATE\n
// 1739              IF only Antenna tuning is selected
// 1740     \li 050:   Write following configuration to MSMCR1..4
// 1741                    - SSM_PLL_EN_STATE
// 1742                    - SSM_PLL_LOCK_STATE
// 1743                    - SSM_TX_DSP_EN_STATE
// 1744                    - SSM_ANTENNA_TUNING_STATE
// 1745                    - SSM_END_STATE\n
// 1746              IF VCO and Antenna tuning is selected
// 1747     \li 060:   Write following configuration to MSMCR1..4
// 1748                    - SSM_PLL_EN_STATE
// 1749                    - SSM_VCO_TUNING_STATE
// 1750                    - SSM_PLL_LOCK_STATE
// 1751                    - SSM_TX_DSP_EN_STATE
// 1752                    - SSM_ANTENNA_TUNING_STATE
// 1753                    - SSM_END_STATE
// 1754     \li 070: Check for direct switch via ::g_sRfTx .bStatus[7]. In case of a direct
// 1755               switch, replace PLL_EN SSM with TX_DSP_DIS
// 1756     \li 080: Initialize SSMFBR register
// 1757     \li 090: Reset SSM by clearing SSMCR register content
// 1758     \li 100: Set SSMCR.SSMTGE according to ::g_sRfTxCurrentService
// 1759               .sPath.bTxSetPath[0][7]
// 1760     \li 110: Set SSMCR.SSMTPE according to ::g_sRfTxCurrentService
// 1761               .sPath.bTxSetPath[0][6]
// 1762     \li 120: Set SSMCR.SSMTAE according to ::g_sRfTxCurrentService
// 1763               .sPath.bTxSetPath[1][6]
// 1764 
// 1765     \Derived{No}
// 1766 
// 1767     \Rationale{N/A}
// 1768 
// 1769     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 1770     \endinternal
// 1771 \n
// 1772 */
// 1773 /*----------------------------------------------------------------------------- */
// 1774 static VOIDFUNC ATA_rfTxConfigureTxSSM_C(void)
// 1775 {
// 1776     /* LLR-Ref: 010 */
// 1777     uint8_t config = g_sRfTx.bConfig & (BM_RFTXCONFIG_BCONFIG_ANT_TUNING | BM_RFTXCONFIG_BCONFIG_VCO_TUNING);
// 1778 
// 1779     /* LLR-Ref: 020 */
// 1780     SSMRR = BM_SSMST;
// 1781 
// 1782     if (config == 0U) {
// 1783         /* NO VCO TUNING */
// 1784         /* NO ANTENNA TUNING */
// 1785         /* LLR-Ref: 030 */
// 1786         MSMCR1 = SSM_PLL_EN_STATE           | (uint8_t)(SSM_PLL_LOCK_STATE << 4U);
// 1787         MSMCR2 = SSM_TX_DSP_EN_STATE        | (uint8_t)(SSM_END_STATE << 4U);
// 1788         MSMCR3 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1789         MSMCR4 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1790     }
// 1791     else if (config == BM_RFTXCONFIG_BCONFIG_VCO_TUNING) {
// 1792         /* ONLY VCO TUNING */
// 1793         /* NO ANTENNA TUNING */
// 1794         /* LLR-Ref: 040 */
// 1795         MSMCR1 = SSM_PLL_EN_STATE           | (uint8_t)(SSM_VCO_TUNING_STATE << 4U);
// 1796         MSMCR2 = SSM_PLL_LOCK_STATE         | (uint8_t)(SSM_TX_DSP_EN_STATE << 4U);
// 1797         MSMCR3 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1798         MSMCR4 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1799     }
// 1800     else if (config == BM_RFTXCONFIG_BCONFIG_ANT_TUNING) {
// 1801         /* NO VCO TUNING */
// 1802         /* ONLY ANTENNA TUNING */
// 1803         /* LLR-Ref: 050 */
// 1804         MSMCR1 = SSM_PLL_EN_STATE           | (uint8_t)(SSM_PLL_LOCK_STATE << 4U);
// 1805         MSMCR2 = SSM_TX_DSP_EN_STATE        | (uint8_t)(SSM_ANTENNA_TUNING_STATE << 4U);
// 1806         MSMCR3 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1807         MSMCR4 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1808     }
// 1809     else {
// 1810         /* VCO TUNING */
// 1811         /* ANTENNA TUNING */
// 1812         /* LLR-Ref: 060 */
// 1813         MSMCR1 = SSM_PLL_EN_STATE           | (uint8_t)(SSM_VCO_TUNING_STATE << 4U);
// 1814         MSMCR2 = SSM_PLL_LOCK_STATE         | (uint8_t)(SSM_TX_DSP_EN_STATE << 4U);
// 1815         MSMCR3 = SSM_ANTENNA_TUNING_STATE   | (uint8_t)(SSM_END_STATE << 4U);
// 1816         MSMCR4 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 1817     }
// 1818 
// 1819     /* LLR-Ref: 070 */
// 1820     if (g_sRfTx.bStatus & BM_RFTXCONFIG_BSTATUS_DIRECT_SWITCH){
// 1821         /* in case of a direct switch -> replace PLL_EN SSM with TX_DSP_DIS */
// 1822         MSMCR1 &= (uint8_t)(BM_MSMSM13 | BM_MSMSM12 | BM_MSMSM11 | BM_MSMSM10);
// 1823         MSMCR1 |= SSM_TX_DSP_DIS_STATE;
// 1824     }
// 1825 
// 1826     /* LLR-Ref: 080 */
// 1827     SSMFBR = g_sRfTxCurrentService.sService.bSSMFBR;
// 1828 
// 1829     /* LLR-Ref: 090 */
// 1830     SSMCR = 0U;
// 1831 
// 1832     /* LLR-Ref: 100 */
// 1833     /* SSMCR.SSMTGE - Sequencer State Machine Tx Gauss Enable */
// 1834     if (g_sRfTxCurrentService.sPath.bTxSetPath[0] & BM_RFTXSERVICE_BTXSETPATH_GAUS) {
// 1835         ATA_SETBITMASK_C(SSMCR,BM_SSMTGE)
// 1836     }
// 1837     /* LLR-Ref: 110 */
// 1838     /* SSMCR.SSMTPE - Sequencer State Machine Tx Preemphasis Enable */
// 1839     if (g_sRfTxCurrentService.sPath.bTxSetPath[0] & BM_RFTXSERVICE_BTXSETPATH_PREE) {
// 1840         ATA_SETBITMASK_C(SSMCR,BM_SSMTPE)
// 1841     }
// 1842     /* LLR-Ref: 120 */
// 1843     /* SSMCR.SSMTAE - Sequencer State Machine Tx Ask-Shaping Enable */
// 1844     if (g_sRfTxCurrentService.sPath.bTxSetPath[1] & BM_RFTXSERVICE_BTXSETPATH_ASK_SHAPING) {
// 1845         ATA_SETBITMASK_C(SSMCR,BM_SSMTAE)
// 1846     }
// 1847 }
// 1848 
// 1849 /*---------------------------------------------------------------------------*/
// 1850 /** \brief <b>ATA_rfTxFevcoCalculation_C</b>
// 1851     does calculation for FEVCO register setting.
// 1852 
// 1853     Variable Usage:
// 1854     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 1855 
// 1856     \image html ATA_rfTxFevcoCalculation_C.png
// 1857 
// 1858     \internal
// 1859     \li 010: Read offset values for vcob and cpcc from EEPROM g_sEepFacLockRfFrontend.bFEVCOoffset
// 1860                  - vcob_offset = g_sEepFacLockRfFrontend.bFEVCOoffset[7..4]
// 1861                  - cpcc_offset = g_sEepFacLockRfFrontend.bFEVCOoffset[3..0]
// 1862     \li 020: Eead vcob value from ::g_sRfTxCurrentService .sService.bFEVCO[7..4]
// 1863     \li 030: Read cpcc value from ::g_sRfTxCurrentService .sService.bFEVCO[3..0]
// 1864     \li 040: Extend signed 4 bit value vcob to 8 bit
// 1865     \li 050: Extend signed 4 bit value cpcc to 8 bit
// 1866     \li 060: Calucate 7 + vcob + vcob_offset and limit negative results to 0
// 1867     \li 070: Move 4 bit result of calculation to vcob[7..4]
// 1868     \li 080: Calucate 7 + cpcc + cpcc_offset and limit negative results to 0
// 1869     \li 090: Move 4 bit result of calculation to cpcc[3..0]
// 1870     \li 100: Combine vcob and cpcc for retVal
// 1871 
// 1872     \Derived{No}
// 1873 
// 1874     \Rationale{N/A}
// 1875 
// 1876     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868,
// 1877                   Primus2P-2443}
// 1878     \endinternal
// 1879 \n
// 1880 */
// 1881 /*---------------------------------------------------------------------------*/
// 1882 static UINT8FUNC ATA_rfTxFevcoCalculation_C(void)
// 1883 {
// 1884     uint8_t bRetVal      = 0U;
// 1885     int8_t  bResult      = 0;
// 1886     eEepErrorCode sEepErrCode;
// 1887 
// 1888     /* LLR-Ref: 010 */
// 1889     uint8_t bFevcoOffset = 0U;
// 1890     sEepErrCode = ATA_eepReadBytes_C(&bFevcoOffset, (uint16_t)&g_sAtmelEEPromSection.eepFEVCOoffset, 1U);
// 1891     if(sEepErrCode != EEC_NO_ERROR)
// 1892     {
// 1893         ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 1894         g_sDebug.bErrorCode = DEBUG_ERROR_CODE_RFTX_EEPROM_READ_ERROR;
// 1895     }
// 1896 
// 1897     /* LLR-Ref: 020 */
// 1898     uint8_t bVcob        = (g_sRfTxCurrentService.sService.bFEVCO & 0xF0U) >> 4U;
// 1899     uint8_t bVcobOffset  = (bFevcoOffset & 0xF0U) >> 4U;
// 1900 
// 1901     /* LLR-Ref: 030 */
// 1902     uint8_t bCpcc        = g_sRfTxCurrentService.sService.bFEVCO & 0x0FU;
// 1903     uint8_t bCpccOffset  = bFevcoOffset & 0x0FU;
// 1904 
// 1905     /* LLR-Ref: 040 */
// 1906     if (bVcob > 7U) {
// 1907         ATA_SETBITMASK_C(bVcob,0xF0U)
// 1908     }
// 1909 
// 1910     /* LLR-Ref: 050 */
// 1911     if (bCpcc > 7U) {
// 1912         ATA_SETBITMASK_C(bCpcc,0xF0U)
// 1913     }
// 1914 
// 1915     /* LLR-Ref: 060 */
// 1916     bResult = 7 + (int8_t)bVcob + (int8_t)bVcobOffset;
// 1917     if(bResult < 0) {
// 1918         bResult = 0;
// 1919     }
// 1920 
// 1921     /* LLR-Ref: 070 */
// 1922     bVcob = (uint8_t)((uint8_t)bResult << 4U);
// 1923     bVcob &= 0xF0U;
// 1924 
// 1925     /* LLR-Ref: 080 */
// 1926     bResult = 7 + (int8_t)bCpcc + (int8_t)bCpccOffset;
// 1927     if (bResult < 0){
// 1928         bResult = 0;
// 1929     }
// 1930 
// 1931     /* LLR-Ref: 090 */
// 1932     bCpcc = (uint8_t)bResult;
// 1933     bCpcc &= 0x0FU;
// 1934 
// 1935     /* LLR-Ref: 100 */
// 1936     bRetVal = bVcob | bCpcc;
// 1937 
// 1938     return bRetVal;
// 1939 }
// 1940 
// 1941 /*---------------------------------------------------------------------------*/
// 1942 /** \brief <b>ATA_rfTxEnd_C</b>
// 1943     closes and switches all used peripherals off.
// 1944 
// 1945     Variable Usage:
// 1946     \li [out] ::g_sRfTxFlowCtrl Global RF Tx statemachine data
// 1947     \li [in] ::g_sRfTx Global RF Tx component data
// 1948 
// 1949     \image html ATA_rfTxEnd_C.png
// 1950 
// 1951     \internal
// 1952     \li 010: Switch off Timer 3 by calling function ::ATA_timer3Close_C
// 1953                 Note: Timer 2 already switched off in function ATA_rfTxShutdown_C
// 1954     \li 020: Reset FSCR and FSEN register
// 1955     \li 030: Disable SSM interrupt and stop currently running SSM anyway
// 1956     \li 040: Remove power from SSM, TX Modulator, CRC and TX DSP HW blocks
// 1957     \li 050: Check if system shall return to IDLEMode(RC) or IDLEMode(XTO)\n
// 1958              IF return to IDLEMode(XTO)
// 1959     \li 060: Reset SUPCR.AVDIC, reset FEEN1/FEEN2 register, set FEEN1.XTOEN\n
// 1960              ELSE (return to IDLEMode(RC))
// 1961     \li 070: Switch AVR core clock to FRC via function ::ATA_globalsClkSwitchFrc_C
// 1962              Reset FEEN1/FEEN2 and SUPCR register\n
// 1963              ENDIF
// 1964     \li 080: Reset SW statemachine data ::g_sRfTxFlowCtrl
// 1965 
// 1966     \Derived{No}
// 1967 
// 1968     \Rationale{N/A}
// 1969 
// 1970     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 1971     \endinternal
// 1972 \n
// 1973 */
// 1974 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
// 1975 static VOIDFUNC ATA_rfTxEnd_C(void)
ATA_rfTxEnd_C:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function ATA_rfTxEnd_C
// 1976 {
// 1977     /* LLR-Ref: 010 */
// 1978     ATA_timer3Close_C();
          CFI FunCall ATA_timer3Close_C
        CALL    ATA_timer3Close_C
// 1979 
// 1980     /* LLR-Ref: 020 */
// 1981     FSCR = 0x00U;
        LDI     R16, 0
        OUT     0x0F, R16
// 1982     FSEN = 0x00U;
        STS     _A_FSEN, R16
// 1983 
// 1984     /* LLR-Ref: 030 */
// 1985     SSMIMR = 0x00U;
        STS     _A_SSMIMR, R16
// 1986     SSMRR  = BM_SSMST;
        LDI     R16, 2
        STS     _A_SSMRR, R16
// 1987 
// 1988     /* LLR-Ref: 040 */
// 1989     ATA_POWEROFF_C(PRR2,PRSSM)
        SBI     0x02, 0x07
// 1990     ATA_POWEROFF_C(PRR2,PRTM)
        SBI     0x02, 0x06
// 1991     ATA_POWEROFF_C(PRR0,PRCRC)
        SBI     0x1A, 0x03
// 1992     ATA_POWEROFF_C(PRR0,PRTXDC)
        SBI     0x1A, 0x02
// 1993 
// 1994     /* LLR-Ref: 050 */
// 1995     if (g_sRfTx.bConfig & BM_RFTXCONFIG_BCONFIG_SHUTDOWN_MODE) {
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+3
        SBRS    R16, 4
        RJMP    ??ATA_rfTxEnd_C_0
// 1996         /* LLR-Ref: 060 */
// 1997         ATA_CLEARBITMASK_C(SUPCR,BM_AVDIC)
        LDS     R16, 204
        ANDI    R16, 0xF7
        STS     204, R16
// 1998         FEEN2 = 0U;
        LDI     R16, 0
        STS     _A_FEEN2, R16
// 1999         FEEN1 = BM_XTOEN;
        LDI     R16, 4
        STS     _A_FEEN1, R16
        RJMP    ??ATA_rfTxEnd_C_1
// 2000     }
// 2001     else {
// 2002         /* LLR-Ref: 070 */
// 2003         /* --P2P-3655-- */
// 2004         if( g_sRfTx.bCmcrSetting & BM_CCS) 
??ATA_rfTxEnd_C_0:
        LDD     R16, Z+6
        SBRS    R16, 3
        RJMP    ??ATA_rfTxEnd_C_2
// 2005         {
// 2006             uint8_t bClockSource = g_sRfTx.bCmcrSetting & (BM_CMM2|BM_CMM1|BM_CMM0);
        ANDI    R16, 0x07
// 2007             if ( bClockSource== 0)  // CLK_SRC
        BRNE    ??ATA_rfTxEnd_C_3
// 2008             {
// 2009                 ATA_globalsClkSwitchSrc_C();
          CFI FunCall ATA_globalsClkSwitchSrc_C
        CALL    ATA_globalsClkSwitchSrc_C
        RJMP    ??ATA_rfTxEnd_C_4
// 2010             }
// 2011             else if (bClockSource == 2) // CLK_EXT
??ATA_rfTxEnd_C_3:
        CPI     R16, 2
        BRNE    ??ATA_rfTxEnd_C_5
// 2012             {
// 2013                 if (SUPCR & BM_DVHEN)
        LDS     R16, _A_SUPCR
        SBRS    R16, 5
        RJMP    ??ATA_rfTxEnd_C_6
// 2014                 {
// 2015                     ATA_globalsClkSwitchExt_C(TRUE);
        LDI     R16, 1
        RJMP    ??ATA_rfTxEnd_C_7
// 2016                 } else {
// 2017                     ATA_globalsClkSwitchExt_C(FALSE);
??ATA_rfTxEnd_C_6:
        LDI     R16, 0
??ATA_rfTxEnd_C_7:
          CFI FunCall ATA_globalsClkSwitchExt_C
        CALL    ATA_globalsClkSwitchExt_C
        RJMP    ??ATA_rfTxEnd_C_4
// 2018                 }
// 2019             }
// 2020             else // CLK_FRC
// 2021             {
// 2022                 ATA_globalsClkSwitchFrc_C();
??ATA_rfTxEnd_C_5:
          CFI FunCall ATA_globalsClkSwitchFrc_C
        CALL    ATA_globalsClkSwitchFrc_C
        RJMP    ??ATA_rfTxEnd_C_4
// 2023             }
// 2024         } else {    // CLK_MRC
// 2025             ATA_globalsClkSwitchMrc_C();
??ATA_rfTxEnd_C_2:
          CFI FunCall ATA_globalsClkSwitchMrc_C
        CALL    ATA_globalsClkSwitchMrc_C
// 2026         }
// 2027         FEEN1 = 0U;
??ATA_rfTxEnd_C_4:
        LDI     R16, 0
        STS     _A_FEEN1, R16
// 2028         ATA_CLEARBITMASK_C(SUPCR,(BM_AVEN | BM_AVCCRM | BM_AVCCLM | BM_AVDIC))
        LDS     R16, _A_SUPCR
        ANDI    R16, 0xE4
        STS     _A_SUPCR, R16
// 2029     }
// 2030 
// 2031     /* LLR-Ref: 080 */
// 2032     g_sRfTxFlowCtrl.bIndex    = 0U;
??ATA_rfTxEnd_C_1:
        LDI     R16, 0
        STS     g_sRfTxFlowCtrl, R16
// 2033     g_sRfTxFlowCtrl.fpLut     = 0x0000U;
        STS     (g_sRfTxFlowCtrl + 1), R16
        STS     (g_sRfTxFlowCtrl + 2), R16
// 2034 }
        RET
          CFI EndBlock cfiBlock8
        REQUIRE _A_FSCR
        REQUIRE _A_FSEN
        REQUIRE _A_SSMIMR
        REQUIRE _A_SSMRR
        REQUIRE _A_PRR2
        REQUIRE _A_PRR0
        REQUIRE _A_SUPCR
        REQUIRE _A_FEEN2
        REQUIRE _A_FEEN1
// 2035 
// 2036 /*---------------------------------------------------------------------------*/
// 2037 /** \brief <b>ATA_rfTxStartSendTelegramSSM_C</b>
// 2038     configures and starts the SendTelegram SSM.
// 2039 
// 2040     Variable Usage:
// 2041     \li [out] ::g_sRfTx Global RF Tx component data
// 2042 
// 2043     \image html ATA_rfTxStartSendTelegramSSM_C.png
// 2044 
// 2045     \internal
// 2046     \li 010: Stop currently running SSM via SSMRR.SSMST
// 2047     \li 020: Configure the SSM via MSMCR1..4 as follows
// 2048                  - SSM_SEND_TELEGRAM_STATE
// 2049                  - SSM_END_STATE
// 2050     \li 030: Clear previous pending SSM interrupts via SSMIFR register
// 2051     \li 040: Clear previous pending SSM error flag via setting flag SSMSR.SSMERR
// 2052     \li 050: Clear rfTx SSM ready flag in ::g_sRfTx .bStatus[6]
// 2053     \li 060: Start SendTelegram SSM via SSMRR.SSMR with SEND_TELEGRAM state
// 2054 
// 2055     \Derived{No}
// 2056 
// 2057     \Rationale{N/A}
// 2058 
// 2059     \Traceability{Primus2P-847}
// 2060     \endinternal
// 2061 \n
// 2062 */
// 2063 /*---------------------------------------------------------------------------*/
// 2064 static VOIDFUNC ATA_rfTxStartSendTelegramSSM_C(void)
// 2065 {
// 2066     /* LLR-Ref: 010 */
// 2067     SSMRR = BM_SSMST;
// 2068 
// 2069     /* LLR-Ref: 020 */
// 2070     MSMCR1 = SSM_SEND_TELEGRAM_STATE    | (uint8_t)(SSM_END_STATE << 4U);
// 2071     MSMCR2 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 2072     MSMCR3 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 2073     MSMCR4 = SSM_END_STATE              | (uint8_t)(SSM_END_STATE << 4U);
// 2074 
// 2075     /* LLR-Ref: 030 */
// 2076     SSMIFR = 0x00U;
// 2077 
// 2078     /* LLR-Ref: 040 */
// 2079     ATA_SETBITMASK_C(SSMSR,BM_SSMERR)
// 2080 
// 2081     /* LLR-Ref: 050 */
// 2082     ATA_CLEARBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_SSMREADY)
// 2083 
// 2084     /* LLR-Ref: 060 */
// 2085     SSMRR = BM_SSMR;
// 2086 }
// 2087 
// 2088 /*---------------------------------------------------------------------------*/
// 2089 /** \brief <b>ATA_rfTxOpenTimer3forTxing_C</b>
// 2090     configures timer 3 for TXMode(buffered).
// 2091 
// 2092     Variable Usage:
// 2093     \li [out] ::g_sTimer3 Global Timer 3 component data
// 2094     \li [in] ::g_sRfTxCurrentService Global RF Tx current service data
// 2095 
// 2096     \image html ATA_rfTxOpenTimer3forTxing_C.png
// 2097 
// 2098     \internal
// 2099     \li 010: Lock Timer 3 via ::g_sTimer3 .bStatus[7]
// 2100     \li 020: Switch on Timer 3 HW block
// 2101     \li 030: Configure Timer 3 registers for TXMode
// 2102                  - T3IMR, disable Timer 3 interrupts
// 2103                  - T3MRB, reset vlaue
// 2104                  - T3MRA, clk = xto/4 prescaler = 1
// 2105     \li 040: Setup T3CORL/H for Tx Data Rate with content from
// 2106               ::g_sRfTxCurrentService .sPath.bTXDR[1..0]
// 2107     \li 050: Enable Timer 3 in T3CR register with
// 2108                  - T3CR.T3CRM
// 2109                  - T3CR.T3CTM
// 2110 
// 2111     \Derived{No}
// 2112 
// 2113     \Rationale{N/A}
// 2114 
// 2115     \Traceability{Primus2P-847}
// 2116     \endinternal
// 2117     \n
// 2118 */
// 2119 /*---------------------------------------------------------------------------*/
// 2120 static VOIDFUNC ATA_rfTxOpenTimer3forTxing_C(void)
// 2121 {
// 2122     /* LLR-Ref: 010 */
// 2123     ATA_SETBITMASK_C(g_sTimer3.bStatus,TMR3LOCK)
// 2124 
// 2125     /* LLR-Ref: 020 */
// 2126     ATA_POWERON_C(PRR1, PRT3)
// 2127 
// 2128     /* LLR-Ref: 030 */
// 2129     T3IMR = 0U;
// 2130     T3MRB = 0U;
// 2131     T3MRA = BM_T3CS1;
// 2132 
// 2133     /* LLR-Ref: 040 */
// 2134     T3CORL = g_sRfTxCurrentService.sPath.bTXDR[0];
// 2135     T3CORH = g_sRfTxCurrentService.sPath.bTXDR[1];
// 2136 
// 2137     /* LLR-Ref: 050 */
// 2138     ATA_SETBITMASK_C(T3CR,(BM_T3ENA | BM_T3CRM | BM_T3CTM))
// 2139 }
// 2140 
// 2141 /*---------------------------------------------------------------------------*/
// 2142 /** \brief <b>ATA_rfTxSFifoFillLevelReached_ISR_C</b>
// 2143     signals S-FIFO fill level reached in ::g_sRfTx .bFlags[1].
// 2144 
// 2145     Variable Usage:
// 2146     \li [out] ::g_sRfTx Global RF Tx component data
// 2147 
// 2148     \image html ATA_rfTxSFifoFillLevelReached_ISR_C.png
// 2149 
// 2150     \internal
// 2151     \li 010: Set fill level reached flag in ::g_sRfTx .bFlags[1]
// 2152 
// 2153     \Derived{No}
// 2154 
// 2155     \Rationale{N/A}
// 2156 
// 2157     \Traceability{Primus2P-845}
// 2158     \endinternal
// 2159 \n
// 2160 */
// 2161 /*---------------------------------------------------------------------------*/
// 2162 //lint -esym(765, ATA_rfTxSFifoFillLevelReached_ISR_C) FlSc (26.05.2014)
// 2163 /* disable lint note 765 - external 'ATA_rfTxSFifoFillLevelReached_ISR_C' could be made static
// 2164  * interrupt service routine shall be accessed from outside via flash software 
// 2165  */
// 2166 //lint -esym(714, ATA_rfTxSFifoFillLevelReached_ISR_C) FlSc (26.05.2014)
// 2167 /* disable lint note 765 - Symbol 'ATA_rfTxSFifoFillLevelReached_ISR_C' not referenced
// 2168  * interrupt service routines are not directly referenced but are called
// 2169  * by the HW interrupt handler
// 2170  */
// 2171 /* #pragma vector=SFFLR_vect */
// 2172 #pragma diag_suppress=Ta006
// 2173 __interrupt VOIDFUNC ATA_rfTxSFifoFillLevelReached_ISR_C(void)
// 2174 {
// 2175     ATA_SET_FUNCTION_TRACE_POINT_ISR_C(ATA_rfTxSFifoFillLevelReached_ISR_C, 0x00);
// 2176     
// 2177     /* LLR-Ref: 010 */
// 2178     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_SFIFO_FILLLEVEL)
// 2179 }
// 2180 
// 2181 /*---------------------------------------------------------------------------*/
// 2182 /** \brief <b>ATA_rfTxSFifoError_ISR_C</b>
// 2183     signals S-FIFO overflow/underflow error in ::g_sRfTx .bFlags[7]
// 2184     and ::g_sRfTx .bFlags[3].
// 2185 
// 2186     Variable Usage:
// 2187     \li [out] ::g_sRfTx Global RF Tx component data
// 2188     \li [out] ::g_sDebug Global Debug component data
// 2189 
// 2190     \image html ATA_rfTxSFifoError_ISR_C.png
// 2191 
// 2192     \internal
// 2193     \li 010: Disable SFIFO error interrupt by clearing SFI.SFERIM to avoid
// 2194               multiple signalling
// 2195     \li 020: Set SFIFO overflow/underflow error flag ::g_sRfTx .bFlags[3]
// 2196     \li 030: Set RF Tx module error flag ::g_sRfTx .bFlags[7]
// 2197     \li 040: Set error code ::g_sDebug .bErrorCode and ::g_sDebug .bSsmErrorCode
// 2198 
// 2199     \Derived{No}
// 2200 
// 2201     \Rationale{N/A}
// 2202 
// 2203     \Traceability{Primus2P-845}
// 2204     \endinternal
// 2205 \n
// 2206 */
// 2207 /*---------------------------------------------------------------------------*/
// 2208 //lint -esym(765, ATA_rfTxSFifoError_ISR_C) FlSc (26.05.2014)
// 2209 /* disable lint note 765 - external 'ATA_rfTxSFifoError_ISR_C' could be made static
// 2210  * interrupt service routine shall be accessed from outside via flash software 
// 2211  */
// 2212 //lint -esym(714, ATA_rfTxSFifoError_ISR_C) FlSc (26.05.2014)
// 2213 /* disable lint note 765 - Symbol 'ATA_rfTxSFifoError_ISR_C' not referenced
// 2214  * interrupt service routines are not directly referenced but are called
// 2215  * by the HW interrupt handler
// 2216  */
// 2217 /* #pragma vector=SFOUE_vect */
// 2218 #pragma diag_suppress=Ta006
// 2219 __interrupt VOIDFUNC ATA_rfTxSFifoError_ISR_C(void)
// 2220 {
// 2221     ATA_SET_FUNCTION_TRACE_POINT_ISR_C(ATA_rfTxSFifoError_ISR_C, 0x00);
// 2222 
// 2223     /* LLR-Ref: 010 */
// 2224     ATA_CLEARBITMASK_C(SFI,BM_SFERIM)
// 2225 
// 2226     /* LLR-Ref: 020 */
// 2227     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_SFIFO_ERROR)
// 2228 
// 2229     /* LLR-Ref: 030 */
// 2230     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 2231 
// 2232     /* LLR-Ref: 040 */
// 2233     g_sDebug.bErrorCode    = DEBUG_ERROR_CODE_RFTX_SFIFO_ERROR;
// 2234     g_sDebug.bSsmErrorCode = 0U;
// 2235 }
// 2236 
// 2237 /*---------------------------------------------------------------------------*/
// 2238 /** \brief <b>ATA_rfTxDFifoFillLevelReached_ISR_C</b>
// 2239     signals D-FIFO fill level reached in g_sRfTx.bFlags[2].
// 2240 
// 2241     Variable Usage:
// 2242     \li [out] ::g_sRfTx Global RF Tx component data
// 2243 
// 2244     \image html ATA_rfTxDFifoFillLevelReached_ISR_C.png
// 2245 
// 2246     \internal
// 2247     \li 010: Set fill level reached flag ::g_sRfTx .bFlags[2]
// 2248 
// 2249     \Derived{No}
// 2250 
// 2251     \Rationale{N/A}
// 2252 
// 2253     \Traceability{Primus2P-845}
// 2254     \endinternal
// 2255 \n
// 2256 */
// 2257 /*---------------------------------------------------------------------------*/
// 2258 //lint -esym(765, ATA_rfTxDFifoFillLevelReached_ISR_C) FlSc (26.05.2014)
// 2259 /* disable lint note 765 - external 'ATA_rfTxDFifoFillLevelReached_ISR_C' could be made static
// 2260  * interrupt service routine shall be accessed from outside via flash software 
// 2261  */
// 2262 //lint -esym(714, ATA_rfTxDFifoFillLevelReached_ISR_C) FlSc (26.05.2014)
// 2263 /* disable lint note 765 - Symbol 'ATA_rfTxDFifoFillLevelReached_ISR_C' not referenced
// 2264  * interrupt service routines are not directly referenced but are called
// 2265  * by the HW interrupt handler
// 2266  */
// 2267 /* #pragma vector=DFFLR_vect */
// 2268 #pragma diag_suppress=Ta006
// 2269 __interrupt VOIDFUNC ATA_rfTxDFifoFillLevelReached_ISR_C(void)
// 2270 {
// 2271     ATA_SET_FUNCTION_TRACE_POINT_ISR_C(ATA_rfTxDFifoFillLevelReached_ISR_C, 0x00);
// 2272 
// 2273     /* LLR-Ref: 010 */
// 2274     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_DFIFO_FILLLEVEL)
// 2275 }
// 2276 
// 2277 /*---------------------------------------------------------------------------*/
// 2278 /** \brief <b>ATA_rfTxDFifoError_ISR_C</b>
// 2279     signals D-FIFO overflow/underflow error in ::g_sRfTx .bFlags[7]
// 2280     and ::g_sRfTx .bFlags[4].
// 2281 
// 2282     Variable Usage:
// 2283     \li [out] ::g_sRfTx Global RF Tx component data
// 2284     \li [out] ::g_sDebug Global Debug component data
// 2285 
// 2286     \image html ATA_rfTxDFifoError_ISR_C.png
// 2287 
// 2288     \internal
// 2289     \li 010: Disable D-FIFO error interrupt by clearing DFI.DFERIM to avoid
// 2290               multiple signalling
// 2291     \li 020: Set SFIFO overflow/underflow error flag in ::g_sRfTx .bFlags[4]
// 2292     \li 030: Set RF Tx module error flag ::g_sRfTx .bFlags[7]
// 2293     \li 040: Set error code ::g_sDebug .bErrorCode and ::g_sDebug .bSsmErrorCode
// 2294 
// 2295     \Derived{No}
// 2296 
// 2297     \Rationale{N/A}
// 2298 
// 2299     \Traceability{Primus2P-845}
// 2300     \endinternal
// 2301 \n
// 2302 */
// 2303 /*---------------------------------------------------------------------------*/
// 2304 //lint -esym(765, ATA_rfTxDFifoError_ISR_C) FlSc (26.05.2014)
// 2305 /* disable lint note 765 - external 'ATA_rfTxDFifoError_ISR_C' could be made static
// 2306  * interrupt service routine shall be accessed from outside via flash software 
// 2307  */
// 2308 //lint -esym(714, ATA_rfTxDFifoError_ISR_C) FlSc (26.05.2014)
// 2309 /* disable lint note 765 - Symbol 'ATA_rfTxDFifoError_ISR_C' not referenced
// 2310  * interrupt service routines are not directly referenced but are called
// 2311  * by the HW interrupt handler
// 2312  */
// 2313 /* #pragma vector=DFOUE_vect */
// 2314 #pragma diag_suppress=Ta006
// 2315 __interrupt VOIDFUNC ATA_rfTxDFifoError_ISR_C(void)
// 2316 {
// 2317     ATA_SET_FUNCTION_TRACE_POINT_ISR_C(ATA_rfTxDFifoError_ISR_C, 0x00);
// 2318 
// 2319     /* LLR-Ref: 010 */
// 2320     ATA_CLEARBITMASK_C(DFI,BM_DFERIM)
// 2321 
// 2322     /* LLR-Ref: 020 */
// 2323     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_DFIFO_ERROR)
// 2324 
// 2325     /* LLR-Ref: 030 */
// 2326     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_ERROR)
// 2327 
// 2328     /* LLR-Ref: 040 */
// 2329     g_sDebug.bErrorCode    = DEBUG_ERROR_CODE_RFTX_DFIFO_ERROR;
// 2330     g_sDebug.bSsmErrorCode = 0U;
// 2331 }
// 2332 
// 2333 /*----------------------------------------------------------------------------- */
// 2334 /** \brief <b>ATA_rfTxSsmRdy_ISR_C</b>
// 2335     signals RF Tx SSM ready flag ::g_sRfTx .bStatus[6].
// 2336 
// 2337     Variable Usage:
// 2338     \li [out] ::g_sRfTx Global RF Tx component data
// 2339 
// 2340     \image html ATA_rfTxSsmRdy_ISR_C.png
// 2341 
// 2342     \internal
// 2343     \li 010: Set RF Tx SSM ready flag ::g_sRfTx .bStatus[6]
// 2344 
// 2345     \Derived{No}
// 2346 
// 2347     \Rationale{N/A}
// 2348 
// 2349     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 2350     \endinternal
// 2351 \n
// 2352 */
// 2353 /*----------------------------------------------------------------------------- */
// 2354 //lint -esym(765, ATA_rfTxSsmRdy_ISR_C) FlSc (26.05.2014)
// 2355 /* disable lint note 765 - external 'ATA_rfTxSsmRdy_ISR_C' could be made static
// 2356  * interrupt service routine shall be accessed from outside via flash software 
// 2357  */
// 2358 //lint -esym(714, ATA_rfTxSsmRdy_ISR_C) FlSc (26.05.2014)
// 2359 /* disable lint note 765 - Symbol 'ATA_rfTxSsmRdy_ISR_C' not referenced
// 2360  * interrupt service routines are not directly referenced but are called
// 2361  * by the HW interrupt handler
// 2362  */
// 2363 /* #pragma vector=SSM_vect */
// 2364 #pragma diag_suppress=Ta006
// 2365 __interrupt VOIDFUNC ATA_rfTxSsmRdy_ISR_C(void)
// 2366 {
// 2367     ATA_SET_FUNCTION_TRACE_POINT_ISR_C(ATA_rfTxSsmRdy_ISR_C, 0x00);
// 2368 
// 2369     /* LLR-Ref: 010 */
// 2370     ATA_SETBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_SSMREADY)
// 2371 }
// 2372 
// 2373 /*---------------------------------------------------------------------------*/
// 2374 /** \brief <b>ATA_rfTxModulatorTelegramFinish_ISR_C</b>
// 2375     signals RF Tx Module transmission complete in ::g_sRfTx .bStatus[5]
// 2376     and End of Telegram in ::g_sRfTx .bFlags[0].
// 2377 
// 2378     Variable Usage:
// 2379     \li [out] ::g_sRfTx Global RF Tx component data
// 2380 
// 2381     \image html ATA_rfTxModulatorTelegramFinish_ISR_C.png
// 2382 
// 2383     \internal
// 2384     \li 010: Stop SendTelegram SSM via SSMRR.SSMST
// 2385     \li 020: Set RF Tx module transmission complete flag ::g_sRfTx .bStatus[5]
// 2386     \li 030: Set End of Telegram flag ::g_sRfTx .bFlags[0]
// 2387 
// 2388     \Derived{No}
// 2389 
// 2390     \Rationale{N/A}
// 2391 
// 2392     \Traceability{Primus2P-898}
// 2393     \endinternal
// 2394 \n
// 2395 */
// 2396 /*---------------------------------------------------------------------------*/
// 2397 //lint -esym(765, ATA_rfTxModulatorTelegramFinish_ISR_C) FlSc (26.05.2014)
// 2398 /* disable lint note 765 - external 'ATA_rfTxModulatorTelegramFinish_ISR_C' could be made static
// 2399  * interrupt service routine shall be accessed from outside via flash software 
// 2400  */
// 2401 //lint -esym(714, ATA_rfTxModulatorTelegramFinish_ISR_C) FlSc (26.05.2014)
// 2402 /* disable lint note 765 - Symbol 'ATA_rfTxModulatorTelegramFinish_ISR_C' not referenced
// 2403  * interrupt service routines are not directly referenced but are called
// 2404  * by the HW interrupt handler
// 2405  */
// 2406 /* #pragma vector=TMTCF_vect */
// 2407 #pragma diag_suppress=Ta006
// 2408 __interrupt VOIDFUNC ATA_rfTxModulatorTelegramFinish_ISR_C(void)
// 2409 {
// 2410     ATA_SET_FUNCTION_TRACE_POINT_ISR_C(ATA_rfTxModulatorTelegramFinish_ISR_C, 0x00);
// 2411 
// 2412     /* LLR-Ref: 010 */
// 2413     SSMRR = BM_SSMST;
// 2414 
// 2415     /* LLR-Ref: 020 */
// 2416     ATA_SETBITMASK_C(g_sRfTx.bStatus,BM_RFTXCONFIG_BSTATUS_TRANSMISSION_COMPLETE)
// 2417 
// 2418     /* LLR-Ref: 030 */
// 2419     ATA_SETBITMASK_C(g_sRfTx.bFlags,BM_RFTXCONFIG_BFLAGS_EOT)
// 2420 }
// 2421 
// 2422 /*----------------------------------------------------------------------------- */
// 2423 /** \brief <b>ATA_rfTxStartShutDownSSM_C</b>
// 2424     starts the SSM shutdown.
// 2425     
// 2426     \image html ATA_rfTxStartShutDownSSM_C.png
// 2427 
// 2428     \internal
// 2429     \li 010: Reset FSCR register (except FSCR.PAOER --> done via SSM)
// 2430     \li 020: Reset FSEN register (except FSCR.ANTT  --> done via SSM)
// 2431     \li 030: Power up SSM HW block
// 2432     \li 040: Stop currently running SSM via SSMRR.SSMST
// 2433     \li 050: Reset SSM by clearing SSMCR register content
// 2434     \li 060: Configure SSM via MSMCR1..4 as follows
// 2435                  - SSM_SHUTDOWN_STATE
// 2436                  - SSM_END_STATE
// 2437     \li 070: Reset SSMIFR to clear previous SSM interrupt flags
// 2438     \li 080: Reset SSMSR.SSMERR flag
// 2439     \li 090: Enable SSM ready interrupt in SSMIMR.SSMIM
// 2440 
// 2441     \Derived{No}
// 2442 
// 2443     \Rationale{N/A}
// 2444 
// 2445     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 2446     \endinternal
// 2447 \n
// 2448 */
// 2449 /*----------------------------------------------------------------------------- */

        RSEG CODE:CODE:ROOT(1)
// 2450 static VOIDFUNC ATA_rfTxStartShutDownSSM_C(void)
ATA_rfTxStartShutDownSSM_C:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function ATA_rfTxStartShutDownSSM_C
          CFI NoCalls
// 2451 {
// 2452     /* LLR-Ref: 010 */
// 2453     ATA_CLEARBITMASK_C(FSCR,BM_PAOER)
        CBI     0x0F, 0x04
// 2454 
// 2455     /* LLR-Ref: 020 */
// 2456     ATA_CLEARBITMASK_C(FSEN,BM_ANTT)
        LDS     R16, 96
        ANDI    R16, 0xDF
        STS     96, R16
// 2457 
// 2458     /* LLR-Ref: 030 */
// 2459     ATA_POWERON_C(PRR2, PRSSM)
        CBI     0x02, 0x07
// 2460 
// 2461     /* LLR-Ref: 040 */
// 2462     SSMRR = BM_SSMST;
        LDI     R16, 2
        STS     _A_SSMRR, R16
// 2463 
// 2464     /* LLR-Ref: 050 */
// 2465     SSMCR = 0x00U;
        LDI     R16, 0
        STS     _A_SSMCR, R16
// 2466 
// 2467     /* LLR-Ref: 060 */
// 2468     MSMCR1 = SSM_SHUTDOWN_STATE | (uint8_t)(SSM_END_STATE << 4U);
        LDI     R16, 6
        STS     _A_MSMCR1, R16
// 2469 
// 2470     /* LLR-Ref: 070 */
// 2471     SSMIFR = 0x00U;
        LDI     R16, 0
        STS     _A_SSMIFR, R16
// 2472 
// 2473     /* LLR-Ref: 080 */
// 2474     ATA_SETBITMASK_C(SSMSR,BM_SSMERR)
        LDS     R16, 230
        ORI     R16, 0x80
        STS     230, R16
// 2475 
// 2476     /* LLR-Ref: 090 */
// 2477     SSMIMR = BM_SSMIM;
        LDI     R16, 1
        STS     _A_SSMIMR, R16
// 2478 
// 2479     /* LLR-Ref: 100 */
// 2480     SSMRR  = BM_SSMR;
          CFI EndBlock cfiBlock9
        REQUIRE ?Subroutine2
        REQUIRE _A_FSCR
        REQUIRE _A_FSEN
        REQUIRE _A_PRR2
        REQUIRE _A_SSMRR
        REQUIRE _A_SSMCR
        REQUIRE _A_MSMCR1
        REQUIRE _A_SSMIFR
        REQUIRE _A_SSMSR
        REQUIRE _A_SSMIMR
        ;               // Fall through to label ?Subroutine2
// 2481 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI NoFunction
        STS     _A_SSMRR, R16
        RET
          CFI EndBlock cfiBlock10
// 2482 
// 2483 
// 2484 /*---------------------------------------------------------------------------*/
// 2485 /** \brief <b>ATA_rfTxStartSsmWatchdog_C</b>
// 2486     starts Timer2 to check timeouts of HW sequencer state machines.
// 2487 
// 2488     \return     OK on success, FAIL on failure
// 2489 
// 2490     \image html ATA_rfTxStartSsmWatchdog_C.png
// 2491 
// 2492     \internal
// 2493     \li 010: Open Timer 2 by calling function ::ATA_timer2Open_C in order to start
// 2494              the SSM watchdog timer.
// 2495 
// 2496     \Derived{No}
// 2497 
// 2498     \Rationale{N/A}
// 2499 
// 2500     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 2501     \endinternal
// 2502 \n
// 2503 */
// 2504 /*---------------------------------------------------------------------------*/
// 2505 UINT8FUNC ATA_rfTxStartSsmWatchdog_C(void)
// 2506 {

        RSEG NEAR_F:CODE:NOROOT(0)
// 2507     sTimerAsyn8BitParams  sTimer2Params = {
`?<Constant {128, 0, 255, 0, (void (*)(void))0,`:
        DC8 128, 0, 255, 0
        DC16 0H, 0H

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStopSsmWatchdog_C:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function ATA_rfTxStopSsmWatchdog_C
          CFI FunCall ATA_timer2Close_C
        JMP     ATA_timer2Close_C
          CFI EndBlock cfiBlock11

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxShutdown_C:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function ATA_rfTxShutdown_C
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxShutdown_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxShutdown_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
          CFI FunCall ATA_rfTxStopSsmWatchdog_C
        RCALL   ATA_rfTxStopSsmWatchdog_C
          CFI FunCall ATA_rfTxStartShutDownSSM_C
        RCALL   ATA_rfTxStartShutDownSSM_C
        LDI     R16, 5
          CFI FunCall ATA_globalsWaitNus_ASM
        CALL    ATA_globalsWaitNus_ASM
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        SBRS    R16, 6
        RJMP    ??ATA_rfTxShutdown_C_0
        LDS     R16, _A_SSMSR
        TST     R16
        BRNE    ??ATA_rfTxShutdown_C_0
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
        RJMP    ??ATA_rfTxShutdown_C_1
??ATA_rfTxShutdown_C_0:
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 35
        STS     g_sDebug, R16
        LDS     R16, _A_SSMSR
        STS     (g_sDebug + 1), R16
??ATA_rfTxShutdown_C_1:
        LDS     R16, 220
        ORI     R16, 0x80
        STS     220, R16
        LDS     R16, 213
        ORI     R16, 0x80
        STS     213, R16
          CFI FunCall ATA_rfTxEnd_C
        RCALL   ATA_rfTxEnd_C
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xEF
        STD     Z+2, R16
        LD      R16, Z
        ANDI    R16, 0xBF
        ST      Z, R16
        RET
          CFI EndBlock cfiBlock12
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SSMSR
        REQUIRE _A_SFL
        REQUIRE _A_DFL

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStop_C:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function ATA_rfTxStop_C
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxStop_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxStop_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
          CFI FunCall ATA_rfTxShutdown_C
        RJMP    ATA_rfTxShutdown_C
          CFI EndBlock cfiBlock13
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxProcessing_C:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function ATA_rfTxProcessing_C
        LDS     R16, g_sRfTxFlowCtrl
        LDS     R30, (g_sRfTxFlowCtrl + 1)
        LDS     R31, (g_sRfTxFlowCtrl + 2)
        LDI     R17, 2
        MUL     R16, R17
        ADD     R30, R0
        ADC     R31, R1
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
          CFI FunCall
        IJMP
          CFI EndBlock cfiBlock14

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxConfigureTxSSM_C:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function ATA_rfTxConfigureTxSSM_C
          CFI NoCalls
        LDS     R16, (g_sRfTx + 3)
        ANDI    R16, 0xC0
        LDI     R17, 2
        STS     _A_SSMRR, R17
        BRNE    ??ATA_rfTxConfigureTxSSM_C_0
        LDI     R16, 33
        STS     _A_MSMCR1, R16
        LDI     R16, 3
        RJMP    ??ATA_rfTxConfigureTxSSM_C_1
??ATA_rfTxConfigureTxSSM_C_0:
        CPI     R16, 64
        BRNE    ??ATA_rfTxConfigureTxSSM_C_2
        LDI     R16, 113
        STS     _A_MSMCR1, R16
        LDI     R16, 50
        RJMP    ??ATA_rfTxConfigureTxSSM_C_1
??ATA_rfTxConfigureTxSSM_C_2:
        CPI     R16, 128
        BRNE    ??ATA_rfTxConfigureTxSSM_C_3
        LDI     R16, 33
        STS     _A_MSMCR1, R16
        LDI     R16, 131
??ATA_rfTxConfigureTxSSM_C_1:
        STS     _A_MSMCR2, R16
        LDI     R16, 0
        STS     _A_MSMCR3, R16
        RJMP    ??ATA_rfTxConfigureTxSSM_C_4
??ATA_rfTxConfigureTxSSM_C_3:
        LDI     R16, 113
        STS     _A_MSMCR1, R16
        LDI     R16, 50
        STS     _A_MSMCR2, R16
        LDI     R16, 8
        STS     _A_MSMCR3, R16
        LDI     R16, 0
??ATA_rfTxConfigureTxSSM_C_4:
        STS     _A_MSMCR4, R16
        LDS     R16, (g_sRfTx + 2)
        SBRS    R16, 7
        RJMP    ??ATA_rfTxConfigureTxSSM_C_5
        LDS     R16, _A_MSMCR1
        ANDI    R16, 0xF0
        STS     _A_MSMCR1, R16
        LDS     R16, 236
        ORI     R16, 0x04
        STS     236, R16
??ATA_rfTxConfigureTxSSM_C_5:
        LDS     R16, g_sRfTxCurrentService
        STS     _A_SSMFBR, R16
        LDI     R16, 0
        STS     _A_SSMCR, R16
        LDI     R30, LOW(g_sRfTxCurrentService)
        LDI     R31, (g_sRfTxCurrentService) >> 8
        LDD     R16, Z+15
        SBRS    R16, 7
        RJMP    ??ATA_rfTxConfigureTxSSM_C_6
        LDS     R16, 226
        ORI     R16, 0x04
        STS     226, R16
??ATA_rfTxConfigureTxSSM_C_6:
        LDD     R16, Z+15
        SBRS    R16, 6
        RJMP    ??ATA_rfTxConfigureTxSSM_C_7
        LDS     R16, 226
        ORI     R16, 0x08
        STS     226, R16
??ATA_rfTxConfigureTxSSM_C_7:
        LDD     R16, Z+16
        SBRS    R16, 6
        RJMP    ??ATA_rfTxConfigureTxSSM_C_8
        LDS     R16, 226
        ORI     R16, 0x20
        STS     226, R16
??ATA_rfTxConfigureTxSSM_C_8:
        RET
          CFI EndBlock cfiBlock15
        REQUIRE _A_SSMRR
        REQUIRE _A_MSMCR1
        REQUIRE _A_MSMCR2
        REQUIRE _A_MSMCR3
        REQUIRE _A_MSMCR4
        REQUIRE _A_SSMFBR
        REQUIRE _A_SSMCR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxSetupTxModulator_C:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function ATA_rfTxSetupTxModulator_C
          CFI NoCalls
        LDI     R16, 24
        STS     _A_TMCR1, R16
        LDS     R16, (g_sRfTxCurrentService + 19)
        STS     _A_TMCR2, R16
        LDI     R16, 1
        STS     _A_TMSR, R16
        LDS     R16, (g_sRfTxCurrentService + 20)
        STS     _A_TMSSC, R16
        LDS     R16, (g_sRfTxCurrentService + 21)
        STS     _A_TMTLL, R16
        LDS     R16, (g_sRfTxCurrentService + 22)
        STS     _A_TMTLH, R16
        LDS     R16, (g_sRfTxCurrentService + 23)
        STS     _A_TMCPL, R16
        LDS     R16, (g_sRfTxCurrentService + 24)
        STS     _A_TMCPH, R16
        LDS     R16, (g_sRfTxCurrentService + 25)
        STS     _A_TMCIL, R16
        LDS     R16, (g_sRfTxCurrentService + 26)
        STS     _A_TMCIH, R16
        LDS     R16, (g_sRfTxCurrentService + 27)
        STS     _A_TMCSB, R16
        RET
          CFI EndBlock cfiBlock16
        REQUIRE _A_TMCR1
        REQUIRE _A_TMCR2
        REQUIRE _A_TMSR
        REQUIRE _A_TMSSC
        REQUIRE _A_TMTLL
        REQUIRE _A_TMTLH
        REQUIRE _A_TMCPL
        REQUIRE _A_TMCPH
        REQUIRE _A_TMCIL
        REQUIRE _A_TMCIH
        REQUIRE _A_TMCSB

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxFrequencySettings_C:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function ATA_rfTxFrequencySettings_C
          CFI NoCalls
        LDS     R22, (g_sRfTxCurrentService + 30)
        LDS     R21, (g_sRfTxCurrentService + 29)
        LDS     R20, (g_sRfTxCurrentService + 28)
        LDS     R1, (g_sRfTxCurrentService + 7)
        CLR     R2
        LDS     R16, (g_sRfTxCurrentService + 6)
        ADD     R20, R16
        ADC     R21, R1
        ADC     R22, R2
        LDS     R16, (g_sRfTxCurrentService + 16)
        SBRS    R16, 7
        RJMP    ??ATA_rfTxFrequencySettings_C_0
        LDS     R16, _A_FFREQ1H
        STS     _A_FFREQ2H, R16
        LDS     R16, _A_FFREQ1M
        STS     _A_FFREQ2M, R16
        LDS     R16, _A_FFREQ1L
        STS     _A_FFREQ2L, R16
        LDI     R16, 3
        OUT     0x0F, R16
        STS     _A_FFREQ1H, R22
        STS     _A_FFREQ1M, R21
        STS     _A_FFREQ1L, R20
        OUT     0x0F, R2
        RET
??ATA_rfTxFrequencySettings_C_0:
        LDS     R1, (g_sRfTxCurrentService + 9)
        LDS     R0, (g_sRfTxCurrentService + 8)
        LDS     R16, _A_FFREQ1H
        STS     _A_FFREQ2H, R16
        LDS     R16, _A_FFREQ1M
        STS     _A_FFREQ2M, R16
        LDS     R16, _A_FFREQ1L
        STS     _A_FFREQ2L, R16
        LDI     R16, 3
        OUT     0x0F, R16
        MOVW    R17:R16, R1:R0
        LSR     R17
        ROR     R16
        SUB     R20, R16
        SBC     R21, R17
        SBCI    R22, 0
        STS     _A_FFREQ1H, R22
        STS     _A_FFREQ1M, R21
        STS     _A_FFREQ1L, R20
        OUT     0x0F, R2
        ADD     R20, R0
        ADC     R21, R1
        ADC     R22, R2
        STS     _A_FFREQ2H, R22
        STS     _A_FFREQ2M, R21
        STS     _A_FFREQ2L, R20
        RET
          CFI EndBlock cfiBlock17
        REQUIRE _A_FFREQ2H
        REQUIRE _A_FFREQ1H
        REQUIRE _A_FFREQ2M
        REQUIRE _A_FFREQ1M
        REQUIRE _A_FFREQ2L
        REQUIRE _A_FFREQ1L
        REQUIRE _A_FSCR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxInitTxSSM_C:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function ATA_rfTxInitTxSSM_C
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxInitTxSSM_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxInitTxSSM_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        CBI     0x1A, 0x02
        CBI     0x02, 0x07
          CFI FunCall ATA_rfTxFrequencySettings_C
        RCALL   ATA_rfTxFrequencySettings_C
        LDS     R16, 96
        ORI     R16, 0x02
        STS     96, R16
        CBI     0x0F, 0x00
        LDS     R16, (g_sRfTx + 3)
        SBRS    R16, 5
        RJMP    ??ATA_rfTxInitTxSSM_C_0
        SBI     0x0F, 0x02
        RJMP    ??ATA_rfTxInitTxSSM_C_1
??ATA_rfTxInitTxSSM_C_0:
        SBI     0x0F, 0x03
??ATA_rfTxInitTxSSM_C_1:
        LDS     R16, (g_sRfTxCurrentService + 16)
        SBRS    R16, 7
        RJMP    ??ATA_rfTxInitTxSSM_C_2
        SBI     0x0F, 0x00
        RJMP    ??ATA_rfTxInitTxSSM_C_3
??ATA_rfTxInitTxSSM_C_2:
        SBI     0x0F, 0x01
??ATA_rfTxInitTxSSM_C_3:
        LDS     R16, (g_sRfTxCurrentService + 12)
        STS     _A_FSFCR, R16
        LDS     R16, (g_sRfTxCurrentService + 10)
        STS     _A_GACDIVL, R16
        LDS     R16, (g_sRfTxCurrentService + 11)
        STS     _A_GACDIVH, R16
          CFI FunCall ATA_rfTxSetupTxModulator_C
        RCALL   ATA_rfTxSetupTxModulator_C
          CFI FunCall ATA_rfTxConfigureTxSSM_C
        RCALL   ATA_rfTxConfigureTxSSM_C
          CFI EndBlock cfiBlock18
        REQUIRE ?Subroutine1
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_PRR0
        REQUIRE _A_PRR2
        REQUIRE _A_FSEN
        REQUIRE _A_FSCR
        REQUIRE _A_FSFCR
        REQUIRE _A_GACDIVL
        REQUIRE _A_GACDIVH
        ;               // Fall through to label ?Subroutine1

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI NoFunction
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
          CFI EndBlock cfiBlock19
        REQUIRE ??Subroutine8_0
        ;               // Fall through to label ??Subroutine8_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine8_0:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI NoFunction
        STS     g_sRfTxFlowCtrl, R16
        RET
          CFI EndBlock cfiBlock20

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxWait4AVCC_C:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function ATA_rfTxWait4AVCC_C
          CFI NoCalls
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxWait4AVCC_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxWait4AVCC_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDS     R16, _A_SUPFR
        ORI     R16, 0x03
        STS     _A_SUPFR, R16
        LDS     R16, _A_SUPFR
        ANDI    R16, 0x03
        BRNE    ??ATA_rfTxWait4AVCC_C_0
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        STS     g_sRfTxFlowCtrl, R16
??ATA_rfTxWait4AVCC_C_0:
        RET
          CFI EndBlock cfiBlock21
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SUPFR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxFevcoCalculation_C:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function ATA_rfTxFevcoCalculation_C
        SBIW    R29:R28, 1
          CFI CFA_Y Y+1
        LDI     R16, 0
        ST      Y, R16
        LDI     R20, 1
        LDI     R18, LOW((g_sAtmelEEPromSection + 133))
        LDI     R19, HIGH((g_sAtmelEEPromSection + 133))
        MOVW    R17:R16, R29:R28
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        TST     R16
        BREQ    ??ATA_rfTxFevcoCalculation_C_0
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 63
        STS     g_sDebug, R16
??ATA_rfTxFevcoCalculation_C_0:
        LDS     R16, (g_sRfTxCurrentService + 4)
        SWAP    R16
        ANDI    R16, 0x0F
        LD      R18, Y
        SWAP    R18
        ANDI    R18, 0x0F
        LDS     R17, (g_sRfTxCurrentService + 4)
        ANDI    R17, 0x0F
        LD      R19, Y
        ANDI    R19, 0x0F
        CPI     R16, 8
        BRCS    ??ATA_rfTxFevcoCalculation_C_1
        ORI     R16, 0xF0
??ATA_rfTxFevcoCalculation_C_1:
        CPI     R17, 8
        BRCS    ??ATA_rfTxFevcoCalculation_C_2
        ORI     R17, 0xF0
??ATA_rfTxFevcoCalculation_C_2:
        ADD     R16, R18
        SUBI    R16, 249
        MOV     R18, R16
        BRPL    ??ATA_rfTxFevcoCalculation_C_3
        LDI     R18, 0
??ATA_rfTxFevcoCalculation_C_3:
        SWAP    R18
        ANDI    R18, 0xF0
        MOV     R16, R18
        ADD     R17, R19
        SUBI    R17, 249
        MOV     R18, R17
        BRPL    ??ATA_rfTxFevcoCalculation_C_4
        LDI     R18, 0
??ATA_rfTxFevcoCalculation_C_4:
        ANDI    R18, 0x0F
        OR      R16, R18
          CFI EndBlock cfiBlock22
        REQUIRE ?Subroutine4
        ;               // Fall through to label ?Subroutine4

        RSEG CODE:CODE:NOROOT(1)
?Subroutine4:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI NoFunction
          CFI CFA_Y Y+1
        ADIW    R29:R28, 1
          CFI CFA_Y Y+0
        RET
          CFI EndBlock cfiBlock23

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxInitFrontEnd_C:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function ATA_rfTxInitFrontEnd_C
        SBIW    R29:R28, 1
          CFI CFA_Y Y+1
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxInitFrontEnd_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxInitFrontEnd_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDI     R20, 1
        LDI     R18, LOW((g_sAtmelEEPromSection + 132))
        LDI     R19, HIGH((g_sAtmelEEPromSection + 132))
        MOVW    R17:R16, R29:R28
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        TST     R16
        BREQ    ??ATA_rfTxInitFrontEnd_C_0
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 63
        STS     g_sDebug, R16
??ATA_rfTxInitFrontEnd_C_0:
        LD      R16, Y
        STS     _A_FETN4, R16
        LDS     R16, 257
        ORI     R16, 0x04
        STS     257, R16
        LDS     R16, (g_sRfTxCurrentService + 2)
        STS     _A_FEAT, R16
        LDI     R20, 1
        LDI     R18, LOW((g_sAtmelEEPromSection + 131))
        LDI     R19, HIGH((g_sAtmelEEPromSection + 131))
        MOVW    R17:R16, R29:R28
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        TST     R16
        BREQ    ??ATA_rfTxInitFrontEnd_C_1
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 63
        STS     g_sDebug, R16
??ATA_rfTxInitFrontEnd_C_1:
        LD      R16, Y
        STS     _A_FEBT, R16
        LDS     R16, (g_sRfTxCurrentService + 3)
        STS     _A_FEPAC, R16
          CFI FunCall ATA_rfTxFevcoCalculation_C
        RCALL   ATA_rfTxFevcoCalculation_C
        STS     _A_FEVCO, R16
        LDS     R16, (g_sRfTxCurrentService + 32)
        STS     _A_FECR, R16
        LDS     R16, (g_sRfTxCurrentService + 31)
        STS     _A_FEMS, R16
        LDS     R16, (g_sRfTxCurrentService + 5)
        STS     _A_FEVCT, R16
        LDS     R16, (g_sRfTxCurrentService + 3)
        CPI     R16, 43
        BRCS    ??ATA_rfTxInitFrontEnd_C_2
        LDS     R16, 204
        ORI     R16, 0x08
        STS     204, R16
??ATA_rfTxInitFrontEnd_C_2:
        LDS     R16, (g_sRfTxCurrentService + 1)
        ANDI    R16, 0x0F
        STS     _A_FEANT, R16
        LDS     R16, (g_sRfTxCurrentService + 1)
        SWAP    R16
        ANDI    R16, 0x03
        STS     _A_FEALR, R16
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        STS     g_sRfTxFlowCtrl, R16
        RJMP    ?Subroutine4
          CFI EndBlock cfiBlock24
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_FETN4
        REQUIRE _A_FEEN1
        REQUIRE _A_FEAT
        REQUIRE _A_FEBT
        REQUIRE _A_FEPAC
        REQUIRE _A_FEVCO
        REQUIRE _A_FECR
        REQUIRE _A_FEMS
        REQUIRE _A_FEVCT
        REQUIRE _A_SUPCR
        REQUIRE _A_FEANT
        REQUIRE _A_FEALR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxWait4XTO_C:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function ATA_rfTxWait4XTO_C
        LDS     R16, _A_FESR
        SBRS    R16, 2
        RJMP    ??ATA_rfTxWait4XTO_C_0
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxWait4XTO_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxWait4XTO_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDS     R16, _A_CMCR
        SBRS    R16, 2
        RJMP    ??ATA_rfTxWait4XTO_C_1
        LDS     R16, _A_CMCR
        SBRC    R16, 3
        RJMP    ??ATA_rfTxWait4XTO_C_2
??ATA_rfTxWait4XTO_C_1:
        LDI     R16, 7
          CFI FunCall ATA_globalsClkSwitchXTO_C
        CALL    ATA_globalsClkSwitchXTO_C
??ATA_rfTxWait4XTO_C_2:
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        STS     g_sRfTxFlowCtrl, R16
??ATA_rfTxWait4XTO_C_0:
        RET
          CFI EndBlock cfiBlock25
        REQUIRE _A_FESR
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_CMCR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStartSSM_C:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function ATA_rfTxStartSSM_C
        ST      -Y, R24
          CFI R24 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        MOV     R24, R16
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxStartSSM_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxStartSSM_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDI     R16, 0
        STS     _A_SSMIFR, R16
        LDS     R16, 230
        ORI     R16, 0x80
        STS     230, R16
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
        LDI     R16, 1
        STS     _A_SSMIMR, R16
          CFI FunCall ATA_rfTxStartSsmWatchdog_C
        RCALL   ATA_rfTxStartSsmWatchdog_C
        TST     R16
        BREQ    ??ATA_rfTxStartSSM_C_0
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 34
        STS     g_sDebug, R16
        LDI     R16, 0
        STS     (g_sDebug + 1), R16
        STS     g_sRfTxFlowCtrl, R24
        RJMP    ??ATA_rfTxStartSSM_C_1
??ATA_rfTxStartSSM_C_0:
        LDI     R16, 1
        STS     _A_SSMRR, R16
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        STS     g_sRfTxFlowCtrl, R16
??ATA_rfTxStartSSM_C_1:
        RJMP    ?Subroutine3
          CFI EndBlock cfiBlock26
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SSMIFR
        REQUIRE _A_SSMSR
        REQUIRE _A_SSMIMR
        REQUIRE _A_SSMRR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStartTxBufSSM_C:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function ATA_rfTxStartTxBufSSM_C
          CFI NoCalls
        LDI     R16, 9
          CFI EndBlock cfiBlock27
        REQUIRE ?Subroutine5
        ;               // Fall through to label ?Subroutine5

        RSEG CODE:CODE:NOROOT(1)
?Subroutine5:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI NoFunction
          CFI FunCall ATA_rfTxStartTxBufSSM_C ATA_rfTxStartSSM_C
          CFI FunCall ATA_rfTxStartTxTransSSM_C ATA_rfTxStartSSM_C
        RJMP    ATA_rfTxStartSSM_C
          CFI EndBlock cfiBlock28

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStartTxTransSSM_C:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function ATA_rfTxStartTxTransSSM_C
          CFI NoCalls
        LDI     R16, 7
        RJMP    ?Subroutine5
          CFI EndBlock cfiBlock29

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxWait4SSMrdy_C:
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function ATA_rfTxWait4SSMrdy_C
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        SBRS    R16, 6
        RJMP    ??ATA_rfTxWait4SSMrdy_C_0
        LDS     R16, _A_SSMSR
        TST     R16
        BRNE    ??ATA_rfTxWait4SSMrdy_C_0
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxWait4SSMrdy_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxWait4SSMrdy_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
          CFI FunCall ATA_rfTxStopSsmWatchdog_C
        RCALL   ATA_rfTxStopSsmWatchdog_C
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
        LD      R16, Z
        ORI     R16, 0x40
        ST      Z, R16
        LDS     R16, _A_FEAT
        STS     (g_sRfTxCurrentService + 2), R16
        STS     g_bAntennaTuningResult, R16
        LDS     R16, _A_FEVCT
        STS     (g_sRfTxCurrentService + 5), R16
        STS     g_bVcoTuningResult, R16
        LDD     R16, Z+3
        SBRC    R16, 5
        SBI     0x0F, 0x04
??ATA_rfTxWait4SSMrdy_C_1:
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        RJMP    ??ATA_rfTxWait4SSMrdy_C_2
??ATA_rfTxWait4SSMrdy_C_0:
        LDS     R16, _A_T2IFR
        SBRC    R16, 1
        RJMP    ??ATA_rfTxWait4SSMrdy_C_3
        LDS     R16, _A_SSMSR
        TST     R16
        BREQ    ??ATA_rfTxWait4SSMrdy_C_4
??ATA_rfTxWait4SSMrdy_C_3:
        LDI     R16, 2
        STS     _A_SSMRR, R16
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        LDI     R16, 36
        STS     g_sDebug, R16
        LDS     R16, _A_SSMSR
        STS     (g_sDebug + 1), R16
        LDD     R16, Z+3
        SBRS    R16, 5
        RJMP    ??ATA_rfTxWait4SSMrdy_C_5
        LDI     R16, 7
??ATA_rfTxWait4SSMrdy_C_2:
        RJMP    ??Subroutine8_0
??ATA_rfTxWait4SSMrdy_C_5:
        LDI     R16, 9
        STS     g_sRfTxFlowCtrl, R16
??ATA_rfTxWait4SSMrdy_C_4:
        RET
          CFI EndBlock cfiBlock30
        REQUIRE _A_SSMSR
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_FEAT
        REQUIRE _A_FEVCT
        REQUIRE _A_FSCR
        REQUIRE _A_T2IFR
        REQUIRE _A_SSMRR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxTransparentMode_C:
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function ATA_rfTxTransparentMode_C
          CFI NoCalls
        RET
          CFI EndBlock cfiBlock31

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxWait4FillLevel_C:
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function ATA_rfTxWait4FillLevel_C
          CFI NoCalls
        LDS     R16, _A_DFL
        LDI     R17, 0
        ANDI    R16, 0x3F
        LDS     R18, (g_sRfTxCurrentService + 15)
        ANDI    R18, 0x3F
        CP      R16, R18
        CPC     R17, R17
        BRLT    ??ATA_rfTxWait4FillLevel_C_0
        LDS     R16, _A_SFL
        ANDI    R16, 0x1F
        LDS     R18, (g_sRfTxCurrentService + 16)
        ANDI    R18, 0x1F
        CP      R16, R18
        CPC     R17, R17
        BRLT    ??ATA_rfTxWait4FillLevel_C_0
        IN      R18, 0x3F
        CLI
        STS     _A_TRCDR, R17
        LDI     R16, LOW(ATA_rfTxWait4FillLevel_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxWait4FillLevel_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        STS     g_sRfTxFlowCtrl, R16
??ATA_rfTxWait4FillLevel_C_0:
        RET
          CFI EndBlock cfiBlock32
        REQUIRE _A_DFL
        REQUIRE _A_SFL
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStartSendTelegramSSM_C:
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function ATA_rfTxStartSendTelegramSSM_C
          CFI NoCalls
        LDI     R16, 2
        STS     _A_SSMRR, R16
        LDI     R16, 5
        STS     _A_MSMCR1, R16
        LDI     R16, 0
        STS     _A_MSMCR2, R16
        STS     _A_MSMCR3, R16
        STS     _A_MSMCR4, R16
        STS     _A_SSMIFR, R16
        LDS     R16, 230
        ORI     R16, 0x80
        STS     230, R16
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
        LDI     R16, 1
        RJMP    ?Subroutine2
          CFI EndBlock cfiBlock33
        REQUIRE _A_SSMRR
        REQUIRE _A_MSMCR1
        REQUIRE _A_MSMCR2
        REQUIRE _A_MSMCR3
        REQUIRE _A_MSMCR4
        REQUIRE _A_SSMIFR
        REQUIRE _A_SSMSR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxOpenTimer3forTxing_C:
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function ATA_rfTxOpenTimer3forTxing_C
          CFI NoCalls
        LDI     R30, LOW(g_sTimer3)
        LDI     R31, (g_sTimer3) >> 8
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
        CBI     0x01, 0x02
        LDI     R16, 0
        STS     _A_T3IMR, R16
        STS     _A_T3MRB, R16
        LDI     R16, 2
        STS     _A_T3MRA, R16
        LDS     R16, (g_sRfTxCurrentService + 13)
        STS     _A_T3CORL, R16
        LDS     R16, (g_sRfTxCurrentService + 14)
        STS     _A_T3CORH, R16
        IN      R16, 0x13
        ORI     R16, 0x86
        OUT     0x13, R16
        RET
          CFI EndBlock cfiBlock34
        REQUIRE _A_PRR1
        REQUIRE _A_T3IMR
        REQUIRE _A_T3MRB
        REQUIRE _A_T3MRA
        REQUIRE _A_T3CORL
        REQUIRE _A_T3CORH
        REQUIRE _A_T3CR

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStartTxModulator_C:
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function ATA_rfTxStartTxModulator_C
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxStartTxModulator_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxStartTxModulator_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDI     R16, 128
        STS     _A_SFC, R16
        LDS     R16, (g_sRfTxCurrentService + 18)
        ANDI    R16, 0x1F
        LDS     R17, _A_SFC
        OR      R17, R16
        STS     _A_SFC, R17
        LDS     R16, 224
        ORI     R16, 0x01
        STS     224, R16
        LDI     R16, 128
        STS     _A_DFC, R16
        LDS     R16, (g_sRfTxCurrentService + 17)
        ANDI    R16, 0x3F
        LDS     R17, _A_DFC
        OR      R17, R16
        STS     _A_DFC, R17
        LDS     R16, 217
        ORI     R16, 0x01
        STS     217, R16
        SBI     0x0F, 0x04
        SBI     0x02, 0x06
        CBI     0x02, 0x06
          CFI FunCall ATA_rfTxOpenTimer3forTxing_C
        RCALL   ATA_rfTxOpenTimer3forTxing_C
          CFI FunCall ATA_rfTxStartSendTelegramSSM_C
        RCALL   ATA_rfTxStartSendTelegramSSM_C
        RJMP    ?Subroutine1
          CFI EndBlock cfiBlock35
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SFC
        REQUIRE _A_SFI
        REQUIRE _A_DFC
        REQUIRE _A_DFI
        REQUIRE _A_FSCR
        REQUIRE _A_PRR2

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxWait4TransmissionComplete_C:
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function ATA_rfTxWait4TransmissionComplete_C
          CFI NoCalls
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        SBRS    R16, 5
        RJMP    ??ATA_rfTxWait4TransmissionComplete_C_0
        IN      R18, 0x3F
        CLI
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxWait4TransmissionComplete_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxWait4TransmissionComplete_C/2) >> 8
        STS     _A_TRCIDH, R16
        OUT     0x3F, R18
        LDD     R16, Z+2
        ANDI    R16, 0xDF
        STD     Z+2, R16
        LDS     R16, 224
        ANDI    R16, 0xFE
        STS     224, R16
        LDS     R16, 217
        ANDI    R16, 0xFE
        STS     217, R16
        LDD     R16, Z+3
        SBRS    R16, 2
        RJMP    ??ATA_rfTxWait4TransmissionComplete_C_1
        LDI     R16, 6
        RJMP    ??Subroutine8_0
??ATA_rfTxWait4TransmissionComplete_C_1:
        LDS     R16, g_sRfTxFlowCtrl
        INC     R16
        STS     g_sRfTxFlowCtrl, R16
??ATA_rfTxWait4TransmissionComplete_C_0:
        RET
          CFI EndBlock cfiBlock36
        REQUIRE _A_SREG
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SFI
        REQUIRE _A_DFI

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_rfTxSFifoFillLevelReached_ISR_C, "interrupt"
ATA_rfTxSFifoFillLevelReached_ISR_C:
          CFI Block cfiBlock37 Using cfiCommon1
          CFI Function ATA_rfTxSFifoFillLevelReached_ISR_C
          CFI NoCalls
        ST      -Y, R31
          CFI R31 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R30
          CFI R30 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        IN      R17, 0x3F
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxSFifoFillLevelReached_ISR_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxSFifoFillLevelReached_ISR_C/2) >> 8
        STS     _A_TRCIDH, R16
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x02
        RJMP    ?Subroutine7
          CFI EndBlock cfiBlock37
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_rfTxSFifoError_ISR_C, "interrupt"
ATA_rfTxSFifoError_ISR_C:
          CFI Block cfiBlock38 Using cfiCommon1
          CFI Function ATA_rfTxSFifoError_ISR_C
          CFI NoCalls
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        IN      R17, 0x3F
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxSFifoError_ISR_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxSFifoError_ISR_C/2) >> 8
        STS     _A_TRCIDH, R16
        LDS     R16, 224
        ANDI    R16, 0xFD
        STS     224, R16
        LDS     R16, g_sRfTx
        ORI     R16, 0x88
        STS     g_sRfTx, R16
        LDI     R16, 37
          CFI EndBlock cfiBlock38
        REQUIRE ?Subroutine6
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SFI
        ;               // Fall through to label ?Subroutine6

        RSEG CODE:CODE:NOROOT(1)
?Subroutine6:
          CFI Block cfiBlock39 Using cfiCommon1
          CFI NoFunction
          CFI CFA_Y Y+2
          CFI R16 Frame(CFA_Y, -2)
          CFI R17 Frame(CFA_Y, -1)
        STS     g_sDebug, R16
        LDI     R16, 0
        STS     (g_sDebug + 1), R16
        OUT     0x3F, R17
        LD      R16, Y+
          CFI CFA_Y Y+1
          CFI R16 SameValue
        LD      R17, Y+
          CFI CFA_Y Y+0
          CFI R17 SameValue
        RETI
          CFI EndBlock cfiBlock39

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_rfTxDFifoFillLevelReached_ISR_C, "interrupt"
ATA_rfTxDFifoFillLevelReached_ISR_C:
          CFI Block cfiBlock40 Using cfiCommon1
          CFI Function ATA_rfTxDFifoFillLevelReached_ISR_C
          CFI NoCalls
        ST      -Y, R31
          CFI R31 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R30
          CFI R30 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        IN      R17, 0x3F
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxDFifoFillLevelReached_ISR_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxDFifoFillLevelReached_ISR_C/2) >> 8
        STS     _A_TRCIDH, R16
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LD      R16, Z
        ORI     R16, 0x04
        RJMP    ?Subroutine7
          CFI EndBlock cfiBlock40
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_rfTxDFifoError_ISR_C, "interrupt"
ATA_rfTxDFifoError_ISR_C:
          CFI Block cfiBlock41 Using cfiCommon1
          CFI Function ATA_rfTxDFifoError_ISR_C
          CFI NoCalls
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        IN      R17, 0x3F
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxDFifoError_ISR_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxDFifoError_ISR_C/2) >> 8
        STS     _A_TRCIDH, R16
        LDS     R16, 217
        ANDI    R16, 0xFD
        STS     217, R16
        LDS     R16, g_sRfTx
        ORI     R16, 0x90
        STS     g_sRfTx, R16
        LDI     R16, 38
        RJMP    ?Subroutine6
          CFI EndBlock cfiBlock41
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_DFI

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_rfTxSsmRdy_ISR_C, "interrupt"
ATA_rfTxSsmRdy_ISR_C:
          CFI Block cfiBlock42 Using cfiCommon1
          CFI Function ATA_rfTxSsmRdy_ISR_C
          CFI NoCalls
        ST      -Y, R31
          CFI R31 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R30
          CFI R30 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        IN      R17, 0x3F
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxSsmRdy_ISR_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxSsmRdy_ISR_C/2) >> 8
        STS     _A_TRCIDH, R16
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ORI     R16, 0x40
        STD     Z+2, R16
        RJMP    ??Subroutine9_0
          CFI EndBlock cfiBlock42
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_rfTxModulatorTelegramFinish_ISR_C, "interrupt"
ATA_rfTxModulatorTelegramFinish_ISR_C:
          CFI Block cfiBlock43 Using cfiCommon1
          CFI Function ATA_rfTxModulatorTelegramFinish_ISR_C
          CFI NoCalls
        ST      -Y, R31
          CFI R31 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R30
          CFI R30 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        IN      R17, 0x3F
        LDI     R16, 0
        STS     _A_TRCDR, R16
        LDI     R16, LOW(ATA_rfTxModulatorTelegramFinish_ISR_C/2)
        STS     _A_TRCIDL, R16
        LDI     R16, (ATA_rfTxModulatorTelegramFinish_ISR_C/2) >> 8
        STS     _A_TRCIDH, R16
        LDI     R16, 2
        STS     _A_SSMRR, R16
        LDI     R30, LOW(g_sRfTx)
        LDI     R31, (g_sRfTx) >> 8
        LDD     R16, Z+2
        ORI     R16, 0x20
        STD     Z+2, R16
        LD      R16, Z
        ORI     R16, 0x01
          CFI EndBlock cfiBlock43
        REQUIRE ?Subroutine7
        REQUIRE _A_TRCDR
        REQUIRE _A_TRCIDL
        REQUIRE _A_TRCIDH
        REQUIRE _A_SSMRR
        ;               // Fall through to label ?Subroutine7

        RSEG CODE:CODE:NOROOT(1)
?Subroutine7:
          CFI Block cfiBlock44 Using cfiCommon1
          CFI NoFunction
          CFI CFA_Y Y+4
          CFI R16 Frame(CFA_Y, -4)
          CFI R17 Frame(CFA_Y, -3)
          CFI R30 Frame(CFA_Y, -2)
          CFI R31 Frame(CFA_Y, -1)
        ST      Z, R16
          CFI EndBlock cfiBlock44
        REQUIRE ??Subroutine9_0
        ;               // Fall through to label ??Subroutine9_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine9_0:
          CFI Block cfiBlock45 Using cfiCommon1
          CFI NoFunction
          CFI CFA_Y Y+4
          CFI R16 Frame(CFA_Y, -4)
          CFI R17 Frame(CFA_Y, -3)
          CFI R30 Frame(CFA_Y, -2)
          CFI R31 Frame(CFA_Y, -1)
        OUT     0x3F, R17
        LD      R16, Y+
          CFI CFA_Y Y+3
          CFI R16 SameValue
        LD      R17, Y+
          CFI CFA_Y Y+2
          CFI R17 SameValue
        LD      R30, Y+
          CFI CFA_Y Y+1
          CFI R30 SameValue
        LD      R31, Y+
          CFI CFA_Y Y+0
          CFI R31 SameValue
        RETI
          CFI EndBlock cfiBlock45

        RSEG CODE:CODE:ROOT(1)
ATA_rfTxStartSsmWatchdog_C:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function ATA_rfTxStartSsmWatchdog_C
        SBIW    R29:R28, 8
          CFI CFA_Y Y+8
// 2508         BM_T2ENA,                   /* T2CR */
// 2509         0x00U,                      /* T2MR */
// 2510         0xFFU,                      /* T2COR */
// 2511         0x00U,                      /* T2IMR */
// 2512         (timerIRQHandler)0x0000,    /* g_sTimer2.ovfIsr */
// 2513         (timerIRQHandler)0x0000     /* g_sTimer2.compIsr */
// 2514         };
        LDI     R30, LOW(`?<Constant {128, 0, 255, 0, (void (*)(void))0,`)
        LDI     R31, (`?<Constant {128, 0, 255, 0, (void (*)(void))0,`) >> 8
        MOVW    R17:R16, R29:R28
        LDI     R20, 8
        LDI     R21, 0
          CFI FunCall ?ML_FLASH_SRAM_16EC_16_L07
        CALL    ?ML_FLASH_SRAM_16EC_16_L07
// 2515 
// 2516     /* LLR-Ref: 010 */
// 2517     return ATA_timer2Open_C(&sTimer2Params);
          CFI FunCall ATA_timer2Open_C
        CALL    ATA_timer2Open_C
        ADIW    R29:R28, 8
          CFI CFA_Y Y+0
        RET
// 2518 }
          CFI EndBlock cfiBlock46

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
// 2519 
// 2520 /*----------------------------------------------------------------------------- */
// 2521 /** \brief <b>ATA_rfTxStopSsmWatchdog_C</b>
// 2522     stops the sequencer state machine watchdog.
// 2523 
// 2524     \image html ATA_rfTxStopSsmWatchdog_C.png
// 2525 
// 2526     \internal
// 2527     \li 010: Close Timer 2 by calling function ::ATA_timer2Close_C in order to
// 2528              stop the SSM watchdog timer.
// 2529 
// 2530     \Derived{No}
// 2531 
// 2532     \Rationale{N/A}
// 2533 
// 2534     \Traceability{Primus2P-869,Primus2P-849,Primus2P-848,Primus2P-847,Primus2P-868}
// 2535     \endinternal
// 2536 \n
// 2537 */
// 2538 /*----------------------------------------------------------------------------- */
// 2539 VOIDFUNC ATA_rfTxStopSsmWatchdog_C(void)
// 2540 {
// 2541     /* LLR-Ref: 010 */
// 2542     ATA_timer2Close_C();
// 2543 }
// 
//     7 bytes in segment .flowctrl
//    40 bytes in segment .rftx
//    72 bytes in segment ABSOLUTE
// 2 972 bytes in segment CODE
//    44 bytes in segment NEAR_F
// 
// 3 016 bytes of CODE memory
//    47 bytes of DATA memory (+ 72 bytes shared)
//
//Errors: none
//Warnings: none
