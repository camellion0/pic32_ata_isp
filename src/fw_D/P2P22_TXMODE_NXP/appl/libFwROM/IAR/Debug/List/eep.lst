###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            05/Apr/2016  13:30:40
# Copyright 1996-2015 IAR Systems AB.
# Network license: DVRIAR01.corpp.atmel.com (STD)
#
#    Source file  =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\eep\src\eep.c
#    Command line =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\eep\src\eep.c
#        -v3 --enhanced_core -ms -o
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\Obj
#        -lC
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List
#        -lA
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug --64k_flash
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 6.0\avr\inc\" --eeprom_size 1152 --clib
#        -Ohz
#    List file    =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List\eep.lst
#    Object file  =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\Obj\eep.r90
#
###############################################################################

C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\eep\src\eep.c
      1          //lint -e9059
      2          /* *C**************************************************************************
      3            Use of this software is subject to Atmel's Software License Agreement.
      4          -------------------------------------------------------------------------------
      5            $URL: http://svnservulm.corp.atmel.com/svn/CDB/Apps/SW_Lib/Car_Access/CARS_GEN2/ATAB5702A/Branches/P2_Gen2_Merge/firmware/eep/src/eep.c $
      6            $LastChangedRevision: 334472 $
      7            $LastChangedDate: 2015-08-25 12:50:16 -0600 (Tue, 25 Aug 2015) $
      8            $LastChangedBy: grueter $
      9          -------------------------------------------------------------------------------
     10            Project:      ATA5700
     11            Target MCU:   ATA5700
     12            Compiler:     IAR C/C++ Compiler for AVR 6.30.1
     13          -------------------------------------------------------------------------------
     14          
     15          ******************************************************************************
     16          * Copyright 2011, Atmel Automotive GmbH                                       *
     17          *                                                                             *
     18          * This software is owned by the Atmel Automotive GmbH                         *
     19          * and is protected by and subject to worldwide patent protection.             *
     20          * Atmel hereby grants to licensee a personal,                                 *
     21          * non-exclusive, non-transferable license to copy, use, modify, create        *
     22          * derivative works of, and compile the Atmel Source Code and derivative       *
     23          * works for the sole purpose of creating custom software in support of        *
     24          * licensee product to be used only in conjunction with a Atmel integrated     *
     25          * circuit as specified in the applicable agreement. Any reproduction,         *
     26          * modification, translation, compilation, or representation of this           *
     27          * software except as specified above is prohibited without the express        *
     28          * written permission of Atmel.                                                *
     29          *                                                                             *
     30          * Disclaimer: ATMEL MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,         *
     31          * WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
     32          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
     33          * Atmel reserves the right to make changes without further notice to the      *
     34          * materials described herein. Atmel does not assume any liability arising     *
     35          * out of the application or use of any product or circuit described herein.   *
     36          * Atmel does not authorize its products for use as critical components in     *
     37          * life-support systems where a malfunction or failure may reasonably be       *
     38          * expected to result in significant injury to the user. The inclusion of      *
     39          * Atmel products in a life-support systems application implies that the       *
     40          * manufacturer assumes all risk of such use and in doing so indemnifies       *
     41          * Atmel against all charges.                                                  *
     42          *                                                                             *
     43          * Use may be limited by and subject to the applicable Atmel software          *
     44          * license agreement.                                                          *
     45          ******************************************************************************/
     46          /** \file firmware/eep/src/eep.c
     47          */
     48          //lint -restore
     49          
     50          /*---------------------------------------------------------------------------*/
     51          /** \brief <b>Module EEP</b>
     52              This modules provides basic EEProm access functions as well as access to 
     53              the FLASH based fuse bytes (Low, High and Fix). Since the fuse write access
     54              is FLASH based, the FLASH write times do apply and not the EEProm write 
     55              times. However, the error handling regarding the fuse functions is 
     56              implemented with EEProm error codes.
     57              The definition of the EEPromlayout for the Atmel EEProm section, and the 
     58              Customer EEProm section is also contained within this module.
     59          
     60          \internal
     61          \Traceability{Primus2P-3143, Primus2P-3144, Primus2P-3146, Primus2P-3147,\
     62                        Primus2P-3150, Primus2P-3151, Primus2P-3153, Primus2P-3154,\
     63                        Primus2P-3159, Primus2P-3162, Primus2P-3165, Primus2P-3184,\
     64                        Primus2P-3185, Primus2P-3187}
     65          \endinternal
     66          \n
     67          */
     68          /*---------------------------------------------------------------------------*/
     69          
     70          /*===========================================================================*/
     71          /*  INCLUDES                                                                 */
     72          /*===========================================================================*/
     73          #include "eep.h"

   \                                 In  segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_EECR2
   \                     _A_EECR2:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEARL
   \                     _A_EEARL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x42
   \   union <unnamed> volatile __io _A_EEARH
   \                     _A_EEARH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x43
   \   union <unnamed> volatile __io _A_EEPR0
   \                     _A_EEPR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x57
   \   union <unnamed> volatile __io _A_SPMCSR
   \                     _A_SPMCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xfc
   \   union <unnamed> volatile __io _A_TRCIDL
   \                     _A_TRCIDL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xfd
   \   union <unnamed> volatile __io _A_TRCIDH
   \                     _A_TRCIDH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xff
   \   union <unnamed> volatile __io _A_TRCDR
   \                     _A_TRCDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x13b
   \   union <unnamed> volatile __ext_io _A_EEPR1
   \                     _A_EEPR1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x13c
   \   union <unnamed> volatile __ext_io _A_EEPR2
   \                     _A_EEPR2:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x13d
   \   union <unnamed> volatile __ext_io _A_EEPR3
   \                     _A_EEPR3:
   \   00000000                      DS8 1
     74          
     75          /*===========================================================================*/
     76          /*  DEFINES                                                                  */
     77          /*===========================================================================*/
     78          
     79          /** \brief <b>ADDR_OF_R16</b>
     80              defines the memory address of register R16 (used as first parameter 
     81              within a function call by the IAR compiler)
     82          */
     83          #define MEM_ADDR_R16        0x10U
     84          
     85          /*===========================================================================*/
     86          /*  Modul Globals                                                            */
     87          /*===========================================================================*/
     88          //lint -esym(9003, g_sAtmelEEPromSection) FlSc (26.05.2014)
     89          /* disable lint note 9003 - could define variable 'g_sAtmelEEPromSection' at block scope
     90           * variable shall be accessed from outside via flash software or other library
     91           * modules
     92           */
     93          /** \brief <b>sAtmelEEPromSection</b>
     94              contains the Atmel specific EEProm section.
     95          */
     96          #pragma location = ".eep_sAtmelEEPromSection"

   \                                 In  segment .eep_sAtmelEEPromSection, align 1, keep-with-next, root
     97          __root __no_init sAtmelEEPromSection g_sAtmelEEPromSection;
   \                     g_sAtmelEEPromSection:
   \   00000000                      DS8 256
     98          
     99          //lint -esym(9003, g_sCustomerEEPromSection) FlSc (26.05.2014)
    100          /* disable lint note 9003 - could define variable 'g_sCustomerEEPromSection' at block scope
    101           * variable shall be accessed from outside via flash software or other library
    102           * modules
    103           */
    104          /** \brief <b>sCustomerEEPromSection</b>
    105              contains the Customer specific EEProm section.
    106          */
    107          #pragma location = ".eep_sCustomerEEPromSection"

   \                                 In  segment .eep_sCustomerEEPromSection, align 1, keep-with-next, root
    108          __root __no_init sCustomerEEPromSection g_sCustomerEEPromSection;
   \                     g_sCustomerEEPromSection:
   \   00000000                      DS8 128
    109          
    110          //#pragma location = ".eep_sCustomerEEPromSectionAESkey"
    111          //__root __no_init sEepFlashApp_AESKey g_sEepFlashApp_AESKey;
    112          
    113          /*===========================================================================*/
    114          /*  IMPLEMENTATION                                                           */
    115          /*===========================================================================*/
    116          /*---------------------------------------------------------------------------*/
    117          /** \brief <b>ATA_eepFuseRead_C</b>
    118              This function is used to read out one of the three fuse bytes handling
    119              the access rights control to the generic EEProm sections.
    120          
    121              \param[in]  bCtrl Value to control, which of the three available fuse bytes will be read
    122              \return     Value of the read fuse byte (::uint8_t)
    123              
    124              Technical background:
    125              16 Bit are used to control all the available 8 generic EEProm section
    126              This results in two bytes. The third byte is used to monitor the Fuse
    127              Fix setting. Which byte is read depends on the input parameter.
    128          
    129              \internal
    130              \li 001: Store SREG state to be able to restore it at the end of the function 
    131                        call
    132              \li 005: Update HW Trace Unit with specific function information
    133              \li 008: Wait for the EEProm to be able to respond to the Fuse read request.
    134              \li 010: Disable interrupts via global interrupt flag in SREG
    135              \li 020: Check which fuse byte is desired and setup SPMCSR according to this.
    136                       The SPMCSR bits to ctrl the LPM instruction are reset with the following LPM.
    137              \li 030: Trigger the LPM instruction.
    138              \li 040: Restore SREG to state before function call
    139              \li 050: Return the read fuse byte value
    140          
    141              \Derived{No}
    142          
    143              \Rationale{N/A}
    144          
    145              \Traceability{Primus2P-3150}
    146              \endinternal
    147          \n
    148          */
    149          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    150          __root uint8_t ATA_eepFuseRead_C(uint8_t bCtrl)
   \                     ATA_eepFuseRead_C:
    151          /*---------------------------------------------------------------------------*/
    152          {
    153              /* LLR-Ref: 001 */
    154              uint8_t bSreg = SREG;  
   \   00000000   B71F               IN      R17, 0x3F
    155            
    156              uint8_t bFuseVal;
    157              uint8_t *regPtr;
    158          
    159              /* LLR-Ref: 005 */
    160              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepFuseRead_C, bCtrl);
   \   00000002   B74F               IN      R20, 0x3F
   \   00000004   94F8               CLI
   \   00000006   9300....           STS     _A_TRCDR, R16
   \   0000000A   ....               LDI     R18, LOW(ATA_eepFuseRead_C/2)
   \   0000000C   9320....           STS     _A_TRCIDL, R18
   \   00000010   ....               LDI     R18, (ATA_eepFuseRead_C/2) >> 8
   \   00000012   9320....           STS     _A_TRCIDH, R18
   \   00000016   BF4F               OUT     0x3F, R20
    161          
    162              /* LLR-Ref: 008 */
    163              while(EECR&(BITMASK(NVMBSY)));
   \                     ??ATA_eepFuseRead_C_0:
   \   00000018   99FF               SBIC    0x1F, 0x07
   \   0000001A   CFFE               RJMP    ??ATA_eepFuseRead_C_0
    164              
    165              /* LLR-Ref: 010 */
    166              __disable_interrupt();
   \   0000001C   94F8               CLI
    167          
    168              /* Dummy write, as the inline ASM will overwrite this! 
    169                 Just needed to supress a warning */
    170              regPtr = (unsigned char *)MEM_ADDR_R16;
    171              
    172              /* LLR-Ref: 020 */                
    173              if(bCtrl==FUSE_EP_L){
   \   0000001E   2300               TST     R16
   \   00000020   F411               BRNE    ??ATA_eepFuseRead_C_1
    174                  SPMCSR = BM_GET_FUSE_EP_L;
   \   00000022   E209               LDI     R16, 41
   \   00000024   C005               RJMP    ??ATA_eepFuseRead_C_2
    175              }
    176              else if(bCtrl==FUSE_EP_H){
   \                     ??ATA_eepFuseRead_C_1:
   \   00000026   3001               CPI     R16, 1
   \   00000028   F411               BRNE    ??ATA_eepFuseRead_C_3
    177                  SPMCSR = BM_GET_FUSE_EP_H;
   \   0000002A   E309               LDI     R16, 57
   \   0000002C   C001               RJMP    ??ATA_eepFuseRead_C_2
    178              }
    179              else{
    180                  SPMCSR = BM_GET_FUSE_SECF;
   \                     ??ATA_eepFuseRead_C_3:
   \   0000002E   E109               LDI     R16, 25
   \                     ??ATA_eepFuseRead_C_2:
   \   00000030   BF07               OUT     0x37, R16
    181              }
    182              
    183              /* LLR-Ref: 030 */
    184              __asm ("LPM");
   \   00000032   95C8               LPM
    185              __asm ("MOV R16 , R0");
   \   00000034   2D00               MOV R16 , R0
    186              //bFuseVal = __load_program_memory((const unsigned char __flash *)0x0000U);
    187              
    188              /* LLR-Ref: 040 */
    189              SREG = bSreg;
   \   00000036   BF1F               OUT     0x3F, R17
    190              
    191              /* LLR-Ref: 050 */
    192              bFuseVal = *regPtr;//needed to supress a compiler warning
    193          
    194              return bFuseVal;
   \   00000038   91000010           LDS     R16, 16
   \   0000003C   9508               RET
   \   0000003E                      REQUIRE _A_SREG
   \   0000003E                      REQUIRE _A_TRCDR
   \   0000003E                      REQUIRE _A_TRCIDL
   \   0000003E                      REQUIRE _A_TRCIDH
   \   0000003E                      REQUIRE _A_EECR
   \   0000003E                      REQUIRE _A_SPMCSR
    195          }
    196          /*---------------------------------------------------------------------------*/
    197          /** \brief <b>ATA_eepFuseWrite_C</b>
    198              This function is used to write one of the two fuse bytes handling
    199              the access rights control to the generic EEProm sections.
    200          
    201              \param[in]  bCtrl             Value to control, which of the three available fuse bytes will be read
    202              \param[in]  bVal              Value to be written to the selected fuse byte
    203              \return     Status of the performed EEPROM operation (::eEepErrorCode)
    204          
    205              \internal
    206              \li 001: Store SREG state to be able to restore it at the end of the function 
    207                       call
    208              \li 010: Wait for the EEProm to be able responding to the Fuse write request.
    209              \li 020: Disable interrupts via global interrupt flag in SREG
    210              \li 025: Reset watchdog
    211              \li 030: Prepare data to be written via SPM, R17 contains the second passed
    212                       parameter (IAR calling convention), this value is written to R0, the
    213                       register used by the SPM instruction
    214              \li 040: Update HW Trace Unit with specific function information         
    215                       Not to be placed at the start cause of the inline assembly!
    216              \li 050: Setup SPMCSR according to the fuse byte intended to be written
    217              \li 060: Enable the Fuse byte write by setting the enable bit and execute the
    218                       write via the SPM instruction
    219              \li 070: Restore SREG to state before function call.
    220              \li 080: Check written fuse with the desired value and return the status of the
    221                       comparison
    222          
    223              \Derived{No}
    224          
    225              \Rationale{N/A}
    226          
    227              \Traceability{Primus2P-3150}
    228              \endinternal
    229          \n
    230          */
    231          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    232          __root eEepErrorCode ATA_eepFuseWrite_C(uint8_t bCtrl, uint8_t bVal)
   \                     ATA_eepFuseWrite_C:
    233          /*---------------------------------------------------------------------------*/
    234          {
   \   00000000   2F51               MOV     R21, R17
    235              /* LLR-Ref: 001 */
    236              uint8_t bSreg = SREG;
   \   00000002   B74F               IN      R20, 0x3F
    237              
    238              uint8_t bFuseVal;
    239              eEepErrorCode tmp;
    240          
    241              /* LLR-Ref: 010 */
    242              while(EECR&(BITMASK(NVMBSY)));
   \                     ??ATA_eepFuseWrite_C_0:
   \   00000004   99FF               SBIC    0x1F, 0x07
   \   00000006   CFFE               RJMP    ??ATA_eepFuseWrite_C_0
    243          
    244              /* LLR-Ref: 020 */
    245              __disable_interrupt();
   \   00000008   94F8               CLI
    246              
    247              /* LLR-Ref: 025 */
    248              __watchdog_reset();
   \   0000000A   95A8               WDR
    249                  
    250              /* LLR-Ref: 030 */
    251              __asm ("MOV R0 , R17");
   \   0000000C   2E01               MOV R0 , R17
    252              
    253              /* LLR-Ref: 040 */
    254              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepFuseWrite_C, bCtrl); //DO not move this line to any other location
   \   0000000E   B71F               IN      R17, 0x3F
   \   00000010   94F8               CLI
   \   00000012   9300....           STS     _A_TRCDR, R16
   \   00000016   ....               LDI     R18, LOW(ATA_eepFuseWrite_C/2)
   \   00000018   9320....           STS     _A_TRCIDL, R18
   \   0000001C   ....               LDI     R18, (ATA_eepFuseWrite_C/2) >> 8
   \   0000001E   9320....           STS     _A_TRCIDH, R18
   \   00000022   BF1F               OUT     0x3F, R17
    255              
    256              /* LLR-Ref: 050 */
    257              if(bCtrl==FUSE_EP_L){
   \   00000024   2300               TST     R16
   \   00000026   F411               BRNE    ??ATA_eepFuseWrite_C_1
    258                  SPMCSR = BM_GET_FUSE_EP_L;
   \   00000028   E219               LDI     R17, 41
   \   0000002A   C005               RJMP    ??ATA_eepFuseWrite_C_2
    259              }
    260              else if(bCtrl==FUSE_EP_H){
   \                     ??ATA_eepFuseWrite_C_1:
   \   0000002C   3001               CPI     R16, 1
   \   0000002E   F411               BRNE    ??ATA_eepFuseWrite_C_3
    261                  SPMCSR = BM_GET_FUSE_EP_H;
   \   00000030   E319               LDI     R17, 57
   \   00000032   C001               RJMP    ??ATA_eepFuseWrite_C_2
    262              }
    263              else{
    264                  SPMCSR = BM_GET_FUSE_SECF;
   \                     ??ATA_eepFuseWrite_C_3:
   \   00000034   E119               LDI     R17, 25
   \                     ??ATA_eepFuseWrite_C_2:
   \   00000036   BF17               OUT     0x37, R17
    265              }
    266              /* LLR-Ref: 060 */
    267              __asm ("SPM");
   \   00000038   95E8               SPM
    268              
    269              /* LLR-Ref: 070 */
    270              SREG = bSreg;
   \   0000003A   BF4F               OUT     0x3F, R20
    271              
    272              /* LLR-Ref: 080 */
    273              bFuseVal = ATA_eepFuseRead_C(bCtrl);
    274              if(bVal != bFuseVal){
   \   0000003C   ....               RCALL   ATA_eepFuseRead_C
   \   0000003E   1750               CP      R21, R16
   \   00000040   F011               BREQ    ??ATA_eepFuseWrite_C_4
    275                  tmp = EEC_ACCESS_FUSE_WR_FAIL;
   \   00000042   E005               LDI     R16, 5
   \   00000044   9508               RET
    276              }
    277              else {
    278                  tmp = EEC_NO_ERROR;
   \                     ??ATA_eepFuseWrite_C_4:
   \   00000046                      REQUIRE ?Subroutine0
   \   00000046                      REQUIRE _A_SREG
   \   00000046                      REQUIRE _A_EECR
   \   00000046                      REQUIRE _A_TRCDR
   \   00000046                      REQUIRE _A_TRCIDL
   \   00000046                      REQUIRE _A_TRCIDH
   \   00000046                      REQUIRE _A_SPMCSR
   \   00000046                      ;               // Fall through to label ?Subroutine0
    279              }
    280          	return tmp;
    281          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   E000               LDI     R16, 0
   \   00000002   9508               RET
    282          /*---------------------------------------------------------------------------*/
    283          /** \brief <b>ATA_eepEEPaccessRightsChange_C</b>
    284              This function is used to adjust the access rights settings of the EEProm.
    285              The fuses as well as the mask register will be manipulated according to the
    286              given values.
    287          
    288              \param[in]  bSectionID          EEPROM section ID for which the access rights 
    289                                              shall be changed
    290              \param[in]  bVal                Bit1..0: New access right value for the given 
    291                                              EEProm section (Bit 0 for WRITE, Bit 1 for READ)
    292                                               - Bit value "1" for an access right means 
    293                                                 "unlock"
    294                                               - Bit value "0" for an access right means 
    295                                                 "lock"
    296                                              Bit7: Indication for fuse or register
    297          
    298              \return     Status of the performed EEPROM operation (::eEepErrorCode)
    299          
    300              \internal
    301              \li 005: Update HW Trace Unit with specific function information
    302              \li 010: Check for Fuse settings to be adjusted
    303              \li 020: Fuse high byte adjustment
    304              \li 030: Fuse low byte adjustment
    305              \li 040: Return Error in case Section is not valid to be protected via the Fuses
    306              \li 050: Adjust access rights via register
    307              \li 060: Calculate mask and pattern to adjuste the needed EEPR<X> Register
    308          
    309              \Derived{No}
    310          
    311              \Rationale{N/A}
    312          
    313              \Traceability{Primus2P-3150, Primus2P-3153, Primus2P-3187}
    314              \endinternal
    315          \n
    316          */
    317          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    318          __root eEepErrorCode ATA_eepEEPaccessRightsChange_C(uint8_t bSectionID, uint8_t bVal)
   \                     ATA_eepEEPaccessRightsChange_C:
    319          /*---------------------------------------------------------------------------*/
    320          {
   \   00000000   2F60               MOV     R22, R16
    321              uint8_t tmp;
    322              uint8_t mask;
    323          
    324              /* LLR-Ref: 005 */
    325              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepEEPaccessRightsChange_C, bSectionID);
   \   00000002   B72F               IN      R18, 0x3F
   \   00000004   94F8               CLI
   \   00000006   9300....           STS     _A_TRCDR, R16
   \   0000000A   ....               LDI     R16, LOW(ATA_eepEEPaccessRightsChange_C/2)
   \   0000000C   9300....           STS     _A_TRCIDL, R16
   \   00000010   ....               LDI     R16, (ATA_eepEEPaccessRightsChange_C/2) >> 8
   \   00000012   9300....           STS     _A_TRCIDH, R16
   \   00000016   BF2F               OUT     0x3F, R18
    326          
    327              /* LLR-Ref: 010 */
    328              if(bVal&EEP_ACC_FUSE)
   \   00000018   FB17               BST     R17, 7
   \   0000001A   F5A6               BRTC    ??ATA_eepEEPaccessRightsChange_C_0
    329              {   
    330                  /* Change access rights via fuses */
    331              	bVal &= ~EEP_ACC_FUSE;
   \   0000001C   771F               ANDI    R17, 0x7F
   \   0000001E   2F31               MOV     R19, R17
    332                  tmp = bSectionID - EEP_FIRST_SECTION_FUSE_ID;
   \   00000020   2F26               MOV     R18, R22
   \   00000022   5025               SUBI    R18, 5
    333              	bSectionID = bSectionID - EEP_FIRST_SECTION_FUSE_ID;
   \   00000024   5065               SUBI    R22, 5
    334                  
    335                  /* In order to handle both FUSE_EP_L and FUSE_EP_H, the mask and value
    336                     byte need to be adjusted for FUSE_EP_H in order to take effect. */
    337              	if ((bSectionID&EEP_SECTION_ID_MASK) > (EEP_NUM_SECTION_PER_FUSE_REG_BYTE - 1))
   \   00000026   2FE6               MOV     R30, R22
   \   00000028   E0F0               LDI     R31, 0
   \   0000002A   70EF               ANDI    R30, 0x0F
   \   0000002C   9734               SBIW    R31:R30, 4
   \   0000002E   F008               BRCS    ??ATA_eepEEPaccessRightsChange_C_1
    338                  {
    339                      tmp = tmp - EEP_NUM_SECTION_PER_FUSE_REG_BYTE;
   \   00000030   5024               SUBI    R18, 4
    340                  }
    341                  
    342                  /* Mask out the two bits intended to be changed */
    343                  mask = (EEP_ACCESS_RIGHT_MASK <<(tmp<<1U));
   \                     ??ATA_eepEEPaccessRightsChange_C_1:
   \   00000032   2F42               MOV     R20, R18
   \   00000034   0F44               LSL     R20
   \   00000036   E003               LDI     R16, 3
   \   00000038   E010               LDI     R17, 0
   \   0000003A   ........           CALL    ?S_SHL_L02
   \   0000003E   2F50               MOV     R21, R16
    344                  bVal = (bVal <<(tmp<<1U));
   \   00000040   2F03               MOV     R16, R19
   \   00000042   E010               LDI     R17, 0
   \   00000044   0F22               LSL     R18
   \   00000046   2F42               MOV     R20, R18
   \   00000048   ........           CALL    ?S_SHL_L02
   \   0000004C   2F30               MOV     R19, R16
    345                      
    346              	/* LLR-Ref: 020 */
    347              	if((bSectionID&EEP_SECTION_ID_MASK)<EEP_NUM_SECTION_PER_FUSE_REG_BYTE)
   \   0000004E   2FE6               MOV     R30, R22
   \   00000050   E0F0               LDI     R31, 0
   \   00000052   70EF               ANDI    R30, 0x0F
   \   00000054   9734               SBIW    R31:R30, 4
   \   00000056   F440               BRCC    ??ATA_eepEEPaccessRightsChange_C_2
    348                  {
    349                      tmp = ATA_eepFuseRead_C(FUSE_EP_L);
   \   00000058   E000               LDI     R16, 0
   \   0000005A   ....               RCALL   ATA_eepFuseRead_C
    350                      tmp &= ~mask;
    351                      tmp |= bVal;
    352                      return ATA_eepFuseWrite_C(FUSE_EP_L,tmp);
   \   0000005C   9550               COM     R21
   \   0000005E   2305               AND     R16, R21
   \   00000060   2B03               OR      R16, R19
   \   00000062   2F10               MOV     R17, R16
   \   00000064   E000               LDI     R16, 0
   \   00000066   C00D               RJMP    ??ATA_eepEEPaccessRightsChange_C_3
    353                  }
    354                  /* LLR-Ref: 030 */
    355                  else if((bSectionID&EEP_SECTION_ID_MASK)<(2U*EEP_NUM_SECTION_PER_FUSE_REG_BYTE))
   \                     ??ATA_eepEEPaccessRightsChange_C_2:
   \   00000068   E0F0               LDI     R31, 0
   \   0000006A   706F               ANDI    R22, 0x0F
   \   0000006C   2FE6               MOV     R30, R22
   \   0000006E   9738               SBIW    R31:R30, 8
   \   00000070   F008               BRCS    $+2+2
   \   00000072   C040               RJMP    ??ATA_eepEEPaccessRightsChange_C_4
    356                  {
    357                      tmp = ATA_eepFuseRead_C(FUSE_EP_H);
   \   00000074   E001               LDI     R16, 1
   \   00000076   ....               RCALL   ATA_eepFuseRead_C
    358                      tmp &= ~mask;
    359                      tmp |= bVal;
    360                      return ATA_eepFuseWrite_C(FUSE_EP_H,tmp);
   \   00000078   9550               COM     R21
   \   0000007A   2305               AND     R16, R21
   \   0000007C   2B03               OR      R16, R19
   \   0000007E   2F10               MOV     R17, R16
   \   00000080   E001               LDI     R16, 1
    361                  }
    362                  /* LLR-Ref: 040 */
    363                  else
    364                  {
    365                      return EEC_SECTION_INVALID;
    366                  }
    367              }
   \                     ??ATA_eepEEPaccessRightsChange_C_3:
   \   00000082   ....               RJMP    ?Subroutine2
    368              /* LLR-Ref: 050 */
    369              else
    370              {
    371                  /* LLR-Ref: 060 */
    372                  tmp = (bSectionID>>2U);
   \                     ??ATA_eepEEPaccessRightsChange_C_0:
   \   00000084   2F26               MOV     R18, R22
   \   00000086   9526               LSR     R18
   \   00000088   9526               LSR     R18
    373                  bSectionID &= EEP_ACCESS_RIGHT_MASK;
   \   0000008A   7063               ANDI    R22, 0x03
    374                  
    375                  /* Mask out the two bits intended to be changed */
    376                  mask = (EEP_ACCESS_RIGHT_MASK <<(bSectionID<<1U));
   \   0000008C   2F46               MOV     R20, R22
   \   0000008E   0F44               LSL     R20
   \   00000090   E003               LDI     R16, 3
   \   00000092   ........           CALL    ?C_SHL_L01
   \   00000096   2F50               MOV     R21, R16
    377                  
    378                  /* Invert the section access rights settings */
    379                  bVal = (bVal^EEP_ACCESS_RIGHT_INVERT_MASK)&EEP_ACCESS_RIGHT_MASK;
    380                  bVal = (bVal <<(bSectionID<<1U));
   \   00000098   9510               COM     R17
   \   0000009A   7013               ANDI    R17, 0x03
   \   0000009C   2F01               MOV     R16, R17
   \   0000009E   0F66               LSL     R22
   \   000000A0   2F46               MOV     R20, R22
   \   000000A2   ........           CALL    ?C_SHL_L01
   \   000000A6   2F30               MOV     R19, R16
    381                  
    382                  /* Check which EEPRx register is to be updated with the given access
    383                     rights */
    384                  if(tmp == EEP_SECTION_ID_IN_EEPR0){
   \   000000A8   2322               TST     R18
   \   000000AA   F431               BRNE    ??ATA_eepEEPaccessRightsChange_C_5
    385                      tmp = EEPR0;
    386                      tmp &= ~mask;
    387                      tmp |= bVal;
    388                      EEPR0 = tmp;
   \   000000AC   B503               IN      R16, 0x23
   \   000000AE   9550               COM     R21
   \   000000B0   2305               AND     R16, R21
   \   000000B2   2B03               OR      R16, R19
   \   000000B4   BD03               OUT     0x23, R16
    389                  }
    390                  else if(tmp == EEP_SECTION_ID_IN_EEPR1){
    391                      tmp = EEPR1;
    392                      tmp &= ~mask;
    393                      tmp |= bVal;
    394                      EEPR1 = tmp;
    395                  }
    396                  else if(tmp == EEP_SECTION_ID_IN_EEPR2){
    397                      tmp = EEPR2;
    398                      tmp &= ~mask;
    399                      tmp |= bVal;
    400                      EEPR2 = tmp;
    401                  }
    402                  else if(tmp == EEP_SECTION_ID_IN_EEPR3){
    403                      tmp = EEPR3;
    404                      tmp &= ~mask;
    405                      tmp |= bVal;
    406                      EEPR3 = tmp;
    407                  }
    408                  else{
    409                      return EEC_SECTION_INVALID;
    410                  }
    411                  return EEC_NO_ERROR;
   \                     ??ATA_eepEEPaccessRightsChange_C_6:
   \   000000B6   ....               RJMP    ?Subroutine0
   \                     ??ATA_eepEEPaccessRightsChange_C_5:
   \   000000B8   3021               CPI     R18, 1
   \   000000BA   F441               BRNE    ??ATA_eepEEPaccessRightsChange_C_7
   \   000000BC   9100....           LDS     R16, _A_EEPR1
   \   000000C0   9550               COM     R21
   \   000000C2   2305               AND     R16, R21
   \   000000C4   2B03               OR      R16, R19
   \   000000C6   9300....           STS     _A_EEPR1, R16
   \   000000CA   CFF5               RJMP    ??ATA_eepEEPaccessRightsChange_C_6
   \                     ??ATA_eepEEPaccessRightsChange_C_7:
   \   000000CC   3022               CPI     R18, 2
   \   000000CE   F441               BRNE    ??ATA_eepEEPaccessRightsChange_C_8
   \   000000D0   9100....           LDS     R16, _A_EEPR2
   \   000000D4   9550               COM     R21
   \   000000D6   2305               AND     R16, R21
   \   000000D8   2B03               OR      R16, R19
   \   000000DA   9300....           STS     _A_EEPR2, R16
   \   000000DE   CFEB               RJMP    ??ATA_eepEEPaccessRightsChange_C_6
   \                     ??ATA_eepEEPaccessRightsChange_C_8:
   \   000000E0   3023               CPI     R18, 3
   \   000000E2   F441               BRNE    ??ATA_eepEEPaccessRightsChange_C_4
   \   000000E4   9100....           LDS     R16, _A_EEPR3
   \   000000E8   9550               COM     R21
   \   000000EA   2305               AND     R16, R21
   \   000000EC   2B03               OR      R16, R19
   \   000000EE   9300....           STS     _A_EEPR3, R16
   \   000000F2   CFE1               RJMP    ??ATA_eepEEPaccessRightsChange_C_6
   \                     ??ATA_eepEEPaccessRightsChange_C_4:
   \   000000F4   E006               LDI     R16, 6
   \   000000F6   9508               RET
   \   000000F8                      REQUIRE _A_SREG
   \   000000F8                      REQUIRE _A_TRCDR
   \   000000F8                      REQUIRE _A_TRCIDL
   \   000000F8                      REQUIRE _A_TRCIDH
   \   000000F8                      REQUIRE _A_EEPR0
   \   000000F8                      REQUIRE _A_EEPR1
   \   000000F8                      REQUIRE _A_EEPR2
   \   000000F8                      REQUIRE _A_EEPR3
    412          	}
    413          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   ....               RJMP    ATA_eepFuseWrite_C
    414          /*---------------------------------------------------------------------------*/
    415          /** \brief <b>ATA_eepFusesFix_C</b>
    416              This function is used to fix the EEProm access rights fuses. if fuse is
    417              programmed the fuses are not eraseable anymore.
    418          
    419              \param[in]  bVal                Value to be written to the fix fuse byte
    420              \return     Status of the performed EEPROM operation (::eEepErrorCode)
    421          
    422              \internal
    423              \li 005: Update HW Trace Unit with specific function information
    424              \li 010: Adjust Fuse settings by calling function ::ATA_eepFuseWrite_C with the
    425                        new fuse fix value and fuse fix as target fuse
    426          
    427              \Derived{No}
    428          
    429              \Rationale{N/A}
    430          
    431              \Traceability{Primus2P-3150, Primus2P-3153}
    432              \endinternal
    433          \n
    434          */
    435          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    436          __root eEepErrorCode ATA_eepFusesFix_C(uint8_t bVal)
   \                     ATA_eepFusesFix_C:
    437          /*---------------------------------------------------------------------------*/
    438          {
    439              /* LLR-Ref: 005 */
    440              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepFusesFix_C, bVal);
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
   \   00000004   9300....           STS     _A_TRCDR, R16
   \   00000008   ....               LDI     R18, LOW(ATA_eepFusesFix_C/2)
   \   0000000A   9320....           STS     _A_TRCIDL, R18
   \   0000000E   ....               LDI     R18, (ATA_eepFusesFix_C/2) >> 8
   \   00000010   9320....           STS     _A_TRCIDH, R18
   \   00000014   BF1F               OUT     0x3F, R17
    441          
    442              /* LLR-Ref: 010 */
    443              return ATA_eepFuseWrite_C(FUSE_EP_F,bVal);
   \   00000016   2F10               MOV     R17, R16
   \   00000018   E002               LDI     R16, 2
   \   0000001A                      REQUIRE ?Subroutine2
   \   0000001A                      REQUIRE _A_SREG
   \   0000001A                      REQUIRE _A_TRCDR
   \   0000001A                      REQUIRE _A_TRCIDL
   \   0000001A                      REQUIRE _A_TRCIDH
   \   0000001A                      ;               // Fall through to label ?Subroutine2
    444          }
    445          /*---------------------------------------------------------------------------*/
    446          /** \brief <b>ATA_eepReadBytes_C</b>
    447              The purpose of this function is to read multiple bytes from the EEPROM in
    448              accordance with the applicable EEPROM Access Right Map.
    449              To copy the bytes, the EEPROM burst read mode is used.
    450          
    451              \param[out] pDes  Pointer pointing to the destination to store the read data to
    452              \param[in]  wSrc  Specifying the EEProm address to start reading from
    453              \param[in]  bCount amount of data to be read from the given EEProm address
    454              \return     Status of the performed EEPROM operation (::eEepErrorCode)
    455              
    456              \internal
    457              \li 001: Store SREG state to be able to restore it at the end of the function 
    458                        call
    459              \li 005: Update HW Trace Unit with specific function information
    460              \li 010: Check for the addresses being within range without overflow protection
    461          
    462                       Note 1:
    463                       The HW/SW access right management will prevent any locked/protected 
    464                       data to be read. Address overflow will also be detected.
    465          
    466                       Note 2:
    467                       The computation of max. address and the following check is correct,
    468                       since the last valid address to read one byte from is 
    469                       EEP_ADDR_START_OUT_OF_RANGE_SEC - 1. This check approach does not 
    470                       require to subract -1 from max. address, which would be the most
    471                       natural way to compute the real max. address.
    472          
    473              \li 020: Check EEP write feature for being busy. Wait in case until it is able
    474                       to deal with the request.
    475              \li 030: Disable interrupts via global interrupt flag in SREG
    476              \li 040: Setup EEProm address for start the reading request.
    477              \li 050: Enable the EEPROM burst read feature by setting bit "EEBRE" in
    478                       register EECR2 to 1
    479              \li 060: read desired data from EEProm and store it to the destination address
    480              \li 070: If EEP FEC (EEP error correction flag) flag is, set the return status 
    481                        to EEProm error correction occured and clear the flag afterwards
    482              \li 080: If EEP AVF (Access violation Flag) flag is, set the return status to
    483                        EEProm address locked for reading and clear the flag afterwards
    484              \li 090: Disable the EEPROM burst read mode by setting bit "EEBRE" in register
    485                       EECR2 to 0.
    486              \li 100: Restore SREG to state before function call.
    487          
    488              \Derived{No}
    489          
    490              \Rationale{N/A}
    491          
    492              \Traceability{Primus2P-3143, Primus2P-3146, Primus2P-3150, Primus2P-3153,\
    493                            Primus2P-3184}
    494              \endinternal
    495          \n
    496          */
    497          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    498          __root eEepErrorCode ATA_eepReadBytes_C(uint8_t* pDes, uint16_t wSrc, uint8_t bCount)
   \                     ATA_eepReadBytes_C:
    499          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   2F64               MOV     R22, R20
    500              /* LLR-Ref: 001 */
    501              uint8_t bSreg = SREG;
   \   00000004   B60F               IN      R0, 0x3F
    502          
    503              uint16_t maxAddr;
    504              eEepErrorCode ret = EEC_NO_ERROR;
   \   00000006   E000               LDI     R16, 0
    505              
    506              /* LLR-Ref: 005 */
    507              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepReadBytes_C, bCount);
   \   00000008   B71F               IN      R17, 0x3F
   \   0000000A   94F8               CLI
   \   0000000C   9340....           STS     _A_TRCDR, R20
   \   00000010   ....               LDI     R20, LOW(ATA_eepReadBytes_C/2)
   \   00000012   9340....           STS     _A_TRCIDL, R20
   \   00000016   ....               LDI     R20, (ATA_eepReadBytes_C/2) >> 8
   \   00000018   9340....           STS     _A_TRCIDH, R20
   \   0000001C   BF1F               OUT     0x3F, R17
    508              
    509              /* LLR-Ref: 010 */
    510              maxAddr = wSrc + bCount;
    511              if((wSrc > EEP_ADDR_END_ATMEL_SEC) ||
    512                 (maxAddr > EEP_ADDR_START_OUT_OF_RANGE_SEC))
   \   0000001E   3820               CPI     R18, 128
   \   00000020   E019               LDI     R17, 9
   \   00000022   0731               CPC     R19, R17
   \   00000024   F430               BRCC    ??ATA_eepReadBytes_C_0
   \   00000026   01A9               MOVW    R21:R20, R19:R18
   \   00000028   0F46               ADD     R20, R22
   \   0000002A   1F50               ADC     R21, R16
   \   0000002C   3841               CPI     R20, 129
   \   0000002E   4059               SBCI    R21, 9
   \   00000030   F008               BRCS    ??ATA_eepReadBytes_C_1
    513              {
    514                  return EEC_ADDR_OUT_OF_RANGE;
   \                     ??ATA_eepReadBytes_C_0:
   \   00000032   ....               RJMP    ?Subroutine1
    515              }
    516          
    517              /* LLR-Ref: 020 */
    518              while(EECR&(BITMASK(NVMBSY)));
   \                     ??ATA_eepReadBytes_C_1:
   \   00000034   99FF               SBIC    0x1F, 0x07
   \   00000036   CFFE               RJMP    ??ATA_eepReadBytes_C_1
    519              
    520              /* LLR-Ref: 030 */
    521              __disable_interrupt();
   \   00000038   94F8               CLI
    522              
    523              /* LLR-Ref: 040 */
    524              EEARH = (uint8_t)(wSrc >> SHIFT_HIGH_TO_LOW_BYTE);
   \   0000003A   BD32               OUT     0x22, R19
    525              EEARL = (uint8_t)(wSrc & MASK_HIGH_BYTE);
   \   0000003C   BD21               OUT     0x21, R18
    526              
    527              /* LLR-Ref: 050 */
    528              EECR2 = BM_EEBRE;
   \   0000003E   E011               LDI     R17, 1
   \   00000040   BB16               OUT     0x16, R17
    529              
    530              /* LLR-Ref: 060 */
    531              for(uint8_t i=0;i<bCount;i++){
   \   00000042   E010               LDI     R17, 0
   \   00000044   C003               RJMP    ??ATA_eepReadBytes_C_2
    532                  *pDes++ = EEDR;
   \                     ??ATA_eepReadBytes_C_3:
   \   00000046   B520               IN      R18, 0x20
   \   00000048   9321               ST      Z+, R18
    533              }
   \   0000004A   9513               INC     R17
   \                     ??ATA_eepReadBytes_C_2:
   \   0000004C   1716               CP      R17, R22
   \   0000004E   F3D8               BRCS    ??ATA_eepReadBytes_C_3
    534              /* LLR-Ref: 070 */
    535              if(EECR2 & BM_E2FF) {
   \   00000050   9BB6               SBIS    0x16, 0x06
   \   00000052   C002               RJMP    ??ATA_eepReadBytes_C_4
    536                  ret = EEC_ERROR_CORRECTION_OCCURED;
   \   00000054   E004               LDI     R16, 4
    537                  EECR2 |= BM_E2FF;
   \   00000056   9AB6               SBI     0x16, 0x06
    538              }
    539              
    540              /* LLR-Ref: 080 */
    541              if(EECR2 & BM_E2AVF)
   \                     ??ATA_eepReadBytes_C_4:
   \   00000058   9BB5               SBIS    0x16, 0x05
   \   0000005A   C002               RJMP    ??ATA_eepReadBytes_C_5
    542              {
    543                  ret = EEC_ADDR_LOCKED_FOR_READING;
   \   0000005C   E001               LDI     R16, 1
    544                  EECR2 |= BM_E2AVF;
   \   0000005E   9AB5               SBI     0x16, 0x05
    545              }
    546              
    547              /* LLR-Ref: 090 */
    548              EECR2 &= ~BM_EEBRE;
   \                     ??ATA_eepReadBytes_C_5:
   \   00000060   98B0               CBI     0x16, 0x00
    549          
    550              /* LLR-Ref: 100 */
    551              SREG = bSreg;
   \   00000062   BE0F               OUT     0x3F, R0
    552          
    553              return ret;
   \   00000064   9508               RET
   \   00000066                      REQUIRE _A_SREG
   \   00000066                      REQUIRE _A_TRCDR
   \   00000066                      REQUIRE _A_TRCIDL
   \   00000066                      REQUIRE _A_TRCIDH
   \   00000066                      REQUIRE _A_EECR
   \   00000066                      REQUIRE _A_EEARH
   \   00000066                      REQUIRE _A_EEARL
   \   00000066                      REQUIRE _A_EECR2
   \   00000066                      REQUIRE _A_EEDR
    554          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   E003               LDI     R16, 3
   \   00000002   9508               RET
    555          
    556          
    557          /*---------------------------------------------------------------------------*/
    558          /** \brief <b>ATA_eepWriteBytes_C</b>
    559              shall write data to the device internal EEProm.
    560          
    561              \param[in] pSrc   Pointer pointing to the source of the written data
    562              \param[in] wDes   Specifying the EEP address to start writing to
    563              \param[in] bCount Specifying the amount of data to write to the given EEP address
    564              \return     Status of the performed EEPROM write access (:.eEepErrorCode)
    565          
    566              \internal
    567              \li 001: Store SREG state to be able to restore it at the end of the function 
    568                        call
    569              \li 010: Update HW Trace Unit with specific function information
    570              \li 020: Check for the addresses being within range with overflow protection
    571          
    572                       Note 1:
    573                       The HW/SW access right management will prevent any locked/protected 
    574                       data to be read. Address overflow will also be detected.
    575          
    576                       Note 2:
    577                       The computation of max. address and the following check is correct,
    578                       since the last valid address to read one byte from is 
    579                       EEP_ADDR_START_OUT_OF_RANGE_SEC - 1. This check approach does not 
    580                       require to subract -1 from max. address, which would be the most
    581                       natural way to compute the real max. address.
    582          
    583              \li 030: Loop writing the desired data to EEProm by using the page write feature.
    584              \li 040: Check EEP write feature for being busy. Wait in case untill it is able
    585                        to deal with the request.
    586              \li 050: Disable interrupts via global interrupt flag in SREG
    587              \li 060: Reset WDT counter
    588              \li 070: Setup EEP address and enalbe the page writing feature.
    589              \li 080: Loop to write the data to the EEP page buffer.
    590              \li 090: Break in case page border is reached or all bytes have been transfered.
    591              \li 100: Enable the atomic EEPROM write operation by resetting bits "EEPM1" and
    592                        "EEPM0" in register EECR. Enable the master write mode by setting bit
    593                        "EEMWE" in register EECR. Then Start the EEPROM write by setting bit
    594                        "EEWE" in register EECR.
    595              \li 110: Restore SREG to state before function call.
    596              \li 130: Check error flag caused by a wrong access.
    597          
    598              \Derived{No}
    599          
    600              \Rationale{N/A}
    601          
    602              \Traceability{Primus2P-3143, Primus2P-3146, Primus2P-3150, Primus2P-3153\
    603                            Primus2P-3185}
    604              \endinternal
    605          \n
    606          */
    607          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    608          __root eEepErrorCode ATA_eepWriteBytes_C(uint8_t *pSrc, uint16_t wDes, uint8_t bCount)
   \                     ATA_eepWriteBytes_C:
    609          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   2F64               MOV     R22, R20
    610              /* LLR-Ref: 001 */
    611              uint8_t bSreg = SREG;
   \   00000004   B60F               IN      R0, 0x3F
    612            
    613              uint16_t maxAddr;
    614              eEepErrorCode ret = EEC_NO_ERROR;
   \   00000006   E000               LDI     R16, 0
    615              
    616              /* LLR-Ref: 010 */
    617              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepWriteBytes_C, bCount);
   \   00000008   B71F               IN      R17, 0x3F
   \   0000000A   94F8               CLI
   \   0000000C   9340....           STS     _A_TRCDR, R20
   \   00000010   ....               LDI     R20, LOW(ATA_eepWriteBytes_C/2)
   \   00000012   9340....           STS     _A_TRCIDL, R20
   \   00000016   ....               LDI     R20, (ATA_eepWriteBytes_C/2) >> 8
   \   00000018   9340....           STS     _A_TRCIDH, R20
   \   0000001C   BF1F               OUT     0x3F, R17
    618                  
    619              /* LLR-Ref: 020 */
    620              maxAddr = wDes + bCount;
    621              if((wDes > EEP_ADDR_END_CUSTO_SEC) || (maxAddr > EEP_ADDR_START_ATMEL_SEC))
   \   0000001E   3820               CPI     R18, 128
   \   00000020   E018               LDI     R17, 8
   \   00000022   0731               CPC     R19, R17
   \   00000024   F430               BRCC    ??ATA_eepWriteBytes_C_0
   \   00000026   01A9               MOVW    R21:R20, R19:R18
   \   00000028   0F46               ADD     R20, R22
   \   0000002A   1F50               ADC     R21, R16
   \   0000002C   3841               CPI     R20, 129
   \   0000002E   4058               SBCI    R21, 8
   \   00000030   F0C0               BRCS    ??ATA_eepWriteBytes_C_1
    622              {
    623                  return EEC_ADDR_OUT_OF_RANGE;
   \                     ??ATA_eepWriteBytes_C_0:
   \   00000032   ....               RJMP    ?Subroutine1
    624              }
    625              
    626              /* LLR-Ref: 030 */
    627              while(bCount>0)
    628              {
    629                  /* LLR-Ref: 040 */
    630                  while(EECR&(BITMASK(NVMBSY)));
   \                     ??ATA_eepWriteBytes_C_2:
   \   00000034   99FF               SBIC    0x1F, 0x07
   \   00000036   CFFE               RJMP    ??ATA_eepWriteBytes_C_2
    631                  
    632                  /* LLR-Ref: 050 */
    633                  __disable_interrupt();
   \   00000038   94F8               CLI
    634                  
    635                  /* LLR-Ref: 060 */
    636                  __watchdog_reset();
   \   0000003A   95A8               WDR
    637                  
    638                  /* LLR-Ref: 070 */
    639                  EECR |= BM_EEPAGE;
   \   0000003C   9AFE               SBI     0x1F, 0x06
    640                  EEARH = (uint8_t)(wDes >> SHIFT_HIGH_TO_LOW_BYTE);
   \   0000003E   BD32               OUT     0x22, R19
    641                  
    642                  /* LLR-Ref: 080 */
    643                  do{
    644                      EEARL = (uint8_t)(wDes & MASK_HIGH_BYTE);
   \                     ??ATA_eepWriteBytes_C_3:
   \   00000040   BD21               OUT     0x21, R18
    645                      EEDR = *pSrc++;
   \   00000042   9111               LD      R17, Z+
   \   00000044   BD10               OUT     0x20, R17
    646                      wDes++;
   \   00000046   5F2F               SUBI    R18, 255
   \   00000048   4F3F               SBCI    R19, 255
    647                      bCount--;
   \   0000004A   956A               DEC     R22
    648          
    649                  /* LLR-Ref: 090 */
    650                  }while((bCount>0)&&((EEARL&MASK_HIGH_NIBBLE)!=MASK_HIGH_NIBBLE));
   \   0000004C   F021               BREQ    ??ATA_eepWriteBytes_C_4
   \   0000004E   B511               IN      R17, 0x21
   \   00000050   701F               ANDI    R17, 0x0F
   \   00000052   301F               CPI     R17, 15
   \   00000054   F7A9               BRNE    ??ATA_eepWriteBytes_C_3
    651                  
    652                  /* LLR-Ref: 100 */
    653                  EECR &= ~(BM_EEPM1 | BM_EEPM0);
   \                     ??ATA_eepWriteBytes_C_4:
   \   00000056   B31F               IN      R17, 0x1F
   \   00000058   7C1F               ANDI    R17, 0xCF
   \   0000005A   BB1F               OUT     0x1F, R17
    654                  EECR |= BM_EEMWE;
   \   0000005C   9AFA               SBI     0x1F, 0x02
    655                  EECR |= BM_EEWE;
   \   0000005E   9AF9               SBI     0x1F, 0x01
    656                  
    657                  /* LLR-Ref: 110 */
    658                  SREG = bSreg;
   \   00000060   BE0F               OUT     0x3F, R0
    659              }
   \                     ??ATA_eepWriteBytes_C_1:
   \   00000062   2366               TST     R22
   \   00000064   F739               BRNE    ??ATA_eepWriteBytes_C_2
    660              
    661              /* LLR-Ref: 130 */
    662              if(EECR2&BM_E2AVF)
   \   00000066   9BB5               SBIS    0x16, 0x05
   \   00000068   C002               RJMP    ??ATA_eepWriteBytes_C_5
    663              {
    664                  ret = EEC_ADDR_LOCKED_FOR_WRITING;
   \   0000006A   E002               LDI     R16, 2
    665                  EECR2 |= BM_E2AVF;
   \   0000006C   9AB5               SBI     0x16, 0x05
    666              }
    667              while(EECR&(BITMASK(NVMBSY)));
   \                     ??ATA_eepWriteBytes_C_5:
   \   0000006E   99FF               SBIC    0x1F, 0x07
   \   00000070   CFFE               RJMP    ??ATA_eepWriteBytes_C_5
    668              
    669              return ret;
   \   00000072   9508               RET
   \   00000074                      REQUIRE _A_SREG
   \   00000074                      REQUIRE _A_TRCDR
   \   00000074                      REQUIRE _A_TRCIDL
   \   00000074                      REQUIRE _A_TRCIDH
   \   00000074                      REQUIRE _A_EECR
   \   00000074                      REQUIRE _A_EEARH
   \   00000074                      REQUIRE _A_EEARL
   \   00000074                      REQUIRE _A_EEDR
   \   00000074                      REQUIRE _A_EECR2
    670          }

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   ATA_eepEEPaccessRightsChange_C
        2   -> ATA_eepFuseRead_C
        2   -> ATA_eepFuseWrite_C
        2 ?C_SHL_L01
        2 ?S_SHL_L02
      2   ATA_eepFuseRead_C
      2   ATA_eepFuseWrite_C
        2   -> ATA_eepFuseRead_C
      2   ATA_eepFusesFix_C
        2   -> ATA_eepFuseWrite_C
      2   ATA_eepReadBytes_C
      2   ATA_eepWriteBytes_C


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?Subroutine0
       4  ?Subroutine1
       2  ?Subroutine2
     248  ATA_eepEEPaccessRightsChange_C
      62  ATA_eepFuseRead_C
      70  ATA_eepFuseWrite_C
      26  ATA_eepFusesFix_C
     102  ATA_eepReadBytes_C
     116  ATA_eepWriteBytes_C
       1  _A_EEARH
       1  _A_EEARL
       1  _A_EECR
       1  _A_EECR2
       1  _A_EEDR
       1  _A_EEPR0
       1  _A_EEPR1
       1  _A_EEPR2
       1  _A_EEPR3
       1  _A_SPMCSR
       1  _A_SREG
       1  _A_TRCDR
       1  _A_TRCIDH
       1  _A_TRCIDL
     256  g_sAtmelEEPromSection
     128  g_sCustomerEEPromSection

 
 256 bytes in segment .eep_sAtmelEEPromSection
 128 bytes in segment .eep_sCustomerEEPromSection
  14 bytes in segment ABSOLUTE
 634 bytes in segment CODE
 
 634 bytes of CODE memory
 384 bytes of DATA memory (+ 14 bytes shared)

Errors: none
Warnings: none
