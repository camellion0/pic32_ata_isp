###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            05/Apr/2016  13:30:41
# Copyright 1996-2015 IAR Systems AB.
# Network license: DVRIAR01.corpp.atmel.com (STD)
#
#    Source file  =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c
#    Command line =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c
#        -v3 --enhanced_core -ms -o
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\Obj
#        -lC
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List
#        -lA
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug --64k_flash
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 6.0\avr\inc\" --eeprom_size 1152 --clib
#        -Ohz
#    List file    =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\List\iic.lst
#    Object file  =  
#        C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\appl\libFwROM\IAR\Debug\Obj\iic.r90
#
###############################################################################

C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c
      1          /* *C**************************************************************************
      2            Use of this software is subject to Atmel's Software License Agreement.
      3          -------------------------------------------------------------------------------
      4            $URL: http://svnservulm.corp.atmel.com/svn/CDB/Apps/SW_Lib/Car_Access/CARS_GEN2/ATAB5702A/Branches/P2_Gen2_Merge/firmware/iic/src/iic.c $
      5            $LastChangedRevision: 328482 $
      6            $LastChangedDate: 2015-07-22 13:17:23 -0600 (Wed, 22 Jul 2015) $
      7            $LastChangedBy: grueter $
      8          -------------------------------------------------------------------------------
      9            Project:      ATA5700
     10            Target MCU:   ATA5700
     11            Compiler:     IAR C/C++ Compiler for AVR 6.3.18.2236
     12          -------------------------------------------------------------------------------
     13          
     14          ******************************************************************************
     15          * Copyright 2011, Atmel Automotive GmbH                                       *
     16          *                                                                             *
     17          * This software is owned by the Atmel Automotive GmbH                         *
     18          * and is protected by and subject to worldwide patent protection.             *
     19          * Atmel hereby grants to licensee a personal,                                 *
     20          * non-exclusive, non-transferable license to copy, use, modify, create        *
     21          * derivative works of, and compile the Atmel Source Code and derivative       *
     22          * works for the sole purpose of creating custom software in support of        *
     23          * licensee product to be used only in conjunction with a Atmel integrated     *
     24          * circuit as specified in the applicable agreement. Any reproduction,         *
     25          * modification, translation, compilation, or representation of this           *
     26          * software except as specified above is prohibited without the express        *
     27          * written permission of Atmel.                                                *
     28          *                                                                             *
     29          * Disclaimer: ATMEL MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,         *
     30          * WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
     31          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
     32          * Atmel reserves the right to make changes without further notice to the      *
     33          * materials described herein. Atmel does not assume any liability arising     *
     34          * out of the application or use of any product or circuit described herein.   *
     35          * Atmel does not authorize its products for use as critical components in     *
     36          * life-support systems where a malfunction or failure may reasonably be       *
     37          * expected to result in significant injury to the user. The inclusion of      *
     38          * Atmel products in a life-support systems application implies that the       *
     39          * manufacturer assumes all risk of such use and in doing so indemnifies       *
     40          * Atmel against all charges.                                                  *
     41          *                                                                             *
     42          * Use may be limited by and subject to the applicable Atmel software          *
     43          * license agreement.                                                          *
     44          ******************************************************************************/
     45          
     46          /** \file iic.c
     47          */
     48          
     49          /*===========================================================================*/
     50          /*  INCLUDES                                                                 */
     51          /*===========================================================================*/
     52          #include "iic.h"
     53          #include "../../globals/src/globals.h"
     54          
     55          /*===========================================================================*/
     56          /*  DEFINES                                                                  */
     57          /*===========================================================================*/
     58          
     59          
     60          /*===========================================================================*/
     61          /*  Modul Globals                                                            */
     62          /*===========================================================================*/
     63          /** \brief <b>iicCtrlBlock</b>
     64              contains IIC component data.
     65          */
     66          #pragma location = ".i2cpara"
     67          __no_init sIicCtrlBlock iicCtrlBlock;
     68          
     69          /*===========================================================================*/
     70          /*  IMPLEMENTATION                                                           */
     71          /*===========================================================================*/
     72          /*---------------------------------------------------------------------------*/
     73          /** \brief <b>ATA_iicReset_C</b>
     74              This routine performs the basic reset/init of the iicStatus and
     75              iicConfig. The IIC peripheral is also brought back into its default state.
     76          
     77          \param[out]     ctrlBlock       Pointer to an IIC ctrl structure
     78          
     79          \return     N/A
     80          
     81          \StackUsageInBytes{XXX}
     82          
     83          \image html ATA_iicReset_C.png
     84          
     85          \internal
     86          \li 010: Reset all IIC - SRAM - Variables to 0x00
     87          \li 020: Disable IIC peripherals with IRQs Disabled globally
     88          
     89          \Derived{No}
     90          
     91          \Rationale{N/A}
     92          
     93          \Traceability{Primus2P-2435}
     94          \endinternal
     95          \n
     96          */
     97          /*---------------------------------------------------------------------------*/
     98          VOIDFUNC ATA_iicReset_C(sIicCtrlBlock* ctrlBlock)
     99          {   
    100              uint8_t tmp; 
    101              // LLR-Ref: 010 
    102              // Set all member variables to 0x00 in order to get a well defined state.
    103              ctrlBlock->iicAddr = 0x00U;
    104              ctrlBlock->iicAddrMsk = 0x00U;
    105              ctrlBlock->iicBaudRate = 0x00U;
    106              ctrlBlock->iicPrescaler = 0x00U;    
    107              ctrlBlock->iicStatus = 0x00U;
    108              ctrlBlock->iicConfig = 0x00U;   
    109              ctrlBlock->iicBufLen = 0x00U;
    110              ctrlBlock->iicDataTx = 0x00U;   
    111              ctrlBlock->iicByteCount = 0x00U;          
    112              // LLR-Ref: 020 
    113              // Bring the IIC peripheral into a defined state, IRQs are disabled while
    114              // serving this task.
    115              tmp = SREG;
    116              _CLI;
    117              PRR0 &= (uint8_t)~(BM_PRI2C);
                                        ^
Error[Pe020]: identifier "BM_PRI2C" is undefined
    118              I2CR = BM_I2INT;
                     ^
Error[Pe020]: identifier "I2CR" is undefined

      I2CR = BM_I2INT;
             ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",118  Error[Pe020]: 
          identifier "BM_I2INT" is undefined
    119              PRR0 |= (uint8_t)(BM_PRI2C);
    120              SREG = tmp;
    121              
    122          }
    123          /*---------------------------------------------------------------------------*/
    124          /** \brief <b>ATA_iicClrError_C</b>
    125              This routine clears pending IIC errors and re enables the peripheral.
    126          
    127          \param[out]     ctrlBlock       Pointer to an IIC ctrl structure
    128          
    129          \return     N/A
    130          
    131          \StackUsageInBytes{XXX}
    132          
    133          \image html ATA_iicClrError_C.png
    134          
    135          \internal
    136          \li 010: Reset both available IIC module error flags
    137          \li 020: Re-Enable the IIC to generate an ACK on the Bus
    138          
    139          \Derived{No}
    140          
    141          \Rationale{N/A}
    142          
    143          \Traceability{Primus2P-2477,Primus2P-2518}
    144          \endinternal
    145          \n
    146          */
    147          /*---------------------------------------------------------------------------*/
    148          VOIDFUNC ATA_iicClrError_C(sIicCtrlBlock* ctrlBlock)
    149          {              
    150              // LLR-Ref: 010 
    151              // Clear the error flags of the IIC module.
    152              ctrlBlock->iicStatus &= ~(BM_CONFERRORIIC|BM_IICTRXERROR);
    153              // LLR-Ref: 020 
    154              // Enable the ACK of data in the IIC module.
    155              I2CR |= BM_I2EA;         
                     ^
Error[Pe020]: identifier "I2CR" is undefined

      I2CR |= BM_I2EA;         
              ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",155  Error[Pe020]: 
          identifier "BM_I2EA" is undefined
    156          }
    157          
    158          /*---------------------------------------------------------------------------*/
    159          /** \brief <b>ATA_iicClrRxDataPend_C</b>
    160              This routine clears the RX data pending IIC flag and re enables
    161              the peripheral to generate an IIC ACK.
    162          
    163          \param[out]     ctrlBlock       Pointer to an IIC ctrl structure
    164          
    165          \return     N/A
    166          
    167          \StackUsageInBytes{XXX}
    168          
    169          \image html ATA_iicClrRxDataPend_C.png
    170          
    171          \internal
    172          \li 010: Reset the RX data pending Flag
    173          \li 020: Re-Enable the IIC to generate an ACK on the Bus
    174          
    175          \Derived{No}
    176          
    177          \Rationale{N/A}
    178          
    179          \Traceability{Primus2P-2477,Primus2P-2518}
    180          \endinternal
    181          \n
    182          */
    183          /*---------------------------------------------------------------------------*/
    184          VOIDFUNC ATA_iicClrRxDataPend_C(sIicCtrlBlock* ctrlBlock)
    185          {           
    186              // LLR-Ref: 010 
    187              // Reset the RX data pending Flag.
    188              ctrlBlock->iicStatus &= ~(BM_IICRXDATAPEDING);
    189              // LLR-Ref: 020 
    190              // Re-Enable the IIC to generate an ACK on the Bus.
    191              I2CR |= BM_I2EA;         
                     ^
Error[Pe020]: identifier "I2CR" is undefined

      I2CR |= BM_I2EA;         
              ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",191  Error[Pe020]: 
          identifier "BM_I2EA" is undefined
    192          }
    193          
    194          /*---------------------------------------------------------------------------*/
    195          /** \brief <b>ATA_iicHwSetup_C</b>
    196              This routine performs the setup of the HW configuration.
    197              The configuration is based on the IIC settings located 
    198              inside the iicCtrlBlock structure.
    199          
    200          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    201          \param[in]      iicAddr         IIC address
    202          \param[in]      iicAddrMsk      IIC address Mask
    203          \param[in]      iicBaudRate     IIC baudrate setting
    204          \param[in]      iicPrescaler    IIC prescaler setting
    205          
    206          \return     OK on success, FAIL on failure
    207          
    208          \StackUsageInBytes{XXX}
    209          
    210          \image html ATA_iicHwSetup_C.png
    211          
    212          \internal
    213          \li 010: Check for a ongoing IIC transaction\n
    214                   IF set Error Flag IIC configuration error and do not touch the IIC
    215                   configuration nor its SRAM based variables
    216          \li 020: ELSE Configure the IIC SRAM block with the given parameters and return the success
    217          
    218          \Derived{No}
    219          
    220          \Rationale{N/A}
    221          
    222          \Traceability{Primus2P-2434,Primus2P-2477}
    223          \endinternal
    224          \n
    225          */
    226          /*---------------------------------------------------------------------------*/
    227          UINT8FUNC ATA_iicHwSetup_C(sIicCtrlBlock* ctrlBlock, uint8_t iicAddr, uint8_t iicAddrMsk, uint8_t iicBaudRate, uint8_t iicPrescaler)
    228          {   
    229              uint8_t retVal;
    230              retVal = FAIL;
    231              // LLR-Ref: 010 
    232              // The SRAM based IIC ctrl struct is only updated in case it is inactive.
    233              if(!(ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING)){
    234                  ctrlBlock->iicAddr = iicAddr;
    235                  ctrlBlock->iicAddrMsk = iicAddrMsk;      
    236                  ctrlBlock->iicBaudRate = iicBaudRate;
    237                  ctrlBlock->iicPrescaler = iicPrescaler;
    238                  retVal = OK;
    239              } 
    240              // LLR-Ref: 020     
    241              // Updating not possible, as IIC is active exchanging data. 
    242              // Therfore an error flag is raised.
    243              else{
    244                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    245              }    
    246              return retVal;
    247          }
    248          
    249          /*---------------------------------------------------------------------------*/
    250          /** \brief <b>ATA_iicBufferSetup_C</b>
    251              This routine performs the setup of the IIC related buffer holding the data
    252              to be TXed or RXed.
    253          
    254          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    255          \param[in]      len             Length of the linked buffer array
    256          \param[in]      ptr             Address linked to the IIC buffer   
    257          
    258          \return     OK on success, FAIL on failure
    259          
    260          \StackUsageInBytes{XXX}
    261          
    262          \image html ATA_iicBufferSetup_C.png
    263          
    264          \internal
    265          \li 010: Check for a buffer len bigger than 0,\n
    266                   Check the ptr valid flag for a valid pointer\n
    267                   Check that no IIC transaction is in progress\n
    268                   IF Configure the IIC SRAM block with the given parameters and return the successset          
    269          \li 020: ELSE raise Error Flag IIC configuration error and do not touch the IIC
    270                   configuration nor its SRAM based variables
    271          
    272          \Derived{No}
    273          
    274          \Rationale{N/A}
    275          
    276          \Traceability{Primus2P-2433,Primus2P-2477}
    277          \endinternal
    278          \n
    279          */
    280          /*---------------------------------------------------------------------------*/
    281          UINT8FUNC ATA_iicBufferSetup_C(uint8_t len, uint8_t* ptr, sIicCtrlBlock* ctrlBlock)
    282          {   
    283              uint8_t retVal;
    284              retVal = FAIL;
    285              // LLR-Ref: 010   
    286              // The SRAM based IIC ctrl struct is only updated in case it is inactive 
    287              // and the ptr changing is validated via a flag.
    288              if((len>0U)&&(ctrlBlock->iicConfig&BM_PTRVALID)&&(!(ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING))){
    289                  ctrlBlock->iicConfig &= ~BM_PTRVALID;
    290                  ctrlBlock->iicBufLen = len;
    291                  ctrlBlock->iicBuffer = ptr;
    292                  retVal = OK;
    293              }
    294              // LLR-Ref: 020  
    295              // Updating not possible, as IIC is active exchanging data or the 
    296              // validation falg is not set. Therfore an error flag is raised.    
    297              else{
    298                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    299              }
    300              
    301              return retVal;
    302          }
    303          
    304          /*---------------------------------------------------------------------------*/
    305          /** \brief <b>ATA_iicOpen_C</b>
    306              This routine performs the setup of the HW configuration of the
    307              IIC settings located inside the iicCtrlBlock structure.
    308          
    309          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    310          
    311          \return     OK on success, FAIL on failure
    312          
    313          \StackUsageInBytes{XXX}
    314          
    315          \image html ATA_iicOpen_C.png
    316          
    317          \internal
    318          \li 010: Check if an opening of the IIC interface is possible          
    319          \li 020: IF possible configure the IIC HW registers with the contents 
    320                   of the ctrl structure. Switch the clocking to the peripheral
    321                   and mark it as locked.
    322          \li 025: Polling or IRQ based IIC usage. IF IRQ based IIC IRQ is enabled, ELSE
    323                   IIC IRQ is not enabled, but disabeld.
    324          \li 030: ELSE raise Error Flag IIC configuration error and do not touch the IIC
    325                   configuration nor its SRAM based variables 
    326          \li 040: Return FAIL/OK         
    327          
    328          \Derived{No}
    329          
    330          \Rationale{N/A}
    331          
    332          \Traceability{Primus2P-2432,Primus2P-2477}
    333          \endinternal
    334          \n
    335          */
    336          /*---------------------------------------------------------------------------*/
    337          UINT8FUNC ATA_iicOpen_C(sIicCtrlBlock* ctrlBlock)
    338          {   
    339              uint8_t retVal;
    340              retVal = FAIL;
    341              // LLR-Ref: 010  
    342              // The IIC module is only opened in case it is not opened/locked already
    343              // and there is no IIC transaction ongoing.
    344              if(!((ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING)||(ctrlBlock->iicStatus&BM_IIC2LOCK))){
    345                  // LLR-Ref: 020     
    346                  PRR0 &= (uint8_t)~(BM_PRI2C);
                                            ^
Error[Pe020]: identifier "BM_PRI2C" is undefined
    347                  I2AR = ctrlBlock->iicAddr;
                         ^
Error[Pe020]: identifier "I2AR" is undefined
    348                  I2AMR = ctrlBlock->iicAddrMsk;
                         ^
Error[Pe020]: identifier "I2AMR" is undefined
    349                  I2BR = ctrlBlock->iicBaudRate;
                         ^
Error[Pe020]: identifier "I2BR" is undefined
    350                  I2SR = ctrlBlock->iicPrescaler;
                         ^
Error[Pe020]: identifier "I2SR" is undefined
    351                  ctrlBlock->iicStatus |= BM_IIC2LOCK;
    352                  // LLR-Ref: 025
    353                  // Check for IRQ based IIC operation or Polling based operation.
    354                  // In case IRQ based -> enable IIC IRQ 
    355                  // In case POLLING -> disable IIC IRQ
    356                  if(ctrlBlock->iicConfig&BM_IICIRQ){
    357                      I2CR = (BM_I2EN | BM_I2IE | BM_I2EA);
                             ^
Error[Pe020]: identifier "I2CR" is undefined

              I2CR = (BM_I2EN | BM_I2IE | BM_I2EA);
                      ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",357  Error[Pe020]: 
          identifier "BM_I2EN" is undefined

              I2CR = (BM_I2EN | BM_I2IE | BM_I2EA);
                                ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",357  Error[Pe020]: 
          identifier "BM_I2IE" is undefined

              I2CR = (BM_I2EN | BM_I2IE | BM_I2EA);
                                          ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",357  Error[Pe020]: 
          identifier "BM_I2EA" is undefined
    358                  }
    359                  else{
    360                      I2CR = (BM_I2EN | BM_I2EA);
                             ^
Error[Pe020]: identifier "I2CR" is undefined

              I2CR = (BM_I2EN | BM_I2EA);
                      ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",360  Error[Pe020]: 
          identifier "BM_I2EN" is undefined

              I2CR = (BM_I2EN | BM_I2EA);
                                ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",360  Error[Pe020]: 
          identifier "BM_I2EA" is undefined
    361                  }
    362                  retVal = OK;
    363              }    
    364              else{
    365                  // LLR-Ref: 030    
    366                  // Raise an Error Flag and do not touch the IIC
    367                  // configuration nor its SRAM based variables. 
    368                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    369              }
    370              // LLR-Ref: 040            
    371              // Return the status of the opening attemp.
    372              return retVal;
    373          }
    374          
    375          /*---------------------------------------------------------------------------*/
    376          /** \brief <b>ATA_iicUse_C</b>
    377              This routine performs the all needed steps to have the IIC 
    378              available for usage.
    379          
    380          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    381          \param[in]      iicAddr         IIC address
    382          \param[in]      iicAddrMsk      IIC address mask
    383          \param[in]      iicBaudRate     IIC baudrate setting
    384          \param[in]      iicPrescaler    IIC prescaler setting    
    385          \param[in]      bufLen          Length of the linked buffer array
    386          \param[in]      ptr             Address linked to the IIC buffer
    387          \param[in]      iicConfig       IIC configuration
    388          
    389          \return     OK on success, FAIL on failure
    390          
    391          \StackUsageInBytes{XXX}
    392          
    393          \image html ATA_iicUse_C.png
    394          
    395          \internal
    396          \li 010: Trigger the HW tracer 
    397          \li 020: Reset the IIC SRAM contents and the IIC HW by calling function 
    398                   ::ATA_iicReset_C
    399          \li 030: Setup the buffer linked to the IIC module by calling function
    400                   ::ATA_iicBufferSetup_C
    401          \li 040: Setup the IIC related HW by calling function ::ATA_iicHwSetup_C
    402          \li 050: Open the IIC peripheral by calling function ::ATA_iicOpen_C
    403          \li 060: Return the status of the operations
    404          
    405          \Derived{No}
    406          
    407          \Rationale{N/A}
    408          
    409          \Traceability{Primus2P-2432,Primus2P-2476,Primus2P-2477,Primus2P-2501}
    410          \endinternal
    411          \n
    412          */
    413          /*---------------------------------------------------------------------------*/
    414          UINT8FUNC ATA_iicUse_C(sIicCtrlBlock* ctrlBlock, uint8_t iicAddr, uint8_t iicAddrMsk, uint8_t iicBaudRate, uint8_t iicPrescaler, uint8_t bufLen, uint8_t* ptr, uint8_t iicConfig)
    415          {
    416              uint8_t retVal;
    417              // LLR-Ref: 010   
    418              // Trigger the HW tracer. 
    419              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_iicUse_C, 0x00U);
    420              retVal = FAIL;
    421              // LLR-Ref: 020  
    422              // Reset the IIC SRAM contents and the IIC HW.
    423              ATA_iicReset_C(ctrlBlock);
    424              ctrlBlock->iicConfig = iicConfig;
    425              // LLR-Ref: 030   
    426              // Setup the buffer linked to the IIC module.
    427              if(ATA_iicBufferSetup_C(bufLen,ptr,ctrlBlock)){
    428                  return retVal;
    429              }
    430              // LLR-Ref: 040    
    431              // Setup the IIC related HW.
    432              if(ATA_iicHwSetup_C(ctrlBlock,iicAddr,iicAddrMsk,iicBaudRate,iicPrescaler)){
    433                  return retVal;
    434              }
    435              // LLR-Ref: 050    
    436              // Open the IIC peripheral.
    437              ATA_iicOpen_C(ctrlBlock);
    438              // LLR-Ref: 060  
    439              // Return the status of the operations.    
    440              retVal = OK;
    441              return retVal;    
    442          }
    443          
    444          
    445          /*---------------------------------------------------------------------------*/
    446          /** \brief <b>ATA_iicMasterTrigger_C</b>
    447              This routine Trigger the start of an IIC master transaction.
    448          
    449          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    450          
    451          \return     OK on success, FAIL on failure
    452          
    453          \StackUsageInBytes{XXX}
    454          
    455          \image html ATA_iicMasterTrigger_C.png
    456          
    457          \internal
    458          \li 010: Trigger the HW tracer 
    459          \li 020: Check if triggering the transaction is valid. 
    460                   IF NOT, raise an error condition
    461          \li 030: IF VALID, display it via the iicStatus variable
    462          \li 040: Setup a Master RX transaction
    463          \li 050: Setup a Master TX transaction
    464          \li 060: Trigger the start of the IIC transaction
    465          \li 070: Return the status of the operation
    466          
    467          \Derived{No}
    468          
    469          \Rationale{N/A}
    470          
    471          \Traceability{Primus2P-2426,Primus2P-2427,Primus2P-2428,Primus2P-2429,Primus2P-2431,Primus2P-2477,Primus2P-2501}
    472          \endinternal
    473          \n
    474          */
    475          /*---------------------------------------------------------------------------*/
    476          UINT8FUNC ATA_iicMasterTrigger_C(sIicCtrlBlock* ctrlBlock)
    477          {   
    478              uint8_t retVal;
    479              retVal = FAIL;
    480              // LLR-Ref: 010    
    481              // Trigger the HW tracer 
    482              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_iicMasterTrigger_C, *(ctrlBlock->iicBuffer));
    483              // LLR-Ref: 020    
    484              // Check if an IIC transaction is in progress or the setup data length is 0x00 
    485              // or the setup data length is larger than the IIC buffer or the IIC is not locked.
    486              // if one condition is true, an error flag is raised.
    487              if(((ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING)||(ctrlBlock->iicDataTx==0x00U)||(ctrlBlock->iicDataTx>ctrlBlock->iicBufLen)||(!ctrlBlock->iicStatus&BM_IIC2LOCK))){       
    488                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    489              }    
    490              // LLR-Ref: 030  
    491              // Triggering an IIC trnasaction is valid. Check what mode is needed. (Master TX / Master RX)
    492              // Setup the IIC status byte to display the internal IIC state.
    493              else{
    494                  ctrlBlock->iicStatus &= ~(BM_IICTRANSACTIONONGOING|BM_IICRXDATAPEDING|BM_IICTXDATAPENDING|BM_IICTRXSTATE);
    495                  // LLR-Ref: 040  
    496                  if(*(ctrlBlock->iicBuffer)&BM_IICTRX){//Master Read IIC transaction.
    497                      ctrlBlock->iicDataTx--;
    498                      if(ctrlBlock->iicDataTx<0x01U){
    499                          ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    500                          return retVal;
    501                      }
    502                      ctrlBlock->iicStatus |= (IICMASTERRX|BM_IICTRANSACTIONONGOING);
    503                  }
    504                  // LLR-Ref: 050  
    505                  else{//Masater Write IIC transaction.
    506                      ctrlBlock->iicStatus |= (IICMASTERTX|BM_IICTRANSACTIONONGOING);        
    507                  }        
    508                  // LLR-Ref: 060   
    509                  // Reset the IIC transaction byte counter.
    510                  ctrlBlock->iicByteCount = 0x00U; 
    511                  I2CR |= (BM_I2STA | BM_I2INT);           
                         ^
Error[Pe020]: identifier "I2CR" is undefined

          I2CR |= (BM_I2STA | BM_I2INT);           
                   ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",511  Error[Pe020]: 
          identifier "BM_I2STA" is undefined

          I2CR |= (BM_I2STA | BM_I2INT);           
                              ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",511  Error[Pe020]: 
          identifier "BM_I2INT" is undefined
    512                  retVal = OK;        
    513              }  
    514              // LLR-Ref: 070   
    515              // return the status of the IIC master triggering.
    516              return retVal;
    517          }
    518          /*---------------------------------------------------------------------------*/
    519          /** \brief <b>ATA_iicSetData_C</b>
    520              This routine performs the setup of the IIC related buffer holding the data
    521              to be TXed or RXed.
    522          
    523          \param[in,out]  ctrlBlock        Pointer to an IIC ctrl structure
    524          \param[in]      index            Index of place data will put into the pointed buffer
    525          \param[in]      data             Pattern put into the index location
    526          \param[in]      len              Length of data to be sent
    527          
    528          \return     OK on success, FAIL on failure
    529          
    530          \StackUsageInBytes{XXX}
    531          
    532          \image html ATA_iicSetData_C.png
    533          
    534          \internal
    535          \li 010: Check if setup of data is valid, IF NOT raise an error condition
    536          \li 020: IF VALID setup the data at the desired location
    537          
    538          \Derived{No}
    539          
    540          \Rationale{N/A}
    541          
    542          \Traceability{Primus2P-2431,Primus2P-2477}
    543          \endinternal
    544          \n
    545          */
    546          /*---------------------------------------------------------------------------*/
    547          UINT8FUNC ATA_iicSetData_C(uint8_t index, uint8_t data, sIicCtrlBlock* ctrlBlock, uint8_t len)
    548          {   
    549              uint8_t retVal;
    550              retVal = FAIL;
    551              // LLR-Ref: 010   
    552              // Check if setup of data is valid, IF NOT raise an error condition
    553              // Error is raised in case of an ongoing IIC transaction or the index is out of 
    554              // the range of the linked array.
    555              if(((ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING))||(index>=ctrlBlock->iicBufLen)){        
    556                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    557              }
    558              // LLR-Ref: 020  
    559              // setup the data at the desired location.
    560              else{
    561                  *(ctrlBlock->iicBuffer+index) = data;
    562                  ctrlBlock->iicDataTx = len;
    563                  retVal = OK;        
    564              }    
    565              return retVal;
    566          }
    567          
    568          /*---------------------------------------------------------------------------*/
    569          /** \brief <b>ATA_iicGetData_C</b>
    570              This routine performs the setup of the IIC related buffer holding the data
    571              to be TXed or RXed.
    572          
    573          \param[in,out]  ctrlBlock        Pointer to an IIC ctrl structure
    574          \param[out]     data             Received data
    575          \param[in]      index            Index of place data will put into the pointed buffer
    576          
    577          \return     OK on success, FAIL on failure
    578          
    579          \StackUsageInBytes{XXX}
    580          
    581          \image html ATA_iicGetData_C.png
    582          
    583          \internal
    584          \li 010: Check if read out of data is valid, IF NOT raise an error condition
    585          \li 020: IF VALID read the data at the desired location    
    586          
    587          \Derived{No}
    588          
    589          \Rationale{N/A}
    590          
    591          \Traceability{Primus2P-2431,Primus2P-2477}
    592          \endinternal
    593          \n
    594          */
    595          /*---------------------------------------------------------------------------*/
    596          UINT8FUNC ATA_iicGetData_C(uint8_t index, sIicCtrlBlock* ctrlBlock, uint8_t* data)
    597          {   
    598              uint8_t retVal;
    599              retVal = FAIL;
    600              *data = *(ctrlBlock->iicBuffer+index);
    601              // LLR-Ref: 010 
    602              // Check if reading out of data is valid, IF NOT raise an error condition
    603              // Error is raised in case of an ongoing IIC transaction or the index is out of 
    604              // the range of the linked array.    
    605              if(((ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING))||(index>=ctrlBlock->iicBufLen)){                        
    606                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    607              }
    608              // LLR-Ref: 020  
    609              // Read the data at the desired location.
    610              else{
    611                  retVal = OK;
    612              }    
    613              return retVal;
    614          }
    615          
    616          /*---------------------------------------------------------------------------*/
    617          /** \brief <b>ATA_iicSetBuffer_C</b>
    618              This routine performs the setup of the IIC related buffer holding the data
    619              to be TXed or RXed.
    620          
    621          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    622          \param[in]      ptrSrc          Source data buffer
    623          \param[in]      len             Amount of data to be copied
    624          
    625          \return     OK on success, FAIL on failure
    626          
    627          \StackUsageInBytes{XXX}
    628          
    629          \image html ATA_iicSetBuffer_C.png
    630          
    631          \internal
    632          \li 010: Check if setup of the buffer data is valid, 
    633                   IF NOT raise an error condition
    634          \li 015: Data copying loop
    635          \li 020: IF VALID setup the buffer data     
    636          
    637          \Derived{No}
    638          
    639          \Rationale{N/A}
    640          
    641          \Traceability{Primus2P-2431,Primus2P-2477}
    642          \endinternal
    643          \n
    644          */
    645          /*---------------------------------------------------------------------------*/
    646          UINT8FUNC ATA_iicSetBuffer_C(uint8_t* ptrSrc, uint8_t len, sIicCtrlBlock* ctrlBlock)
    647          {   
    648              uint8_t retVal;
    649              uint8_t i;
    650              retVal = FAIL;
    651              // LLR-Ref: 010   
    652              // Check if setup of buffer data is valid, IF NOT raise an error condition
    653              // Data is setup in case of no ongoing IIC transaction or the index is in 
    654              // the range of the linked array.    
    655              if(!((ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING)||(len>ctrlBlock->iicBufLen))){        
    656                  // LLR-Ref: 015
    657                  // Copy Loop for the desired data.
    658                  for(i=0;i<len;i++){
    659                      *(ctrlBlock->iicBuffer+i) = *ptrSrc++;
    660                  }        
    661                  ctrlBlock->iicDataTx = len;
    662                  retVal = OK;
    663              }
    664              // LLR-Ref: 020
    665              // Raise the Error flag.
    666              else{
    667                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    668              }    
    669              return retVal;
    670          }
    671          
    672          /*---------------------------------------------------------------------------*/
    673          /** \brief <b>ATA_iicGetBuffer_C</b>
    674              This routine performs the setup of the IIC related buffer holding the data
    675              to be TXed or RXed.
    676          
    677          \param[in,out]  ctrlBlock       Pointer to an IIC ctrl structure
    678          \param[out]     ptrDes          Destination data buffer
    679          \param[in]      len             Amount of data to be copied
    680          
    681          \return     OK on success, FAIL on failure
    682          
    683          \StackUsageInBytes{XXX}
    684          
    685          \image html ATA_iicGetBuffer_C.png
    686          
    687          \internal
    688          \li 010: Check if read out of the buffer is valid, 
    689                   IF NOT raise an error condition
    690          \li 015: Data copying loop
    691          \li 020: IF VALID read the given amount of data of the buffer    
    692          
    693          \Derived{No}
    694          
    695          \Rationale{N/A}
    696          
    697          \Traceability{Primus2P-2431,Primus2P-2477}
    698          \endinternal
    699          \n
    700          */
    701          /*---------------------------------------------------------------------------*/
    702          UINT8FUNC ATA_iicGetBuffer_C(uint8_t* ptrDes, uint8_t len, sIicCtrlBlock* ctrlBlock)
    703          {   
    704              uint8_t retVal;
    705              uint8_t i;
    706              retVal = FAIL;
    707              // LLR-Ref: 010 
    708              // Check if reading of buffer data is valid, IF NOT raise an error condition
    709              // Data is read in case of no ongoing IIC transaction or the index is in 
    710              // the range of the linked array.    
    711              if(!((ctrlBlock->iicStatus&BM_IICTRANSACTIONONGOING)||(len>ctrlBlock->iicBufLen))){        
    712                  // LLR-Ref: 015 
    713                  // Copy Loop for the desired data.
    714                  for(i=0;i<len;i++){
    715                      *ptrDes++ = *(ctrlBlock->iicBuffer+i);
    716                  }        
    717                  retVal = OK;
    718              }
    719              // LLR-Ref: 020 
    720              // Raise the Error flag.
    721              else{
    722                  ctrlBlock->iicStatus |= BM_CONFERRORIIC;
    723              }    
    724              return retVal;
    725          }
    726          
    727          /*---------------------------------------------------------------------------*/
    728          /** \brief <b>ATA_iicServeIsr_C</b>
    729              This routine performs the polling of the IIC irq flag in case the IIC 
    730              is used in non IRQ mode.
    731          
    732          \param      N/A
    733          
    734          \return     OK in case IRQ was pending, FAIL in case no IRQ was pending
    735          
    736          \StackUsageInBytes{XXX}
    737          
    738          \image html ATA_iicServeIsr_C.png
    739          
    740          \internal
    741          \li 010: Check if IIC - IRQ flag is set, IF serve it by calling function
    742                   ::twiByteCompleteHandler_ASM
    743          \li 020: ELSE return, indicating nothing has been done
    744          
    745          \Derived{No}
    746          
    747          \Rationale{N/A}
    748          
    749          \Traceability{Primus2P-2426,Primus2P-2427,Primus2P-2428,Primus2P-2429,Primus2P-2430,Primus2P-2477,Primus2P-2501}
    750          \endinternal
    751          \n
    752          */
    753          /*---------------------------------------------------------------------------*/
    754          UINT8FUNC ATA_iicServeIsr_C(void)
    755          {  
    756              uint8_t retVal;
    757              // LLR-Ref: 010 
    758              // Check if IIC - IRQ flag is set, IF serve it!
    759              if(I2CR&BM_I2INT){
                        ^
Error[Pe020]: identifier "I2CR" is undefined

      if(I2CR&BM_I2INT){
              ^
"C:\Users\grueter\Documents\CDB_\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2_Gen2_Merge\firmware\iic\src\iic.c",759  Error[Pe020]: 
          identifier "BM_I2INT" is undefined
    760                  twiByteCompleteHandler_ASM();
    761                  retVal = OK;
    762              }
    763              // LLR-Ref: 020  
    764              // ELSE return, indicating nothing has been done.
    765              else{
    766                  retVal = FAIL;
    767              }
    768              return retVal;
    769          }

Errors: 24
Warnings: none
