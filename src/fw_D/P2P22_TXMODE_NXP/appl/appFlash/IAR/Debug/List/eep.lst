###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.21.1.50603 for Atmel AVR        29/Jan/2014  11:07:38 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\AT #
#                    AK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\firmwar #
#                    e\eep\src\eep.c                                          #
#    Command line =  C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\AT #
#                    AK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\firmwar #
#                    e\eep\src\eep.c -v3 --enhanced_core -ms -o               #
#                    C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\AT #
#                    AK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\appl\ap #
#                    pFlash\IAR\Debug\Obj\ -lCN C:\Users\grueter\Documents\CD #
#                    B\Apps\SW_Lib\Car_Access\ATAK51003-V3_P2P_Demo\branch_LF #
#                    rssi_new\P2P_Demo01\appl\appFlash\IAR\Debug\List\ -lA    #
#                    C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\AT #
#                    AK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\appl\ap #
#                    pFlash\IAR\Debug\List\ --no_cse --no_inline              #
#                    --no_code_motion --no_cross_call --no_clustering         #
#                    --no_tbaa --debug --64k_flash -DENABLE_BIT_DEFINITIONS   #
#                    -e --eeprom_size 1152 --clib -Ohz                        #
#    List file    =  C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\AT #
#                    AK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\appl\ap #
#                    pFlash\IAR\Debug\List\eep.lst                            #
#    Object file  =  C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\AT #
#                    AK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\appl\ap #
#                    pFlash\IAR\Debug\Obj\eep.r90                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\grueter\Documents\CDB\Apps\SW_Lib\Car_Access\ATAK51003-V3_P2P_Demo\branch_LFrssi_new\P2P_Demo01\firmware\eep\src\eep.c
      1          /* *C**************************************************************************
      2            Use of this software is subject to Atmel's Software License Agreement.
      3          -------------------------------------------------------------------------------
      4            $URL: http://svnservulm.corp.atmel.com/svn/CDB/Apps/SW_Lib/Car_Access/CARS_GEN2/ATAB5702A/Branches/P2P22_TXMODE_NXP/appl/appFlash/IAR/Debug/List/eep.lst $
      5            $LastChangedRevision: 328482 $
      6            $LastChangedDate: 2015-07-22 13:17:23 -0600 (Wed, 22 Jul 2015) $
      7            $LastChangedBy: grueter $
      8          -------------------------------------------------------------------------------
      9            Project:      ATA5700
     10            Target MCU:   ATA5700
     11            Compiler:     IAR C/C++ Compiler for AVR 6.3.18.2236
     12          -------------------------------------------------------------------------------
     13          
     14          ******************************************************************************
     15          * Copyright 2011, Atmel Automotive GmbH                                       *
     16          *                                                                             *
     17          * This software is owned by the Atmel Automotive GmbH                         *
     18          * and is protected by and subject to worldwide patent protection.             *
     19          * Atmel hereby grants to licensee a personal,                                 *
     20          * non-exclusive, non-transferable license to copy, use, modify, create        *
     21          * derivative works of, and compile the Atmel Source Code and derivative       *
     22          * works for the sole purpose of creating custom software in support of        *
     23          * licensee product to be used only in conjunction with a Atmel integrated     *
     24          * circuit as specified in the applicable agreement. Any reproduction,         *
     25          * modification, translation, compilation, or representation of this           *
     26          * software except as specified above is prohibited without the express        *
     27          * written permission of Atmel.                                                *
     28          *                                                                             *
     29          * Disclaimer: ATMEL MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,         *
     30          * WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
     31          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
     32          * Atmel reserves the right to make changes without further notice to the      *
     33          * materials described herein. Atmel does not assume any liability arising     *
     34          * out of the application or use of any product or circuit described herein.   *
     35          * Atmel does not authorize its products for use as critical components in     *
     36          * life-support systems where a malfunction or failure may reasonably be       *
     37          * expected to result in significant injury to the user. The inclusion of      *
     38          * Atmel products in a life-support systems application implies that the       *
     39          * manufacturer assumes all risk of such use and in doing so indemnifies       *
     40          * Atmel against all charges.                                                  *
     41          *                                                                             *
     42          * Use may be limited by and subject to the applicable Atmel software          *
     43          * license agreement.                                                          *
     44          ******************************************************************************/
     45          /** \file eep.c
     46          */
     47          
     48          /*===========================================================================*/
     49          /*  INCLUDES                                                                 */
     50          /*===========================================================================*/
     51          #include "eep.h"

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEARL
   \                     _A_EEARL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x42
   \   union <unnamed> volatile __io _A_EEARH
   \                     _A_EEARH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xfc
   \   union <unnamed> volatile __io _A_TRCIDL
   \                     _A_TRCIDL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xfd
   \   union <unnamed> volatile __io _A_TRCIDH
   \                     _A_TRCIDH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xff
   \   union <unnamed> volatile __io _A_TRCDR
   \                     _A_TRCDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x159
   \   union <unnamed> volatile __ext_io _A_EECR2
   \                     _A_EECR2:
   \   00000000                      DS8 1
     52          
     53          /*===========================================================================*/
     54          /*  DEFINES                                                                  */
     55          /*===========================================================================*/
     56          
     57          #define EEPROM_START_ADD                    0x0000U
     58          #define EEPROM_XROW_END_ADD                 0x08FFU
     59          #define EEPROM_XROW_BEGIN_ADD               0x0880U
     60          #define EEPROM_FAC_LOCK_END_ADD             0x087FU
     61          #define EEPROM_FAC_LOCK_BEGIN_ADD           0x0800U
     62          #define EEPROM_USER_END_ADD                 0x07FFU
     63          #define AP0_START_ADD                       0x0780U
     64          
     65          /* Start of the Access Right Map */
     66          #define EEP_MEM_ACCESS_MAP_ADD              0x0750U
     67          
     68          /* Byte [29] of the Access Right Map holds the access rights for the map
     69             itself */
     70          #define EEP_MEM_ACCESS_MAP_SECTION_ADD      0x076DU
     71          
     72          #define BM_EEP_SECTION_ROW_0_WR_ACC         0x40U
     73          #define BM_EEP_SECTION_ROW_1_WR_ACC         0x10U
     74          #define BM_EEP_SECTION_ROW_2_WR_ACC         0x04U
     75          #define BM_EEP_SECTION_ROW_3_WR_ACC         0x01U
     76          
     77          #define BM_EEP_SECTION_ROW_0_RD_ACC         0x80U
     78          #define BM_EEP_SECTION_ROW_1_RD_ACC         0x20U
     79          #define BM_EEP_SECTION_ROW_2_RD_ACC         0x08U
     80          #define BM_EEP_SECTION_ROW_3_RD_ACC         0x02U
     81          
     82          #define EEP_BYTES_PER_PAGE                  0x10U
     83          
     84          /* Access Map (byte 0x076D goes from Row 1 to 3. */
     85          #define EEP_LOWER_MEM_ACCESS_MAP_SECTION    0x01U
     86          #define EEP_MIDDL_MEM_ACCESS_MAP_SECTION    0x02U
     87          #define EEP_UPPER_MEM_ACCESS_MAP_SECTION    0x03U
     88          
     89          
     90          #define EEP_EEPR_DISABLE_ALL                0x00U
     91          
     92          /*===========================================================================*/
     93          /*  Modul Globals                                                            */
     94          /*===========================================================================*/
     95          
     96          /** \brief <b>g_sEepFacLockRfFrontend</b>
     97              contains the Xrow EEPROM setting for RF TX Module.
     98          */
     99          #pragma location = ".eep_xrow_RfFrontendCalibValues"

   \                                 In  segment .eep_xrow_RfFrontendCalibValues, align 1, keep-with-next, root
    100          __root __no_init sEEPromFacLockRfTx g_sEepFacLockRfFrontend;
   \                     g_sEepFacLockRfFrontend:
   \   00000000                      DS8 6
    101          
    102          
    103          /** \brief <b>eepXrowUniqueId</b>
    104              contains the unique ID of the chip.
    105          */
    106          #pragma location = ".eep_xrow_UniqueId"

   \                                 In  segment .eep_xrow_UniqueId, align 1, keep-with-next, root
    107          __root __no_init uint8_t eepXrowUniqueId[EEP_XROW_UID_SIZE];
   \                     eepXrowUniqueId:
   \   00000000                      DS8 4
    108          
    109          
    110          /** \brief <b>eepLfReceiverCalibration</b>
    111              contains the LF decoder settings.
    112          */
    113          #pragma location = ".eep_xrow_LfDecoderSettings"

   \                                 In  segment .eep_xrow_LfDecoderSettings, align 1, keep-with-next, root
    114          __root __no_init sEEPromLfDecoderSettings eepLfDecoderSettings;
   \                     eepLfDecoderSettings:
   \   00000000                      DS8 11
    115          
    116          /** \brief <b>eepTransponderCalibValues</b>
    117              contains the TP calibration value for TPCALR11 and TPCALR12.
    118          */
    119          #pragma location = ".eep_xrow_TransponderCalibValues"

   \                                 In  segment .eep_xrow_TransponderCalibValues, align 1, keep-with-next, root
    120          __root __no_init uint8_t eepTransponderCalibValues[2];
   \                     eepTransponderCalibValues:
   \   00000000                      DS8 2
    121          
    122          
    123          /** \brief <b>eepLfReceiverCalibration</b>
    124              contains the LF calibration values.
    125          */
    126          #pragma location = ".eep_xrow_LfReceiverCalibRegister"

   \                                 In  segment .eep_xrow_LfReceiverCalibRegister, align 1, keep-with-next, root
    127          __root __no_init sEEPromLfReceiverCalibration eepLfReceiverCalibration;
   \                     eepLfReceiverCalibration:
   \   00000000                      DS8 40
    128          
    129          
    130          /** \brief <b>eepSrcCalibration</b>
    131              contains the SRC calibration value.
    132          */
    133          #pragma location = ".eep_xrow_SrcCalibration"

   \                                 In  segment .eep_xrow_SrcCalibration, align 1, keep-with-next, root
    134          __root __no_init sEEPromSrcCalibration eepSrcCalibration;
   \                     eepSrcCalibration:
   \   00000000                      DS8 1
    135          
    136          
    137          /** \brief <b>eepSrcTemperatureCompensation</b>
    138              contains the SRC temperature compensation value.
    139          */
    140          #pragma location = ".eep_xrow_SrcTemperatureCompensation"

   \                                 In  segment .eep_xrow_SrcTemperatureCompensation, align 1, keep-with-next, root
    141          __root __no_init sEEPromSrcTemperatureCompensation eepSrcTemperatureCompensation;
   \                     eepSrcTemperatureCompensation:
   \   00000000                      DS8 1
    142          
    143          
    144          /** \brief <b>eepMvccSettlingTime</b>
    145              contains the value for MVCC settling time
    146          */
    147          #pragma location = ".eep_xrow_MvccSettlingTime"

   \                                 In  segment .eep_xrow_MvccSettlingTime, align 1, keep-with-next, root
    148          __root __no_init sEEPromMvccSettlingTime eepMvccSettlingTime;
   \                     eepMvccSettlingTime:
   \   00000000                      DS8 1
    149          
    150          
    151          /** \brief <b>eepSecretKeyOne</b>
    152              contains Secret Key One with two additional backup copies
    153          */
    154          #pragma location = ".eep_SecretKey_KeyOneSection"

   \                                 In  segment .eep_SecretKey_KeyOneSection, align 1, keep-with-next, root
    155          __root __no_init sEepSecretKey eepSecretKeyOne[EEP_NUMBER_OF_SECRET_KEYS];
   \                     eepSecretKeyOne:
   \   00000000                      DS8 48
    156          
    157          /** \brief <b>eepSecretKeyTwo</b>
    158              contains Secret Key Two with two additional backup copies
    159          */
    160          #pragma location = ".eep_SecretKey_KeyTwoSection"

   \                                 In  segment .eep_SecretKey_KeyTwoSection, align 1, keep-with-next, root
    161          __root __no_init sEepSecretKey eepSecretKeyTwo[EEP_NUMBER_OF_SECRET_KEYS];
   \                     eepSecretKeyTwo:
   \   00000000                      DS8 48
    162          
    163          /** \brief <b>eepXrowRfFrontend</b>
    164              contains the Xrow EEPROM setting for RF TX Module.
    165          */
    166          #pragma location = ".eep_xrow_LfRssiSettings"

   \                                 In  segment .eep_xrow_LfRssiSettings, align 1, keep-with-next, root
    167          __root __no_init sEEPromLfRssiSettings eepLfRssiSettings;
   \                     eepLfRssiSettings:
   \   00000000                      DS8 10
    168          
    169          /** \brief <b>eepRfTxRcsc</b>
    170              is the Rolling Code Sequence Counter value in EEPROM.
    171          */
    172          #pragma location = ".eep_RfTx_RollingCodeSequenceCounter"

   \                                 In  segment .eep_RfTx_RollingCodeSequenceCounter, align 1, keep-with-next, root
    173          __root __no_init uint8_t eepRfTxRcc[EEP_RFRCC_SIZE];
   \                     eepRfTxRcc:
   \   00000000                      DS8 4
    174          
    175          /*===========================================================================*/
    176          /*  IMPLEMENTATION                                                           */
    177          /*===========================================================================*/
    178          
    179          /*---------------------------------------------------------------------------*/
    180          /** \brief <b>ATA_eepChangeAccessRights_C</b>
    181              shall change the EEPROM access rights of a given EEPROM section in
    182              accordance with the applicable EEPROM Access Right Map.
    183              An EEPROM Access Right Map contains 32 EEPROM sections, each comprising
    184              four EEPROM row access right values.
    185              Due to performance reasons, one can change all access rights of one EEPROM
    186              section.\n
    187              Prerequisite:
    188              The enabling of read/write access for sections AP0, AP1, AP2 and AP3 in
    189              register EEPR needs to be handled by the Application SW in order
    190              for this function to work as specified.
    191          
    192          \param[in] uEepSection          EEPROM section (Byte number of Access Right Map)
    193                                          for which the access rights shall be changed
    194          \param[in] uAccessRightValue    New access right value for the given EEPROM section
    195          \param[in] uAccessRightMask     Mask to only update a dedicated part of the access
    196                                          rights of the given EEPROM section
    197          
    198          \return    Status of the performed EEPROM operation (::eEepErrorCode)
    199          
    200          \StackUsageInBytes{XXX}
    201          
    202          \image html ATA_eepChangeAccessRights_C.png
    203          
    204          \internal
    205          \li 005: Update HW Trace Unit with specific function information\n\n
    206                   Technical background:
    207                   64 bytes are covered by one Access Right Map byte,
    208                   4 rows per access byte with 2 bits for each row (== 8 bits for 4 rows).
    209                   16 bytes per row, 4 rows per access byte, Row = 0..3\n\n
    210                   IF parameter "uEepSection" in not within the specified range
    211                    [0x0000 to 0x08FF],
    212                   THEN
    213          \li 010:   Set "return" to EEC_ADDR_OUT_OF_RANGE to indicate that the
    214                     EEPROM Access Right Map section information was invalid.\n
    215                   ELSE
    216          \li 020:   Wait for any previous EEPROM access to be finished by
    217                     checking bit "NVMBSY" in register EECR being set to 0.
    218          
    219          \li 030:   Disable all interrupts to allow for an atomic execution of an EEPROM
    220                     change of access rights.
    221          
    222          \li 040:   Get the EEPROM Access Right Map byte corresponding to the
    223                     EEPROM Access Right Map itself by calling the function macro
    224                     ::ATA_FM_EEP_READ_BYTE_C() to check whether the EEPROM Access Right
    225                     Map is allowed to be changed.
    226              
    227          \li 050:   IF after the EEPROM read access to retrieve the access rights, an
    228                      uncorrectable EEPROM error was detected, indicated by
    229                      bit "E2FF" in register EECR2 being set 1,
    230                     THEN
    231                       Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    232                        that an EEPROM error correction occured and further information
    233                        could be retrieved by reading the EEPROM syndrome value EESYN0 to
    234                        EESYN3 in register EEST.
    235          
    236                     ELSE
    237          \li 060:     Retrieve the access row (two bit defining the access rights for a
    238                       dedicated EEPROM page) within the EEPROM Access Right Map byte
    239                       corresponding to parameter "uEepSection".
    240          
    241          \li 070:     IF the EEPROM section indicated by "uEepSection" is write
    242                        protected,
    243                       THEN
    244                         Set "return" to EEC_ADDR_LOCKED_FOR_WRITING to indicate that
    245                         this EEPROM Access Right Map section cannot be changed.
    246          
    247          \li 080:     ELSE
    248                         Get the EEPROM Access Right Map byte corresponding to the
    249                         given EEPROM Access Right Map section "uEepSection" by calling
    250                         the function macro ATA_FM_EEP_READ_BYTE_C().
    251          
    252          \li 085:       Reset both EEPROM error indications by setting bits "E2CF" and 
    253                          "E2FF" in register EECR2 to 1 in order to not have stale flags
    254                          when executing a subsequent EEPROM read call.
    255          
    256          \li 090:       IF after the EEPROM read access to retrieve the access rights,
    257                          an uncorrectable EEPROM error was detected, indicated by
    258                          bit "E2FF" in register EECR2 being set 1,
    259                         THEN
    260                           Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    261                            that an EEPROM error correction occured and further
    262                            information could be retrieved by reading the EEPROM syndrome
    263                            value EESYN0 to EESYN3 in register EEST.
    264          
    265          \li 100:       ELSE
    266                           Apply the given access rights mask "uAccessRightMask" to the
    267                            new access right value "uAccessRightValue".
    268          
    269          \li 110:         IF at least one WRITE lock is revoked in one of the access rows
    270                            within the access right byte corresponding to "uEepSection",
    271                           THEN
    272                             Set "return" to EEC_INVALID_ACCESS_RIGHT_VALUE to indicate
    273                             that the new access right value "uAccessRightValue" together
    274                             with the applicable mask "uAccessRightMask" for EEPROM
    275                             section "uEepSection" is invalid.
    276                           ENDIF
    277                         ENDIF
    278          
    279          \li 120:       IF "return" is set to EEC_NO_ERROR, indicating that the intended
    280                          change of access rights is valid,
    281                         THEN
    282                           Merge the existing access rights for EEPROM section
    283                            "uEepSection" with the new access rights being composed of
    284                            "uAccessRightValue" and its mask "uAccessRightMask", AND
    285                           execute the EEPROM change access rights request by calling the
    286                            function macro ::ATA_FM_EEP_WRITE_BYTE_C() with the newly
    287                            computed access right value.
    288                         ENDIF
    289                       ENDIF
    290                     ENDIF
    291          
    292          \li 130:   Restore SREG status (namely the global interrupt flag), 
    293                     since the critical section is finished.
    294          
    295                   ENDIF
    296          
    297          \li 135: Reset both EEPROM error indications by setting bits "E2CF" and 
    298                    "E2FF" in register EECR2 to 1 in order to not have stale flags
    299                    when executing a subsequent EEPROM read call.
    300          
    301          \li 140: Return the function's error code to the calling function.
    302          
    303          \Derived{No}
    304          
    305          \Rationale{N/A}
    306          
    307          \Traceability{Primus2P-891}
    308          \endinternal
    309          \n
    310          */
    311          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    312          __root eEepErrorCode ATA_eepChangeAccessRights_C(uint8_t uEepSection, uint8_t uAccessRightValue, uint8_t uAccessRightMask)
   \                     ATA_eepChangeAccessRights_C:
    313          {
   \   00000000   2F60               MOV     R22, R16
   \   00000002   2F51               MOV     R21, R17
   \   00000004   2F72               MOV     R23, R18
    314              uint8_t bSreg = SREG;
   \   00000006   B60F               IN      R0, 0x3F
    315            
    316              /* Variable to hold the function's return value. */
    317              eEepErrorCode retValue = EEC_NO_ERROR;
   \   00000008   E010               LDI     R17, 0
    318          
    319              /* Variable to hold the actual row info for EEPROM operations */
    320              uint8_t uAccessRowInByte;
    321          
    322              /* Variable to hold the actual access right value of the EEPROM Access Right
    323                 Map. */
    324              uint8_t uAccessRightAddressValue;
    325          
    326              /* Variable to hold the actual access right value of the given EEPROM Access
    327                 Right Map section. */
    328              uint8_t uSectionByte;
    329          
    330              /* LLR-Ref: 005 */
    331              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepChangeAccessRights_C, uEepSection);
   \   0000000A   B70F               IN      R16, 0x3F
   \   0000000C   94F8               CLI
   \   0000000E   9360....           STS     _A_TRCDR, R22
   \   00000012   ....               LDI     R18, LOW(ATA_eepChangeAccessRights_C/2)
   \   00000014   9320....           STS     _A_TRCIDL, R18
   \   00000018   ....               LDI     R18, (ATA_eepChangeAccessRights_C/2) >> 8
   \   0000001A   9320....           STS     _A_TRCIDH, R18
   \   0000001E   BF0F               OUT     0x3F, R16
    332          
    333              if ( uEepSection > (EEPROM_XROW_END_ADD >> 6) )
   \   00000020   3264               CPI     R22, 36
   \   00000022   F010               BRCS    ??ATA_eepChangeAccessRights_C_0
    334              {
    335                  /* LLR-Ref: 010 */
    336                  retValue = EEC_ADDR_OUT_OF_RANGE;
   \   00000024   E013               LDI     R17, 3
   \   00000026   C05E               RJMP    ??ATA_eepChangeAccessRights_C_1
    337              }
    338              else
    339              {
    340                  /* LLR-Ref: 020 */
    341                  while(EECR & BM_NVMBSY){}
   \                     ??ATA_eepChangeAccessRights_C_0:
   \   00000028   99FF               SBIC    0x1F, 0x07
   \   0000002A   CFFE               RJMP    ??ATA_eepChangeAccessRights_C_0
    342          
    343                  /* LLR-Ref: 030 */
    344                  __disable_interrupt();
   \   0000002C   94F8               CLI
    345          
    346                  /* LLR-Ref: 040 */
    347                  ATA_FM_EEP_READ_BYTE_C (EEP_MEM_ACCESS_MAP_SECTION_ADD, uAccessRightAddressValue)
   \   0000002E   E007               LDI     R16, 7
   \   00000030   BD02               OUT     0x22, R16
   \   00000032   E60D               LDI     R16, 109
   \   00000034   BD01               OUT     0x21, R16
   \   00000036   9AF8               SBI     0x1F, 0x00
   \   00000038   B520               IN      R18, 0x20
    348          
    349                  if ( EECR2 & BM_E2FF )
   \   0000003A   9100....           LDS     R16, _A_EECR2
   \   0000003E   FD06               SBRC    R16, 6
   \   00000040   C022               RJMP    ??ATA_eepChangeAccessRights_C_2
    350                  {
    351                      /* LLR-Ref: 050 */
    352                      retValue = EEC_ERROR_CORRECTION_OCCURED;
    353                  }
    354                  else
    355                  {
    356                      /* LLR-Ref: 060 */
    357                      if ( uEepSection < EEP_BYTES_PER_PAGE )
   \   00000042   3160               CPI     R22, 16
   \   00000044   F410               BRCC    ??ATA_eepChangeAccessRights_C_3
    358                      {
    359                          uAccessRowInByte = EEP_LOWER_MEM_ACCESS_MAP_SECTION;
   \   00000046   E041               LDI     R20, 1
   \   00000048   C005               RJMP    ??ATA_eepChangeAccessRights_C_4
    360                      }
    361                      else if ( uEepSection < 2*EEP_BYTES_PER_PAGE )
   \                     ??ATA_eepChangeAccessRights_C_3:
   \   0000004A   3260               CPI     R22, 32
   \   0000004C   F410               BRCC    ??ATA_eepChangeAccessRights_C_5
    362                      {
    363                          uAccessRowInByte = EEP_MIDDL_MEM_ACCESS_MAP_SECTION;
   \   0000004E   E042               LDI     R20, 2
   \   00000050   C001               RJMP    ??ATA_eepChangeAccessRights_C_4
    364                      }
    365                      else
    366                      {
    367                          uAccessRowInByte = EEP_UPPER_MEM_ACCESS_MAP_SECTION;
   \                     ??ATA_eepChangeAccessRights_C_5:
   \   00000052   E043               LDI     R20, 3
    368                      }
    369          
    370                      /* LLR-Ref: 070 */
    371                      if ( (uAccessRightAddressValue & (BM_EEP_SECTION_ROW_0_WR_ACC >> (uAccessRowInByte * 2))) == FALSE  )
   \                     ??ATA_eepChangeAccessRights_C_4:
   \   00000054   0F44               LSL     R20
   \   00000056   E400               LDI     R16, 64
   \   00000058   ........           CALL    ?UC_SHR_L01
   \   0000005C   2320               AND     R18, R16
   \   0000005E   F411               BRNE    ??ATA_eepChangeAccessRights_C_6
    372                      {
    373                          retValue = EEC_ADDR_LOCKED_FOR_WRITING;
   \   00000060   E012               LDI     R17, 2
   \   00000062   C03F               RJMP    ??ATA_eepChangeAccessRights_C_7
    374                      }
    375                      else
    376                      {
    377                          /* LLR-Ref: 085: Always clear both EEPROM error flags. */
    378                          EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepChangeAccessRights_C_6:
   \   00000064   9100....           LDS     R16, _A_EECR2
   \   00000068   6C00               ORI     R16, 0xC0
   \   0000006A   9300....           STS     _A_EECR2, R16
    379                        
    380                          /* LLR-Ref: 080 */
    381                          ATA_FM_EEP_READ_BYTE_C (EEP_MEM_ACCESS_MAP_ADD + uEepSection, uSectionByte)
   \   0000006E   2F26               MOV     R18, R22
   \   00000070   E030               LDI     R19, 0
   \   00000072   5B20               SUBI    R18, 176
   \   00000074   4F38               SBCI    R19, 248
   \   00000076   BD32               OUT     0x22, R19
   \   00000078   BD21               OUT     0x21, R18
   \   0000007A   9AF8               SBI     0x1F, 0x00
   \   0000007C   B540               IN      R20, 0x20
    382          
    383                          if ( EECR2 & BM_E2FF )
   \   0000007E   9100....           LDS     R16, _A_EECR2
   \   00000082   FF06               SBRS    R16, 6
   \   00000084   C002               RJMP    ??ATA_eepChangeAccessRights_C_8
    384                          {
    385                              /* LLR-Ref: 090 */
    386                              retValue = EEC_ERROR_CORRECTION_OCCURED;
   \                     ??ATA_eepChangeAccessRights_C_2:
   \   00000086   E014               LDI     R17, 4
   \   00000088   C02C               RJMP    ??ATA_eepChangeAccessRights_C_7
    387                          }
    388                          else
    389                          {
    390                              /* LLR-Ref: 100 */
    391                              uint8_t uSectionByteMasked = (uSectionByte & uAccessRightMask);
   \                     ??ATA_eepChangeAccessRights_C_8:
   \   0000008A   2F34               MOV     R19, R20
   \   0000008C   2337               AND     R19, R23
    392                              uAccessRightValue &= uAccessRightMask;
   \   0000008E   2357               AND     R21, R23
    393          
    394                              /* LLR-Ref: 110 */
    395                              if ( (uSectionByteMasked & BM_EEP_SECTION_ROW_0_WR_ACC) <
    396                                   (uAccessRightValue  & BM_EEP_SECTION_ROW_0_WR_ACC)
    397                                 )
   \   00000090   2F23               MOV     R18, R19
   \   00000092   7420               ANDI    R18, 0x40
   \   00000094   2F05               MOV     R16, R21
   \   00000096   7400               ANDI    R16, 0x40
   \   00000098   1720               CP      R18, R16
   \   0000009A   F090               BRCS    ??ATA_eepChangeAccessRights_C_9
    398                              {
    399                                  retValue = EEC_INVALID_ACCESS_RIGHT_VALUE;
    400                              }
    401                              else if ( (uSectionByteMasked & BM_EEP_SECTION_ROW_1_WR_ACC) <
    402                                        (uAccessRightValue  & BM_EEP_SECTION_ROW_1_WR_ACC)
    403                                 )
   \   0000009C   2F23               MOV     R18, R19
   \   0000009E   7120               ANDI    R18, 0x10
   \   000000A0   2F05               MOV     R16, R21
   \   000000A2   7100               ANDI    R16, 0x10
   \   000000A4   1720               CP      R18, R16
   \   000000A6   F060               BRCS    ??ATA_eepChangeAccessRights_C_9
    404                              {
    405                                  retValue = EEC_INVALID_ACCESS_RIGHT_VALUE;
    406                              }
    407                              else if ( (uSectionByteMasked & BM_EEP_SECTION_ROW_2_WR_ACC) <
    408                                        (uAccessRightValue  & BM_EEP_SECTION_ROW_2_WR_ACC)
    409                                 )
   \   000000A8   2F23               MOV     R18, R19
   \   000000AA   7024               ANDI    R18, 0x04
   \   000000AC   2F05               MOV     R16, R21
   \   000000AE   7004               ANDI    R16, 0x04
   \   000000B0   1720               CP      R18, R16
   \   000000B2   F030               BRCS    ??ATA_eepChangeAccessRights_C_9
    410                              {
    411                                  retValue = EEC_INVALID_ACCESS_RIGHT_VALUE;
    412                              }
    413                              else if ( (uSectionByteMasked & BM_EEP_SECTION_ROW_3_WR_ACC) <
    414                                        (uAccessRightValue  & BM_EEP_SECTION_ROW_3_WR_ACC)
    415                                 )
   \   000000B4   2F03               MOV     R16, R19
   \   000000B6   7001               ANDI    R16, 0x01
   \   000000B8   2F25               MOV     R18, R21
   \   000000BA   7021               ANDI    R18, 0x01
   \   000000BC   1702               CP      R16, R18
   \   000000BE   F410               BRCC    ??ATA_eepChangeAccessRights_C_10
    416                              {
    417                                  retValue = EEC_INVALID_ACCESS_RIGHT_VALUE;
   \                     ??ATA_eepChangeAccessRights_C_9:
   \   000000C0   E015               LDI     R17, 5
   \   000000C2   C00F               RJMP    ??ATA_eepChangeAccessRights_C_7
    418                              }
    419                              else
    420                              {
    421                                  /* Do nothing */
    422                              }
    423                          }
    424          
    425                          if ( retValue == EEC_NO_ERROR )
    426                          {
    427                              /* LLR-Ref: 120 */
    428                              uAccessRightValue |= (uSectionByte & ~uAccessRightMask);
    429                              ATA_FM_EEP_WRITE_BYTE_C (EEP_MEM_ACCESS_MAP_ADD + uEepSection, uAccessRightValue)
   \                     ??ATA_eepChangeAccessRights_C_10:
   \   000000C4   2F26               MOV     R18, R22
   \   000000C6   E030               LDI     R19, 0
   \   000000C8   5B20               SUBI    R18, 176
   \   000000CA   4F38               SBCI    R19, 248
   \   000000CC   BD32               OUT     0x22, R19
   \   000000CE   BD21               OUT     0x21, R18
   \   000000D0   9570               COM     R23
   \   000000D2   2347               AND     R20, R23
   \   000000D4   2B54               OR      R21, R20
   \   000000D6   BD50               OUT     0x20, R21
   \   000000D8   B30F               IN      R16, 0x1F
   \   000000DA   7C0F               ANDI    R16, 0xCF
   \   000000DC   BB0F               OUT     0x1F, R16
   \   000000DE   9AFA               SBI     0x1F, 0x02
   \   000000E0   9AF9               SBI     0x1F, 0x01
    430                          }
    431                      }
    432                  }
    433          
    434                  /* LLR-Ref: 130 */
    435                  SREG = bSreg;
   \                     ??ATA_eepChangeAccessRights_C_7:
   \   000000E2   BE0F               OUT     0x3F, R0
    436              }
    437          
    438              /* LLR-Ref: 135 */
    439              EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepChangeAccessRights_C_1:
   \   000000E4   9100....           LDS     R16, _A_EECR2
   \   000000E8   6C00               ORI     R16, 0xC0
   \   000000EA   9300....           STS     _A_EECR2, R16
    440              
    441              /* LLR-Ref: 140 */
    442              return retValue;
   \   000000EE   2F01               MOV     R16, R17
   \   000000F0   9508               RET
   \   000000F2                      REQUIRE _A_SREG
   \   000000F2                      REQUIRE _A_TRCDR
   \   000000F2                      REQUIRE _A_TRCIDL
   \   000000F2                      REQUIRE _A_TRCIDH
   \   000000F2                      REQUIRE _A_EECR
   \   000000F2                      REQUIRE _A_EEARH
   \   000000F2                      REQUIRE _A_EEARL
   \   000000F2                      REQUIRE _A_EEDR
   \   000000F2                      REQUIRE _A_EECR2
    443          }
    444          
    445          
    446          /*---------------------------------------------------------------------------*/
    447          /** \brief <b>ATA_eepWriteByte_C</b>
    448              shall write a single byte to the EEPROM in accordance with the applicable
    449              EEPROM Access Right Map.
    450          
    451          \param[in]  uAddress        EEPROM address to be written to
    452          \param[in]  uDataToWrite    Data to be written to the given EEPROM address
    453          
    454          \return     Status of the performed EEPROM write access (::eEepErrorCode)
    455          
    456          \StackUsageInBytes{XXX}
    457          
    458          \image html ATA_eepWriteByte_C.png
    459          
    460          \internal
    461              Prerequisite:
    462              The enabling of read/write access for sections AP0, AP1, AP2 and AP3 in
    463              register EEPR needs to be handled by the Application SW in order
    464              for this function to work as specified.
    465          
    466          \li 005: Update HW Trace Unit with specific function information\n\n
    467                   Technical background:
    468                   64 bytes are covered by one Access Right Map byte,
    469                   4 rows per access byte with 2 bits for each row (== 8 bits for 4 rows).
    470                   16 bytes per row, 4 rows per access byte, Row = 0..3
    471          
    472          \li 010: Get the EEPROM Access Right Map byte holding the access rights for the
    473                   row containing EEPROM address "uAddress" by dividing the given address
    474                   with 64.
    475          
    476          \li 020: Get the EEPROM Access Right Map row position within the access right
    477                   byte for the given EEPROM address, by only locking at bits 5 and 6.
    478          
    479          \li 030: Wait for any previous EEPROM access (Write or AES) to be finished by
    480                   checking the NVMBSY bit in register EECR being 0.
    481          
    482          \li 040: Disable all interrupts to allow for an atomic execution of the EEPROM
    483                   write access.
    484          
    485          \li 050: IF the given EEPROM address "uAddress" is not in the range
    486                    EEPROM_START_ADD to EEPROM_USER_END_ADD,
    487                   THEN
    488                     Set "return" to EEC_ADDR_OUT_OF_RANGE to indicate that the
    489                      given EEPROM address is out of range,
    490          
    491          \li 060: ELSE IF the given EEPROM address "uAddress" falls into section AP0,
    492                   THEN
    493                     Set "return" to EEC_ADDR_LOCKED_FOR_WRITING to indicate
    494                      that the given EEPROM address is locked,
    495          
    496          \li 070: ELSE
    497                     Get the EEPROM Access Right Map byte corresponding to the given
    498                      EEPROM address "uAddress" by calling function macro
    499                      ::ATA_FM_EEP_READ_BYTE_C().
    500                     IF after the EEPROM read access to retrieve the access rights, an
    501                      uncorrectable EEPROM error was detected, indicated by
    502                      bit "E2FF" in register EECR2 being set 1,
    503                     THEN
    504                       Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    505                        that an EEPROM error correction occured.
    506          
    507          \li 080:   ELSE IF the given EEPROM address "uAddress" is locked for writing,
    508                     THEN
    509                       Set "return" to EEC_ADDR_LOCKED_FOR_WRITING to indicate that
    510                        the given EEPROM address is locked,
    511          
    512          \li 090:   ELSE
    513                       Execute the write request by calling the function macro
    514                        ::ATA_FM_EEP_WRITE_BYTE_C() with the given EEPROM address
    515                        "uAddress" and "uDataToWrite" as parameters, AND
    516                     ENDIF
    517          
    518          \li 095:   Reset both EEPROM error indications by setting bits "E2CF" and 
    519                      "E2FF" in register EECR2 to 1 in order to not have stale flags
    520                      when executing a subsequent EEPROM read call.
    521          
    522                   ENDIF
    523          
    524          \li 100: Restore SREG status (namely the global interrupt flag), 
    525                   since the critical section is finished.
    526          
    527          \li 110: Return the function's error code to the calling function.
    528          
    529          \Derived{No}
    530          
    531          \Rationale{N/A}
    532          
    533          \Traceability{Primus2P-813,Primus2P-1103}
    534          \endinternal
    535          \n
    536          */
    537          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    538          __root eEepErrorCode ATA_eepWriteByte_C(uint16_t uAddress, uint8_t uDataToWrite)
   \                     ATA_eepWriteByte_C:
    539          {
   \   00000000   0108               MOVW    R1:R0, R17:R16
   \   00000002   2F32               MOV     R19, R18
    540              uint8_t bSreg = SREG;
   \   00000004   B75F               IN      R21, 0x3F
    541            
    542              /* Variable to hold the function's return value. */
    543              eEepErrorCode retValue = EEC_NO_ERROR;
   \   00000006   E020               LDI     R18, 0
    544          
    545              /* Variable to hold the actual row info for EEPROM operations */
    546              uint8_t uAccessRowInByte;
    547          
    548              /* Variable to hold the actual access right address for EEPROM operations */
    549              uint16_t uAccessRightAddress;
    550          
    551              /* Variable to hold the actual access right value of the given EEPROM address */
    552              uint8_t uAccessRightAddressValue;
    553          
    554              /* LLR-Ref: 005 */
    555              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepWriteByte_C, 0x00);
   \   00000008   B74F               IN      R20, 0x3F
   \   0000000A   94F8               CLI
   \   0000000C   9320....           STS     _A_TRCDR, R18
   \   00000010   ....               LDI     R16, LOW(ATA_eepWriteByte_C/2)
   \   00000012   9300....           STS     _A_TRCIDL, R16
   \   00000016   ....               LDI     R16, (ATA_eepWriteByte_C/2) >> 8
   \   00000018   9300....           STS     _A_TRCIDH, R16
   \   0000001C   BF4F               OUT     0x3F, R20
    556          
    557              /* LLR-Ref: 010 */
    558              uAccessRightAddress = EEP_MEM_ACCESS_MAP_ADD + (uAddress >> 6);
   \   0000001E   E046               LDI     R20, 6
   \   00000020   2D00               MOV     R16, R0
   \   00000022   ........           CALL    ?US_SHR_L02
   \   00000026   5B00               SUBI    R16, 176
   \   00000028   4F18               SBCI    R17, 248
    559          
    560              /* LLR-Ref: 020 */
    561              uAccessRowInByte = (uint8_t)((uAddress & 0x003F) >> 4);
   \   0000002A   2D40               MOV     R20, R0
   \   0000002C   9542               SWAP    R20
   \   0000002E   7043               ANDI    R20, 0x03
    562          
    563              /* LLR-Ref: 030 */
    564              while(EECR & BM_NVMBSY){}
   \                     ??ATA_eepWriteByte_C_0:
   \   00000030   99FF               SBIC    0x1F, 0x07
   \   00000032   CFFE               RJMP    ??ATA_eepWriteByte_C_0
    565          
    566              /* LLR-Ref: 040 */
    567              __disable_interrupt();
   \   00000034   94F8               CLI
    568          
    569              if ( uAddress > EEPROM_USER_END_ADD )
   \   00000036   E068               LDI     R22, 8
   \   00000038   1616               CP      R1, R22
   \   0000003A   F010               BRCS    ??ATA_eepWriteByte_C_1
    570              {
    571                  /* LLR-Ref: 050 */
    572                  retValue = EEC_ADDR_OUT_OF_RANGE;
   \   0000003C   E023               LDI     R18, 3
   \   0000003E   C026               RJMP    ??ATA_eepWriteByte_C_2
    573              }
    574              else if ( uAddress >= EEP_MEM_ACCESS_MAP_ADD )
   \                     ??ATA_eepWriteByte_C_1:
   \   00000040   E560               LDI     R22, 80
   \   00000042   1606               CP      R0, R22
   \   00000044   E067               LDI     R22, 7
   \   00000046   0616               CPC     R1, R22
   \   00000048   F010               BRCS    ??ATA_eepWriteByte_C_3
    575              {
    576                  /* LLR-Ref: 060 */
    577                  retValue = EEC_ADDR_LOCKED_FOR_WRITING;
   \   0000004A   E022               LDI     R18, 2
   \   0000004C   C01F               RJMP    ??ATA_eepWriteByte_C_2
    578              }
    579              else
    580              {
    581                  /* LLR-Ref: 070 */
    582                  ATA_FM_EEP_READ_BYTE_C (uAccessRightAddress, uAccessRightAddressValue)
   \                     ??ATA_eepWriteByte_C_3:
   \   0000004E   BD12               OUT     0x22, R17
   \   00000050   BD01               OUT     0x21, R16
   \   00000052   9AF8               SBI     0x1F, 0x00
   \   00000054   B510               IN      R17, 0x20
    583          
    584                  if ( EECR2 & BM_E2FF )
   \   00000056   9100....           LDS     R16, _A_EECR2
   \   0000005A   FF06               SBRS    R16, 6
   \   0000005C   C002               RJMP    ??ATA_eepWriteByte_C_4
    585                  {
    586                      retValue = EEC_ERROR_CORRECTION_OCCURED;
   \   0000005E   E024               LDI     R18, 4
   \   00000060   C010               RJMP    ??ATA_eepWriteByte_C_5
    587                  }
    588                  else if ( (uAccessRightAddressValue & (BM_EEP_SECTION_ROW_0_WR_ACC >> (uAccessRowInByte * 2))) == FALSE )
   \                     ??ATA_eepWriteByte_C_4:
   \   00000062   0F44               LSL     R20
   \   00000064   E400               LDI     R16, 64
   \   00000066   ........           CALL    ?UC_SHR_L01
   \   0000006A   2310               AND     R17, R16
   \   0000006C   F411               BRNE    ??ATA_eepWriteByte_C_6
    589                  {
    590                      /* LLR-Ref: 080 */
    591                      retValue = EEC_ADDR_LOCKED_FOR_WRITING;
   \   0000006E   E022               LDI     R18, 2
   \   00000070   C008               RJMP    ??ATA_eepWriteByte_C_5
    592                  }
    593                  else
    594                  {
    595                      /* LLR-Ref: 090 */
    596                      ATA_FM_EEP_WRITE_BYTE_C (uAddress, uDataToWrite)
   \                     ??ATA_eepWriteByte_C_6:
   \   00000072   BC12               OUT     0x22, R1
   \   00000074   BC01               OUT     0x21, R0
   \   00000076   BD30               OUT     0x20, R19
   \   00000078   B30F               IN      R16, 0x1F
   \   0000007A   7C0F               ANDI    R16, 0xCF
   \   0000007C   BB0F               OUT     0x1F, R16
   \   0000007E   9AFA               SBI     0x1F, 0x02
   \   00000080   9AF9               SBI     0x1F, 0x01
    597                  }
    598                  
    599                  /* LLR-Ref: 095 */
    600                  EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepWriteByte_C_5:
   \   00000082   9100....           LDS     R16, _A_EECR2
   \   00000086   6C00               ORI     R16, 0xC0
   \   00000088   9300....           STS     _A_EECR2, R16
    601              }
    602          
    603              /* LLR-Ref: 100 */
    604              SREG = bSreg;
   \                     ??ATA_eepWriteByte_C_2:
   \   0000008C   BF5F               OUT     0x3F, R21
    605          
    606              /* LLR-Ref: 110 */
    607              return retValue;
   \   0000008E                      REQUIRE ?Subroutine0
   \   0000008E                      REQUIRE _A_SREG
   \   0000008E                      REQUIRE _A_TRCDR
   \   0000008E                      REQUIRE _A_TRCIDL
   \   0000008E                      REQUIRE _A_TRCIDH
   \   0000008E                      REQUIRE _A_EECR
   \   0000008E                      REQUIRE _A_EEARH
   \   0000008E                      REQUIRE _A_EEARL
   \   0000008E                      REQUIRE _A_EEDR
   \   0000008E                      REQUIRE _A_EECR2
   \   0000008E                      ;               // Fall through to label ?Subroutine0
    608          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   2F02               MOV     R16, R18
   \   00000002   9508               RET
    609          
    610          
    611          /*---------------------------------------------------------------------------*/
    612          /** \brief <b>ATA_eepReadByte_C</b>
    613              shall read a single byte from the EEPROM in accordance with the
    614              applicable EEPROM Access Right Map.
    615          
    616          \param[out] pDataToRead     Address to store the data to
    617          \param[in]  uAddress        EEPROM address to be read from
    618          
    619          \return     Status of the performed EEPROM read access (::eEepErrorCode)
    620          
    621          \StackUsageInBytes{XXX}
    622          
    623          \image html ATA_eepReadByte_C.png
    624          
    625          \internal
    626              Prerequisite:
    627              The enabling of read/write access for sections AP0, AP1, AP2 and AP3 in
    628              register EEPR needs to be handled by the Application SW in order
    629              for this function to work as specified.
    630          
    631          \li 005: Update HW Trace Unit with specific function information\n\n
    632                   Technical background:
    633                   64 bytes are covered by one Access Right Map byte,
    634                   4 rows per access byte with 2 bits for each row (== 8 bits for 4 rows).
    635                   16 bytes per row, 4 rows per access byte, Row = 0..3
    636          
    637          \li 010: Get the EEPROM Access Right Map byte holding the access rights for the
    638                   row containing this EEPROM address "uAddress" by dividing the given
    639                   address with 64.
    640          
    641          \li 020: Get the EEPROM Access Right Map row position within the access right
    642                   byte for EEPROM address "uAddress", by only locking at bits 5 and 6.
    643          
    644          \li 030: Wait for any previous EEPROM access (Write or AES) to be finished by
    645                   checking the NVMBSY bit in register EECR being 0.
    646          
    647          \li 040: Disable all interrupts to allow for an atomic execution of the EEPROM
    648                   read access.
    649          
    650          \li 050: IF the given EEPROM address "uAddress" is not in the range
    651                    EEPROM_START_ADD to EEPROM_XROW_END_ADD,
    652                   THEN
    653                     Set the return value to EEC_ADDR_OUT_OF_RANGE to indicate that the
    654                      given EEPROM address is out of range,
    655          
    656          \li 060: ELSE
    657                     Get the EEPROM Access Right Map byte corresponding to the given
    658                     EEPROM address "uAddress" by calling function macro
    659                     ::ATA_FM_EEP_READ_BYTE_C().
    660                     IF after the EEPROM read access to retrieve the access rights, an
    661                      uncorrectable EEPROM error was detected, indicated by
    662                      bit "E2FF" in register EECR2 being set 1,
    663                     THEN
    664                       Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    665                        that an EEPROM error correction occured.
    666          
    667          \li 070:   ELSE IF the given EEPROM address "uAddress" is locked for reading,
    668                     THEN
    669                       Set the return value to EEC_ADDR_LOCKED_FOR_READING to indicate
    670                       that the given EEPROM address is locked,
    671          
    672                     ELSE
    673          \li 075:     Reset both EEPROM error indications by setting bits "E2CF" and 
    674                        "E2FF" in register EECR2 to 1 in order to not have stale flags
    675                        when executing a subsequent EEPROM read call.
    676          
    677          \li 080:     Execute the write request by calling the function macro
    678                        ::ATA_FM_EEP_READ_BYTE_C() with EEPROM address "uAddress" and
    679                        "pDataToRead" as parameters.
    680                       IF after the EEPROM read access to retrieve the requested data, an
    681                        uncorrectable EEPROM error was detected, indicated by
    682                        bit "E2FF" in register EECR2 being set 1,
    683                       THEN
    684                         Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    685                          that an EEPROM error correction occured.
    686                       ELSE
    687                         Set "return" to EEC_NO_ERROR to indicate that the EEPROM read
    688                          request was performed successfully.
    689                       ENDIF
    690                     ENDIF
    691          
    692          \li 085:   Reset both EEPROM error indications by setting bits "E2CF" and 
    693                       "E2FF" in register EECR2 to 1.
    694          
    695                   ENDIF
    696          
    697          \li 090: Restore SREG status (namely the global interrupt flag), 
    698                   since the critical section is finished.
    699          
    700          \li 100: Return the function's error code to the calling function.
    701          
    702          \Derived{No}
    703          
    704          \Rationale{N/A}
    705          
    706          \Traceability{Primus2P-820,Primus2P-1102}
    707          \endinternal
    708          \n
    709          */
    710          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    711          __root eEepErrorCode ATA_eepReadByte_C(uint16_t uAddress, uint8_t* const pDataToRead)
   \                     ATA_eepReadByte_C:
    712          {
   \   00000000   0108               MOVW    R1:R0, R17:R16
   \   00000002   01F9               MOVW    R31:R30, R19:R18
    713              uint8_t bSreg = SREG;
   \   00000004   B73F               IN      R19, 0x3F
    714              
    715              /* Variable to hold the function's return value. */
    716              eEepErrorCode retValue = EEC_NO_ERROR;
   \   00000006   E020               LDI     R18, 0
    717          
    718              /* Variable to hold the actual row info for EEPROM operations */
    719              uint8_t uAccessRowInByte;
    720          
    721              /* Variable to hold the actual access right address for EEPROM operations */
    722              uint16_t uAccessRightAddress;
    723          
    724              /* Variable to hold the actual access right value of the given EEPROM address */
    725              uint8_t uAccessRightAddressValue;
    726          
    727              /* LLR-Ref: 005 */
    728              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepReadByte_C, 0x00);
   \   00000008   B74F               IN      R20, 0x3F
   \   0000000A   94F8               CLI
   \   0000000C   9320....           STS     _A_TRCDR, R18
   \   00000010   ....               LDI     R16, LOW(ATA_eepReadByte_C/2)
   \   00000012   9300....           STS     _A_TRCIDL, R16
   \   00000016   ....               LDI     R16, (ATA_eepReadByte_C/2) >> 8
   \   00000018   9300....           STS     _A_TRCIDH, R16
   \   0000001C   BF4F               OUT     0x3F, R20
    729          
    730              /* LLR-Ref: 010 */
    731              uAccessRightAddress = EEP_MEM_ACCESS_MAP_ADD + (uAddress >> 6);
   \   0000001E   E046               LDI     R20, 6
   \   00000020   2D00               MOV     R16, R0
   \   00000022   ........           CALL    ?US_SHR_L02
   \   00000026   5B00               SUBI    R16, 176
   \   00000028   4F18               SBCI    R17, 248
    732          
    733              /* LLR-Ref: 020 */
    734              uAccessRowInByte = (uint8_t)((uAddress & 0x003F) >> 4);
   \   0000002A   2D40               MOV     R20, R0
   \   0000002C   9542               SWAP    R20
   \   0000002E   7043               ANDI    R20, 0x03
    735          
    736              /* LLR-Ref: 030 */
    737              __disable_interrupt();
   \   00000030   94F8               CLI
    738          
    739              /* LLR-Ref: 040 */
    740              while(EECR & BM_NVMBSY){}
   \                     ??ATA_eepReadByte_C_0:
   \   00000032   99FF               SBIC    0x1F, 0x07
   \   00000034   CFFE               RJMP    ??ATA_eepReadByte_C_0
    741          
    742              if ( uAddress > EEPROM_XROW_END_ADD )
   \   00000036   E059               LDI     R21, 9
   \   00000038   1615               CP      R1, R21
   \   0000003A   F010               BRCS    ??ATA_eepReadByte_C_1
    743              {
    744                  /* LLR-Ref: 050 */
    745                  retValue = EEC_ADDR_OUT_OF_RANGE;
   \   0000003C   E023               LDI     R18, 3
   \   0000003E   C023               RJMP    ??ATA_eepReadByte_C_2
    746              }
    747              else
    748              {
    749                  /* LLR-Ref: 060 */
    750                  ATA_FM_EEP_READ_BYTE_C(uAccessRightAddress, uAccessRightAddressValue)
   \                     ??ATA_eepReadByte_C_1:
   \   00000040   BD12               OUT     0x22, R17
   \   00000042   BD01               OUT     0x21, R16
   \   00000044   9AF8               SBI     0x1F, 0x00
   \   00000046   B510               IN      R17, 0x20
    751          
    752                  if ( EECR2 & BM_E2FF )
   \   00000048   9100....           LDS     R16, _A_EECR2
   \   0000004C   FD06               SBRC    R16, 6
   \   0000004E   C015               RJMP    ??ATA_eepReadByte_C_3
    753                  {
    754                      retValue = EEC_ERROR_CORRECTION_OCCURED;
    755                  }
    756                  else if ( (uAccessRightAddressValue & (BM_EEP_SECTION_ROW_0_RD_ACC >> (uAccessRowInByte * 2))) == FALSE )
   \   00000050   0F44               LSL     R20
   \   00000052   E800               LDI     R16, 128
   \   00000054   ........           CALL    ?UC_SHR_L01
   \   00000058   2310               AND     R17, R16
   \   0000005A   F411               BRNE    ??ATA_eepReadByte_C_4
    757                  {
    758                      /* LLR-Ref: 070 */
    759                      retValue = EEC_ADDR_LOCKED_FOR_READING;
   \   0000005C   E021               LDI     R18, 1
   \   0000005E   C00E               RJMP    ??ATA_eepReadByte_C_5
    760                  }
    761                  else
    762                  {
    763                      /* LLR-Ref: 075 */
    764                      EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepReadByte_C_4:
   \   00000060   9100....           LDS     R16, _A_EECR2
   \   00000064   6C00               ORI     R16, 0xC0
   \   00000066   9300....           STS     _A_EECR2, R16
    765                    
    766                      /* LLR-Ref: 080 */
    767                      ATA_FM_EEP_READ_BYTE_C(uAddress, *pDataToRead)
   \   0000006A   BC12               OUT     0x22, R1
   \   0000006C   BC01               OUT     0x21, R0
   \   0000006E   9AF8               SBI     0x1F, 0x00
   \   00000070   B500               IN      R16, 0x20
   \   00000072   8300               ST      Z, R16
    768          
    769                      if ( EECR2 & BM_E2FF )
   \   00000074   9100....           LDS     R16, _A_EECR2
   \   00000078   FD06               SBRC    R16, 6
    770                      {
    771                          retValue = EEC_ERROR_CORRECTION_OCCURED;
   \                     ??ATA_eepReadByte_C_3:
   \   0000007A   E024               LDI     R18, 4
    772                      }
    773                  }
    774                  
    775                  /* LLR-Ref: 085 */
    776                  EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepReadByte_C_5:
   \   0000007C   9100....           LDS     R16, _A_EECR2
   \   00000080   6C00               ORI     R16, 0xC0
   \   00000082   9300....           STS     _A_EECR2, R16
    777              }
    778          
    779              /* LLR-Ref: 090 */
    780              SREG = bSreg;
   \                     ??ATA_eepReadByte_C_2:
   \   00000086   BF3F               OUT     0x3F, R19
    781          
    782              /* LLR-Ref: 100 */
    783              return retValue;
   \   00000088   ....               RJMP    ?Subroutine0
   \   0000008A                      REQUIRE _A_SREG
   \   0000008A                      REQUIRE _A_TRCDR
   \   0000008A                      REQUIRE _A_TRCIDL
   \   0000008A                      REQUIRE _A_TRCIDH
   \   0000008A                      REQUIRE _A_EECR
   \   0000008A                      REQUIRE _A_EEARH
   \   0000008A                      REQUIRE _A_EEARL
   \   0000008A                      REQUIRE _A_EEDR
   \   0000008A                      REQUIRE _A_EECR2
    784          }
    785          
    786          
    787          /*---------------------------------------------------------------------------*/
    788          /** \brief <b>ATA_eepReadMultipleBytes_C</b>
    789              The purpose of this function is to read multiple bytes from the EEPROM in
    790              accordance with the applicable EEPROM Access Right Map.
    791              To copy the bytes, the EEPROM burst read mode is used.
    792          
    793          \param[out] uDataBytes      Address to store the data to
    794          \param[in]  uAddress        EEPROM address to be read from
    795          \param[in]  uLength         Number of data bytes to be read
    796          
    797          \return     Status of the performed EEPROM read access (::eEepErrorCode)
    798          
    799          \StackUsageInBytes{XXX}
    800          
    801          \image html ATA_eepReadMultipleBytes_C.png
    802          
    803          \internal
    804              Prerequisite:
    805              The enabling of read/write access for sections AP0, AP1, AP2 and AP3 in
    806              register EEPR needs to be handled by the Application SW in order
    807              for this function to work as specified.
    808          
    809          \li 005: Update HW Trace Unit with specific function information\n\n
    810                   Technical background:
    811                   64 bytes are covered by one Access Right Map byte,
    812                   4 rows per access byte with 2 bits for each row (== 8 bits for 4 rows).
    813                   16 bytes per row, 4 rows per access byte, Row = 0..3
    814          
    815          \li 010: Compute the last valid address to be taken into account for reading
    816                   by adding "uLength" to "uAddress" and subtracting one byte.
    817          
    818          \li 020: Wait for any previous EEPROM access (Write or AES) to be finished by
    819                   checking the NVMBSY bit in register EECR being 0.
    820          
    821          \li 030: Disable all interrupts to allow for an atomic execution of the EEPROM
    822                   read access.
    823          
    824          \li 040: IF the given range of EEPROM addresses starting from "uAddress", is
    825                    not in the range EEPROM_START_ADD to EEPROM_XROW_END_ADD,
    826                   THEN
    827                     Set "return" to EEC_ADDR_OUT_OF_RANGE to indicate that the
    828                     given EEPROM addresses are out of range,
    829          
    830                   ELSE
    831                     Check all read access rights of the affected EEPROM pages.
    832          
    833          \li 050:   Get the EEPROM Access Right Map byte holding the access rights for
    834                     the row containing this EEPROM address "uAddress" by dividing the
    835                     given address with 64.
    836          
    837          \li 060:   Get the EEPROM Access Right Map row position within the access right
    838                     byte for EEPROM address "uAddress", by only locking at bits 5 and 6.
    839          
    840          \li 070:   Get the EEPROM Access Right Map byte corresponding to the affected
    841                      EEPROM address by calling function macro ::ATA_FM_EEP_READ_BYTE_C().
    842          
    843          \li 080:   IF after the EEPROM read access to retrieve the access rights, an
    844                       uncorrectable EEPROM error was detected, indicated by
    845                       bit "E2FF" in register EECR2 being set 1,
    846                     THEN
    847                       Reset the EEPROM fault indications by 
    848                        setting bit "E2FF" in register EECR2 to 1, AND
    849                       Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    850                        that an EEPROM error correction occured.
    851                       Stop checking further access rights to not overwrite the given
    852                        EEPROM error with a different one.
    853          
    854                     ELSE
    855          \li 090:     IF the given EEPROM address "uAddress" is locked for reading,
    856                       THEN
    857                         Set "return" to EEC_ADDR_LOCKED_FOR_READING to indicate
    858                          that the given EEPROM address is locked, AND
    859                         Stop checking further access rights to not overwrite the given
    860                          EEPROM error with a different one.
    861                       ENDIF
    862                     ENDIF
    863          
    864          \li 095:   Reset both EEPROM error indications by setting bits "E2CF" and 
    865                      "E2FF" in register EECR2 to 1 in order to not have stale flags
    866                      when executing a subsequent EEPROM read call.
    867          
    868          \li 100:   IF "return" is set to EEC_NO_ERROR, indicating that the intended
    869                      EEPROM read access is valid,
    870                     THEN
    871                       Execute the EEPROM multi byte read request by calling the function
    872                        macro ::ATA_FM_EEP_READ_MULTIPLE_BYTES_C() with EEPROM start address
    873                        "uAddress", "uLength" and "uDataBytes" as parameters.
    874          
    875          \li 110:     IF after the EEPROM multi byte read access to retrieve the requested
    876                        data, an uncorrectable EEPROM error was detected, indicated by
    877                        bit "E2FF" in register EECR2 being set 1,
    878                       THEN
    879                         Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
    880                          that an EEPROM error correction occured.
    881                       ELSE
    882                         Set "return" to EEC_NO_ERROR to indicate that the EEPROM read
    883                          request was performed successfully.
    884                       ENDIF
    885          
    886          \li 115:     Reset both EEPROM error indications by setting bits "E2CF" and 
    887                        "E2FF" in register EECR2 to 1
    888          
    889                     ENDIF
    890                   ENDIF
    891          
    892          \li 120: Restore SREG status (namely the global interrupt flag), 
    893                   since the critical section is finished.
    894          
    895          \li 130: Return the function's error code to the calling function.
    896          
    897          \Derived{No}
    898          
    899          \Rationale{N/A}
    900          
    901          \Traceability{Primus2P-815,Primus2P-1102}
    902          \endinternal
    903          \n
    904          */
    905          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
    906          __root eEepErrorCode ATA_eepReadMultipleBytes_C(uint16_t uAddress, uint8_t uLength, uint8_t* uDataBytes)
   \                     ATA_eepReadMultipleBytes_C:
    907          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01B8               MOVW    R23:R22, R17:R16
   \   00000006   2E02               MOV     R0, R18
    908              uint8_t bSreg = SREG;
   \   00000008   B73F               IN      R19, 0x3F
    909            
    910              /* Performance optimization. */
    911              uint8_t* pData;
    912          
    913              /* Variable to hold the function's return value. */
    914              eEepErrorCode retValue = EEC_NO_ERROR;
   \   0000000A   E020               LDI     R18, 0
    915          
    916              /* Variable to hold the address for which the access right is checked. */
    917              uint16_t loopAddress;
    918          
    919              /* Variable to hold the end address of the EEPROM read opearation */
    920              uint16_t uAddressEnd;
    921          
    922              /* Variable to hold the actual row info for EEPROM operations */
    923              uint8_t uAccessRowInByte;
    924          
    925              /* Variable to hold the actual access right address for EEPROM operations */
    926              uint16_t uAccessRightAddress;
    927          
    928              /* Variable to hold the actual access right value of the given EEPROM address */
    929              uint8_t uAccessRightAddressValue;
    930          
    931              /* LLR-Ref: 005 */
    932              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepReadMultipleBytes_C, uLength);
   \   0000000C   B61F               IN      R1, 0x3F
   \   0000000E   94F8               CLI
   \   00000010   9200....           STS     _A_TRCDR, R0
   \   00000014   ....               LDI     R16, LOW(ATA_eepReadMultipleBytes_C/2)
   \   00000016   9300....           STS     _A_TRCIDL, R16
   \   0000001A   ....               LDI     R16, (ATA_eepReadMultipleBytes_C/2) >> 8
   \   0000001C   9300....           STS     _A_TRCIDH, R16
   \   00000020   BE1F               OUT     0x3F, R1
    933          
    934              pData = uDataBytes;
   \   00000022   01FA               MOVW    R31:R30, R21:R20
    935          
    936              /* LLR-Ref: 010 */
    937              uAddressEnd = uAddress + uLength - 0x01U;
   \   00000024   2FA6               MOV     R26, R22
   \   00000026   2FB1               MOV     R27, R17
   \   00000028   0DA0               ADD     R26, R0
   \   0000002A   1FB2               ADC     R27, R18
   \   0000002C   9711               SBIW    R27:R26, 1
    938          
    939              /* LLR-Ref: 020 */
    940              while(EECR & BM_NVMBSY){}
   \                     ??ATA_eepReadMultipleBytes_C_0:
   \   0000002E   99FF               SBIC    0x1F, 0x07
   \   00000030   CFFE               RJMP    ??ATA_eepReadMultipleBytes_C_0
    941          
    942              /* LLR-Ref: 030 */
    943              __disable_interrupt();
   \   00000032   94F8               CLI
    944          
    945              /* LLR-Ref: 040 */
    946              /* This check detects an address overflow as well! */
    947              if ( (uAddress > EEPROM_XROW_END_ADD) || (uAddressEnd > EEPROM_XROW_END_ADD)  )
   \   00000034   3019               CPI     R17, 9
   \   00000036   F410               BRCC    ??ATA_eepReadMultipleBytes_C_1
   \   00000038   30B9               CPI     R27, 9
   \   0000003A   F010               BRCS    ??ATA_eepReadMultipleBytes_C_2
    948              {
    949                  retValue = EEC_ADDR_OUT_OF_RANGE;
   \                     ??ATA_eepReadMultipleBytes_C_1:
   \   0000003C   E023               LDI     R18, 3
   \   0000003E   C04B               RJMP    ??ATA_eepReadMultipleBytes_C_3
    950              }
    951              else
    952              {
    953                  for ( loopAddress = uAddress;
   \                     ??ATA_eepReadMultipleBytes_C_2:
   \   00000040   2E26               MOV     R2, R22
   \   00000042   2E31               MOV     R3, R17
   \   00000044   C007               RJMP    ??ATA_eepReadMultipleBytes_C_4
    954                        loopAddress <= uAddressEnd;
    955                        loopAddress += (0x0010U - (loopAddress & 0x000FU)) )
   \                     ??ATA_eepReadMultipleBytes_C_5:
   \   00000046   01C1               MOVW    R25:R24, R3:R2
   \   00000048   9640               ADIW    R25:R24, 16
   \   0000004A   2D02               MOV     R16, R2
   \   0000004C   700F               ANDI    R16, 0x0F
   \   0000004E   011C               MOVW    R3:R2, R25:R24
   \   00000050   1A20               SUB     R2, R16
   \   00000052   0A32               SBC     R3, R18
   \                     ??ATA_eepReadMultipleBytes_C_4:
   \   00000054   15A2               CP      R26, R2
   \   00000056   05B3               CPC     R27, R3
   \   00000058   F0D8               BRCS    ??ATA_eepReadMultipleBytes_C_6
    956                  {
    957                      /* LLR-Ref: 050 */
    958                      uAccessRightAddress = EEP_MEM_ACCESS_MAP_ADD + (loopAddress >> 6);
   \   0000005A   E046               LDI     R20, 6
   \   0000005C   0181               MOVW    R17:R16, R3:R2
   \   0000005E   ........           CALL    ?US_SHR_L02
   \   00000062   5B00               SUBI    R16, 176
   \   00000064   4F18               SBCI    R17, 248
    959          
    960                      /* LLR-Ref: 060 */
    961                      uAccessRowInByte = (uint8_t)((loopAddress & 0x003F) >> 4);
    962          
    963                      /* LLR-Ref: 070 */
    964                      ATA_FM_EEP_READ_BYTE_C(uAccessRightAddress, uAccessRightAddressValue)
   \   00000066   BD12               OUT     0x22, R17
   \   00000068   BD01               OUT     0x21, R16
   \   0000006A   9AF8               SBI     0x1F, 0x00
   \   0000006C   B510               IN      R17, 0x20
    965          
    966                      if ( EECR2 & BM_E2FF )
   \   0000006E   9100....           LDS     R16, _A_EECR2
   \   00000072   FF06               SBRS    R16, 6
   \   00000074   C002               RJMP    ??ATA_eepReadMultipleBytes_C_7
    967                      {
    968                          /* LLR-Ref: 080 */
    969                          retValue = EEC_ERROR_CORRECTION_OCCURED;
   \   00000076   E024               LDI     R18, 4
    970                          break;
   \   00000078   C00B               RJMP    ??ATA_eepReadMultipleBytes_C_6
    971                      }
    972                      else
    973                      {
    974                          /* LLR-Ref: 090 */
    975                          if ( (uAccessRightAddressValue & (BM_EEP_SECTION_ROW_0_RD_ACC >> (uAccessRowInByte * 2))) == FALSE )
   \                     ??ATA_eepReadMultipleBytes_C_7:
   \   0000007A   2D42               MOV     R20, R2
   \   0000007C   9546               LSR     R20
   \   0000007E   9546               LSR     R20
   \   00000080   9546               LSR     R20
   \   00000082   7046               ANDI    R20, 0x06
   \   00000084   E800               LDI     R16, 128
   \   00000086   ........           CALL    ?UC_SHR_L01
   \   0000008A   2310               AND     R17, R16
   \   0000008C   F6E1               BRNE    ??ATA_eepReadMultipleBytes_C_5
    976                          {
    977                              retValue = EEC_ADDR_LOCKED_FOR_READING;
   \   0000008E   E021               LDI     R18, 1
    978                              break;
    979                          }
    980                      }
    981                  }
    982          
    983                  /* LLR-Ref: 095 */
    984                  EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepReadMultipleBytes_C_6:
   \   00000090   9100....           LDS     R16, _A_EECR2
   \   00000094   6C00               ORI     R16, 0xC0
   \   00000096   9300....           STS     _A_EECR2, R16
    985                  
    986                  if ( retValue == EEC_NO_ERROR )
   \   0000009A   2322               TST     R18
   \   0000009C   F4E1               BRNE    ??ATA_eepReadMultipleBytes_C_3
    987                  {
    988                      /* LLR-Ref: 100 */
    989                      ATA_FM_EEP_READ_MULTIPLE_BYTES_C(uAddress, uLength, pData)
   \   0000009E   BD72               OUT     0x22, R23
   \   000000A0   BD61               OUT     0x21, R22
   \   000000A2   91000159           LDS     R16, 345
   \   000000A6   6001               ORI     R16, 0x01
   \   000000A8   93000159           STS     345, R16
   \   000000AC   E000               LDI     R16, 0
   \   000000AE   C003               RJMP    ??ATA_eepReadMultipleBytes_C_8
   \                     ??ATA_eepReadMultipleBytes_C_9:
   \   000000B0   B510               IN      R17, 0x20
   \   000000B2   9311               ST      Z+, R17
   \   000000B4   9503               INC     R16
   \                     ??ATA_eepReadMultipleBytes_C_8:
   \   000000B6   1500               CP      R16, R0
   \   000000B8   F3D8               BRCS    ??ATA_eepReadMultipleBytes_C_9
   \   000000BA   9100....           LDS     R16, _A_EECR2
   \   000000BE   730E               ANDI    R16, 0x3E
   \   000000C0   9300....           STS     _A_EECR2, R16
    990          
    991                      if ( EECR2 & BM_E2FF )
   \   000000C4   9100....           LDS     R16, _A_EECR2
   \   000000C8   FD06               SBRC    R16, 6
    992                      {
    993                          /* LLR-Ref: 110 */
    994                          retValue = EEC_ERROR_CORRECTION_OCCURED;
   \   000000CA   E024               LDI     R18, 4
    995                      }
    996                      
    997                      /* LLR-Ref: 115 */
    998                      EECR2 |= (BM_E2CF | BM_E2FF);
   \                     ??ATA_eepReadMultipleBytes_C_10:
   \   000000CC   9100....           LDS     R16, _A_EECR2
   \   000000D0   6C00               ORI     R16, 0xC0
   \   000000D2   9300....           STS     _A_EECR2, R16
    999                  }
   1000              }
   1001          
   1002              /* LLR-Ref: 120 */
   1003              SREG = bSreg;
   \                     ??ATA_eepReadMultipleBytes_C_3:
   \   000000D6                      REQUIRE ?Subroutine1
   \   000000D6                      REQUIRE _A_SREG
   \   000000D6                      REQUIRE _A_TRCDR
   \   000000D6                      REQUIRE _A_TRCIDL
   \   000000D6                      REQUIRE _A_TRCIDH
   \   000000D6                      REQUIRE _A_EECR
   \   000000D6                      REQUIRE _A_EEARH
   \   000000D6                      REQUIRE _A_EEARL
   \   000000D6                      REQUIRE _A_EEDR
   \   000000D6                      REQUIRE _A_EECR2
   \   000000D6                      ;               // Fall through to label ?Subroutine1
   1004          
   1005              /* LLR-Ref: 130 */
   1006              return retValue;
   1007          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   BF3F               OUT     0x3F, R19
   \   00000002   2F02               MOV     R16, R18
   \   00000004   E0E4               LDI     R30, 4
   \   00000006   ........           JMP     ?EPILOGUE_B4_L09
   1008          
   1009          
   1010          /*---------------------------------------------------------------------------*/
   1011          /** \brief <b>ATA_eepWriteMultipleBytes_C</b>
   1012              shall write multiple bytes to a defined EEPROM start address in accordance
   1013              with the applicable EEPROM Access Right Map.
   1014          
   1015          \param[in]  uAddress         EEPROM address to be written to
   1016          \param[in]  uLength          Number of bytes to be written
   1017          \param[in]  pDataToWrite     Data to be written to the given EEPROM address
   1018          
   1019          \return     Status of the performed EEPROM write access (:.eEepErrorCode)
   1020          
   1021          \StackUsageInBytes{XXX}
   1022          
   1023          \image html ATA_eepWriteMultipleBytes_C.png
   1024          
   1025          \internal
   1026              Prerequisite:
   1027              The enabling of read/write access for sections AP0, AP1, AP2 and AP3 in
   1028              register EEPR needs to be handled by the Application SW in order
   1029              for this function to work as specified.
   1030          
   1031          \li 005: Update HW Trace Unit with specific function information\n\n
   1032                   Technical background:
   1033                   64 bytes are covered by one Access Right Map byte,
   1034                   4 rows per access byte with 2 bits for each row (== 8 bits for 4 rows).
   1035                   16 bytes per row, 4 rows per access byte, Row = 0..3
   1036          
   1037          \li 010: Compute the last valid address to be taken into account for reading
   1038                   by adding "uLength" to "uAddress" and subtracting one byte.
   1039          
   1040          \li 020: Wait for any previous EEPROM access (Write or AES) to be finished by
   1041                   checking the NVMBSY bit in register EECR being 0.
   1042          
   1043          \li 030: Disable all interrupts to allow for an atomic execution of the EEPROM
   1044                   read access.
   1045          
   1046          \li 040: IF the given range of EEPROM addresses starting from "uAddress", is
   1047                    not in the range EEPROM_START_ADD to EEPROM_USER_END_ADD,
   1048                   THEN
   1049                     Set "return" to EEC_ADDR_OUT_OF_RANGE to indicate that the
   1050                     given EEPROM addresses are out of range,
   1051          
   1052          \li 050: ELSE IF the given range of EEPROM addresses starting from "uAddress",
   1053                    is not in the range AP0_START_ADD to EEPROM_USER_END_ADD,
   1054                   THEN
   1055                     Set "return" to EEC_ADDR_OUT_OF_RANGE to indicate that the
   1056                     given EEPROM addresses are out of range,
   1057          
   1058                   ELSE
   1059                     Check all write access rights of the affected EEPROM pages.
   1060          
   1061          \li 060:   Get the EEPROM Access Right Map byte holding the access rights for
   1062                     the row containing this EEPROM address "uAddress" by dividing the
   1063                     given address with 64.
   1064          
   1065          \li 070:   Get the EEPROM Access Right Map row position within the access right
   1066                     byte for EEPROM address "uAddress", by only locking at bits 5 and 6.
   1067          
   1068          \li 080:   Get the EEPROM Access Right Map byte corresponding to the affected
   1069                     EEPROM address by calling function macro ::ATA_FM_EEP_READ_BYTE_C().
   1070          
   1071          \li 090:   IF after the EEPROM read access to retrieve the access rights, an
   1072                       uncorrectable EEPROM error was detected, indicated by
   1073                       bit "E2FF" in register EECR2 being set 1,
   1074                     THEN
   1075                       Set "return" to EEC_ERROR_CORRECTION_OCCURED to indicate
   1076                        that an EEPROM error correction occured.
   1077                       Stop checking further access rights to not overwrite the given
   1078                        EEPROM error with a different one.
   1079          
   1080                     ELSE
   1081          \li 100:     IF the given EEPROM address "uAddress" is locked for writing,
   1082                       THEN
   1083                         Set "return" to EEC_ADDR_LOCKED_FOR_READING to indicate
   1084                          that the given EEPROM address is locked, AND
   1085                         Stop checking further access rights to not overwrite the given
   1086                          EEPROM error with a different one.
   1087                       ENDIF
   1088                     ENDIF
   1089                   ENDIF
   1090          
   1091          \li 105: Reset both EEPROM error indications by setting bits "E2CF" and 
   1092                    "E2FF" in register EECR2 to 1 in order to not have stale flags
   1093                    when executing a subsequent EEPROM read call.
   1094          
   1095                   IF "return" is set to EEC_NO_ERROR, indicating that the intended
   1096                    EEPROM read access is valid,
   1097                   THEN
   1098                     Do the following until all bytes have been written to the EEPROM
   1099          
   1100          \li 110:   Wait for any previous EEPROM write access to be finished by
   1101                     checking the NVMBSY bit in register EECR being 0.
   1102          
   1103          \li 120:   Compute the actual number of bytes to be written to the affected
   1104                     EEPROM address taking into account that the EEPROM start address is
   1105                     not EEPROM page aligned and that the last EPPROM write may not
   1106                     contain a full EPPROM page to be written.
   1107          
   1108          \li 130:   Execute the EEPROM multi byte wite request by calling the function
   1109                     macro ::ATA_FM_EEP_WRITE_MULTIPLE_BYTES_C() with the affected EEPROM
   1110                     address, the number of bytes to be written and the date to be
   1111                     written as parameters.
   1112          
   1113          \li 140:   Update the affected EEPROM address with the number of bytes written
   1114                      in the last cycle, AND
   1115                     Update the number of bytes to be written with the number of bytes
   1116                      written in the last cycle.
   1117          
   1118                   ENDIF
   1119          
   1120          \li 150: Restore SREG status (namely the global interrupt flag), 
   1121                   since the critical section is finished.
   1122          
   1123          \li 160: Return the return value to the calling function.
   1124          
   1125          \Derived{No}
   1126          
   1127          \Rationale{N/A}
   1128          
   1129          \Traceability{Primus2P-814,Primus2P-1103}
   1130          \endinternal
   1131          \n
   1132          */
   1133          /*---------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next, root
   1134          __root eEepErrorCode ATA_eepWriteMultipleBytes_C(uint16_t uAddress, uint8_t uLength, const uint8_t* pDataToWrite)
   \                     ATA_eepWriteMultipleBytes_C:
   1135          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   0108               MOVW    R1:R0, R17:R16
   \   00000006   2E22               MOV     R2, R18
   \   00000008   01FA               MOVW    R31:R30, R21:R20
   1136              uint8_t bSreg = SREG;
   \   0000000A   B73F               IN      R19, 0x3F
   1137            
   1138              /* Variable to hold the function's return value. */
   1139              eEepErrorCode retValue = EEC_NO_ERROR;
   \   0000000C   E020               LDI     R18, 0
   1140          
   1141              /* Variable to hold the number of bytes to be written via the EEPROM page mode. */
   1142              uint8_t uByteCount;
   1143          
   1144              /* Variable to hold the address for which the access right is checked. */
   1145              uint16_t loopAddress;
   1146          
   1147              /* Variable to hold the end address of the EEPROM read opearation */
   1148              uint16_t uAddressEnd;
   1149          
   1150              /* Variable to hold the actual row info for EEPROM operations */
   1151              uint8_t uAccessRowInByte;
   1152          
   1153              /* Variable to hold the actual access right address for EEPROM operations */
   1154              uint16_t uAccessRightAddress;
   1155          
   1156              /* Variable to hold the actual access right value of the given EEPROM address */
   1157              uint8_t uAccessRightAddressValue;
   1158          
   1159              /* LLR-Ref: 005 */
   1160              ATA_SET_FUNCTION_TRACE_POINT_C(ATA_eepWriteMultipleBytes_C, 0x00);
   \   0000000E   B74F               IN      R20, 0x3F
   \   00000010   94F8               CLI
   \   00000012   9320....           STS     _A_TRCDR, R18
   \   00000016   ....               LDI     R16, LOW(ATA_eepWriteMultipleBytes_C/2)
   \   00000018   9300....           STS     _A_TRCIDL, R16
   \   0000001C   ....               LDI     R16, (ATA_eepWriteMultipleBytes_C/2) >> 8
   \   0000001E   9300....           STS     _A_TRCIDH, R16
   \   00000022   BF4F               OUT     0x3F, R20
   1161          
   1162              /* LLR-Ref: 010 */
   1163              uAddressEnd = uAddress + uLength - 0x01U;
   \   00000024   2433               CLR     R3
   \   00000026   2D60               MOV     R22, R0
   \   00000028   2F71               MOV     R23, R17
   \   0000002A   0D62               ADD     R22, R2
   \   0000002C   1F72               ADC     R23, R18
   \   0000002E   5061               SUBI    R22, 1
   \   00000030   4070               SBCI    R23, 0
   1164          
   1165              /* LLR-Ref: 020 */
   1166              while(EECR & BM_NVMBSY){}
   \                     ??ATA_eepWriteMultipleBytes_C_0:
   \   00000032   99FF               SBIC    0x1F, 0x07
   \   00000034   CFFE               RJMP    ??ATA_eepWriteMultipleBytes_C_0
   1167          
   1168              /* LLR-Ref: 030 */
   1169              __disable_interrupt();
   \   00000036   94F8               CLI
   1170          
   1171              if ( (uAddress > EEPROM_USER_END_ADD) || (uAddressEnd > EEPROM_USER_END_ADD)  )
   \   00000038   3018               CPI     R17, 8
   \   0000003A   F410               BRCC    ??ATA_eepWriteMultipleBytes_C_1
   \   0000003C   3078               CPI     R23, 8
   \   0000003E   F010               BRCS    ??ATA_eepWriteMultipleBytes_C_2
   1172              {
   1173                  /* LLR-Ref: 040 */
   1174                  retValue = EEC_ADDR_OUT_OF_RANGE;
   \                     ??ATA_eepWriteMultipleBytes_C_1:
   \   00000040   E023               LDI     R18, 3
   1175              }
   1176              else if ( (uAddress > AP0_START_ADD) || (uAddressEnd > AP0_START_ADD) )
   1177              {
   1178                  /* LLR-Ref: 050 */
   1179                  retValue = EEC_ADDR_LOCKED_FOR_WRITING;
   1180              }
   1181              else
   1182              {
   1183                  for ( loopAddress = uAddress;
   1184                        loopAddress <= uAddressEnd;
   1185                        loopAddress += (0x0010U - (loopAddress & 0x000FU)) )
   1186                  {
   1187                      /* LLR-Ref: 060 */
   1188                      uAccessRightAddress = EEP_MEM_ACCESS_MAP_ADD + (loopAddress >> 6);
   1189          
   1190                      /* LLR-Ref: 070 */
   1191                      uAccessRowInByte = (loopAddress & 0x003F) >> 4;
   1192          
   1193                      /* LLR-Ref: 080 */
   1194                      ATA_FM_EEP_READ_BYTE_C(uAccessRightAddress, uAccessRightAddressValue)
   1195          
   1196                      if ( EECR2 & BM_E2FF )
   1197                      {
   1198                          /* LLR-Ref: 090 */
   1199                          retValue = EEC_ERROR_CORRECTION_OCCURED;
   1200                          break;
   1201                      }
   1202                      else
   1203                      {
   1204                          /* LLR-Ref: 100 */
   1205                          if ( (uAccessRightAddressValue & (BM_EEP_SECTION_ROW_0_WR_ACC >> (uAccessRowInByte * 2))) == FALSE )
   1206                          {
   1207                              retValue = EEC_ADDR_LOCKED_FOR_WRITING;
   1208                              break;
   1209                          }
   1210                      }
   1211                  }
   1212          
   1213                  /* LLR-Ref: 105 */
   1214                  EECR2 |= (BM_E2CF | BM_E2FF);
   1215                  
   1216                  if ( retValue == EEC_NO_ERROR )
   1217                  {
   1218                      while ( uLength > 0 )
   1219                      {
   1220                          /* LLR-Ref: 110 */
   1221                          /* Wait until EEPROM write operation has been finished.
   1222                             Put at the beginning, since no wait shall occur on the
   1223                             last write operation. */
   1224                          while(EECR & BM_NVMBSY){}
   1225          
   1226                          /* LLR-Ref: 120 */
   1227                          uByteCount = (0x0010U - (uAddress & 0x000FU));
   1228          
   1229                          if ( uLength < uByteCount )
   1230                          {
   1231                              uByteCount = uLength;
   1232                          }
   1233          
   1234                          /* LLR-Ref: 130 */
   1235                          ATA_FM_EEP_WRITE_MULTIPLE_BYTES_C(uAddress, uByteCount, pDataToWrite)
   1236          
   1237                          /* LLR-Ref: 140 */
   1238                          uAddress += uByteCount;
   1239                          uLength -= uByteCount;
   1240                      }
   1241                  }
   1242              }
   1243          
   1244              /* LLR-Ref: 150 */
   1245              SREG = bSreg;
   \                     ??ATA_eepWriteMultipleBytes_C_3:
   \   00000042   ....               RJMP    ?Subroutine1
   \                     ??ATA_eepWriteMultipleBytes_C_2:
   \   00000044   E801               LDI     R16, 129
   \   00000046   1600               CP      R0, R16
   \   00000048   E007               LDI     R16, 7
   \   0000004A   0710               CPC     R17, R16
   \   0000004C   F418               BRCC    ??ATA_eepWriteMultipleBytes_C_4
   \   0000004E   3861               CPI     R22, 129
   \   00000050   0770               CPC     R23, R16
   \   00000052   F010               BRCS    ??ATA_eepWriteMultipleBytes_C_5
   \                     ??ATA_eepWriteMultipleBytes_C_4:
   \   00000054   E022               LDI     R18, 2
   \   00000056   CFF5               RJMP    ??ATA_eepWriteMultipleBytes_C_3
   \                     ??ATA_eepWriteMultipleBytes_C_5:
   \   00000058   2DA0               MOV     R26, R0
   \   0000005A   2FB1               MOV     R27, R17
   \   0000005C   C007               RJMP    ??ATA_eepWriteMultipleBytes_C_6
   \                     ??ATA_eepWriteMultipleBytes_C_7:
   \   0000005E   01CD               MOVW    R25:R24, R27:R26
   \   00000060   9640               ADIW    R25:R24, 16
   \   00000062   2F0A               MOV     R16, R26
   \   00000064   700F               ANDI    R16, 0x0F
   \   00000066   01DC               MOVW    R27:R26, R25:R24
   \   00000068   1BA0               SUB     R26, R16
   \   0000006A   40B0               SBCI    R27, 0
   \                     ??ATA_eepWriteMultipleBytes_C_6:
   \   0000006C   176A               CP      R22, R26
   \   0000006E   077B               CPC     R23, R27
   \   00000070   F0D8               BRCS    ??ATA_eepWriteMultipleBytes_C_8
   \   00000072   E046               LDI     R20, 6
   \   00000074   018D               MOVW    R17:R16, R27:R26
   \   00000076   ........           CALL    ?US_SHR_L02
   \   0000007A   5B00               SUBI    R16, 176
   \   0000007C   4F18               SBCI    R17, 248
   \   0000007E   BD12               OUT     0x22, R17
   \   00000080   BD01               OUT     0x21, R16
   \   00000082   9AF8               SBI     0x1F, 0x00
   \   00000084   B510               IN      R17, 0x20
   \   00000086   9100....           LDS     R16, _A_EECR2
   \   0000008A   FF06               SBRS    R16, 6
   \   0000008C   C002               RJMP    ??ATA_eepWriteMultipleBytes_C_9
   \   0000008E   E024               LDI     R18, 4
   \   00000090   C00B               RJMP    ??ATA_eepWriteMultipleBytes_C_8
   \                     ??ATA_eepWriteMultipleBytes_C_9:
   \   00000092   2F4A               MOV     R20, R26
   \   00000094   9546               LSR     R20
   \   00000096   9546               LSR     R20
   \   00000098   9546               LSR     R20
   \   0000009A   7046               ANDI    R20, 0x06
   \   0000009C   E400               LDI     R16, 64
   \   0000009E   ........           CALL    ?UC_SHR_L01
   \   000000A2   2310               AND     R17, R16
   \   000000A4   F6E1               BRNE    ??ATA_eepWriteMultipleBytes_C_7
   \   000000A6   E022               LDI     R18, 2
   \                     ??ATA_eepWriteMultipleBytes_C_8:
   \   000000A8   9100....           LDS     R16, _A_EECR2
   \   000000AC   6C00               ORI     R16, 0xC0
   \   000000AE   9300....           STS     _A_EECR2, R16
   \   000000B2   2322               TST     R18
   \   000000B4   F631               BRNE    ??ATA_eepWriteMultipleBytes_C_3
   \   000000B6   C00F               RJMP    ??ATA_eepWriteMultipleBytes_C_10
   \                     ??ATA_eepWriteMultipleBytes_C_11:
   \   000000B8   BD51               OUT     0x21, R21
   \   000000BA   9111               LD      R17, Z+
   \   000000BC   BD10               OUT     0x20, R17
   \   000000BE   9553               INC     R21
   \   000000C0   9503               INC     R16
   \                     ??ATA_eepWriteMultipleBytes_C_12:
   \   000000C2   1704               CP      R16, R20
   \   000000C4   F3C8               BRCS    ??ATA_eepWriteMultipleBytes_C_11
   \   000000C6   B30F               IN      R16, 0x1F
   \   000000C8   7C0F               ANDI    R16, 0xCF
   \   000000CA   BB0F               OUT     0x1F, R16
   \   000000CC   9AFA               SBI     0x1F, 0x02
   \   000000CE   9AF9               SBI     0x1F, 0x01
   \   000000D0   0E04               ADD     R0, R20
   \   000000D2   1C13               ADC     R1, R3
   \   000000D4   1A24               SUB     R2, R20
   \                     ??ATA_eepWriteMultipleBytes_C_10:
   \   000000D6   2022               TST     R2
   \   000000D8   F409               BRNE    $+2+2
   \   000000DA   CFB3               RJMP    ??ATA_eepWriteMultipleBytes_C_3
   \                     ??ATA_eepWriteMultipleBytes_C_13:
   \   000000DC   99FF               SBIC    0x1F, 0x07
   \   000000DE   CFFE               RJMP    ??ATA_eepWriteMultipleBytes_C_13
   \   000000E0   E140               LDI     R20, 16
   \   000000E2   2D00               MOV     R16, R0
   \   000000E4   700F               ANDI    R16, 0x0F
   \   000000E6   1B40               SUB     R20, R16
   \   000000E8   1624               CP      R2, R20
   \   000000EA   F408               BRCC    ??ATA_eepWriteMultipleBytes_C_14
   \   000000EC   2D42               MOV     R20, R2
   \                     ??ATA_eepWriteMultipleBytes_C_14:
   \   000000EE   2D50               MOV     R21, R0
   \   000000F0   9AFE               SBI     0x1F, 0x06
   \   000000F2   BC12               OUT     0x22, R1
   \   000000F4   E000               LDI     R16, 0
   \   000000F6   CFE5               RJMP    ??ATA_eepWriteMultipleBytes_C_12
   \   000000F8                      REQUIRE _A_SREG
   \   000000F8                      REQUIRE _A_TRCDR
   \   000000F8                      REQUIRE _A_TRCIDL
   \   000000F8                      REQUIRE _A_TRCIDH
   \   000000F8                      REQUIRE _A_EECR
   \   000000F8                      REQUIRE _A_EEARH
   \   000000F8                      REQUIRE _A_EEARL
   \   000000F8                      REQUIRE _A_EEDR
   \   000000F8                      REQUIRE _A_EECR2
   1246          
   1247              /* LLR-Ref: 160 */
   1248              return retValue;
   1249          }

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      4   ATA_eepChangeAccessRights_C
      0      4   ATA_eepReadByte_C
      4      4   ATA_eepReadMultipleBytes_C
      0      4   ATA_eepWriteByte_C
      4      4   ATA_eepWriteMultipleBytes_C


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?Subroutine0
      10  ?Subroutine1
     242  ATA_eepChangeAccessRights_C
     138  ATA_eepReadByte_C
     214  ATA_eepReadMultipleBytes_C
     142  ATA_eepWriteByte_C
     248  ATA_eepWriteMultipleBytes_C
       1  _A_EEARH
       1  _A_EEARL
       1  _A_EECR
       1  _A_EECR2
       1  _A_EEDR
       1  _A_SREG
       1  _A_TRCDR
       1  _A_TRCIDH
       1  _A_TRCIDL
      11  eepLfDecoderSettings
      40  eepLfReceiverCalibration
      10  eepLfRssiSettings
       1  eepMvccSettlingTime
       4  eepRfTxRcc
      48  eepSecretKeyOne
      48  eepSecretKeyTwo
       1  eepSrcCalibration
       1  eepSrcTemperatureCompensation
       2  eepTransponderCalibValues
       4  eepXrowUniqueId
       6  g_sEepFacLockRfFrontend

 
   4 bytes in segment .eep_RfTx_RollingCodeSequenceCounter
  48 bytes in segment .eep_SecretKey_KeyOneSection
  48 bytes in segment .eep_SecretKey_KeyTwoSection
  11 bytes in segment .eep_xrow_LfDecoderSettings
  40 bytes in segment .eep_xrow_LfReceiverCalibRegister
  10 bytes in segment .eep_xrow_LfRssiSettings
   1 byte  in segment .eep_xrow_MvccSettlingTime
   6 bytes in segment .eep_xrow_RfFrontendCalibValues
   1 byte  in segment .eep_xrow_SrcCalibration
   1 byte  in segment .eep_xrow_SrcTemperatureCompensation
   2 bytes in segment .eep_xrow_TransponderCalibValues
   4 bytes in segment .eep_xrow_UniqueId
   9 bytes in segment ABSOLUTE
 998 bytes in segment CODE
 
 998 bytes of CODE memory
 176 bytes of DATA memory (+ 9 bytes shared)

Errors: none
Warnings: none
