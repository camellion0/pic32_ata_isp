###############################################################################
#
# IAR C/C++ Compiler V7.10.1.1197 for Atmel AVR           13/May/2020  17:03:23
# Copyright 1996-2017 IAR Systems AB.
# Network license: dvriar01.mchp-main.com (STD)
#
#    Source file  =  
#        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\firmware\lfrx\src\lfrx_immo_flash.c
#    Command line =  
#        -f C:\Users\C41045\AppData\Local\Temp\EW1B58.tmp
#        (C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\firmware\lfrx\src\lfrx_immo_flash.c
#        -v3 --enhanced_core -ms -o
#        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\Obj
#        -lCN
#        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\List
#        -lA
#        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\List
#        --no_cse --no_inline --no_code_motion --no_cross_call --no_clustering
#        --no_tbaa --debug --64k_flash -DENABLE_BIT_DEFINITIONS -e
#        --eeprom_size 2304 --clib -Ohz)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\List\lfrx_immo_flash.lst
#    Object file  =  
#        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\Obj\lfrx_immo_flash.r90
#
###############################################################################

C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\firmware\lfrx\src\lfrx_immo_flash.c
      1          //lint -e9059
      2          /******************************************************************************
      3            Use of this software is subject to Microchip's Software License Agreement.
      4          --------------------------------------------------------------------------------
      5            $URL: http://svnservulm.corp.atmel.com/svn/CDB/02_AutoRF/Primus2pSW/Branches/VB_PRIMUS2P_ROM_2.0/firmware/lfrx/src/lfrx_immo_flash.c $
      6            $LastChangedRevision: 303954 $
      7            $LastChangedDate: 2015-03-11 12:58:46 +0100 (Mi, 11 Mrz 2015) $
      8            $LastChangedBy: gwillbol $
      9          -------------------------------------------------------------------------------
     10            Project:      ATA5700
     11            Target MCU:   ATA5700
     12            Compiler:     IAR C/C++ Compiler for AVR 6.3.18.0
     13          -------------------------------------------------------------------------------
     14          
     15          ******************************************************************************
     16          * Copyright 2017, Microchip Technology Incorporated and its subsidiaries.     *
     17          *                                                                             *
     18          * This software is owned by the Microchip Technology Incorporated.            *
     19          * Microchip hereby grants to licensee a personal                              *
     20          * non-exclusive, non-transferable license to copy, use, modify, create        *
     21          * derivative works of, and compile the Microchip Source Code and derivative   *
     22          * works for the sole and exclusive purpose of creating custom software in     *
     23          * support of licensee product to be used only in conjunction with a Microchip *
     24          * integrated circuit as specified in the applicable agreement. Any            *        
     25          * reproduction, modification, translation, compilation, or representation of  *
     26          * this software except as specified above is prohibited without the express   *
     27          * written permission of Microchip.                                            *
     28          *                                                                             *
     29          * Disclaimer: MICROCHIP MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,    *
     30          * WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
     31          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
     32          * Microchip reserves the right to make changes without further notice to the  *
     33          * materials described herein. Microchip does not assume any liability arising *
     34          * out of the application or use of any product or circuit described herein.   *
     35          * Microchip does not authorize its products for use as critical components in *
     36          * life-support systems where a malfunction or failure may reasonably be       *
     37          * expected to result in significant injury to the user. The inclusion of      *
     38          * Microchip products in a life-support systems application implies that the   *
     39          * manufacturer assumes all risk of such use and in doing so indemnifies       *
     40          * Microchip against all charges.                                              *
     41          *                                                                             *
     42          * Use may be limited by and subject to the applicable Microchip software      *
     43          * license agreement.                                                          *
     44          ******************************************************************************/
     45          /** \file lfrx_immo.c
     46          */
     47          
     48          //lint -restore
     49          
     50          /*===========================================================================*/
     51          /*  INCLUDES                                                                 */
     52          /*===========================================================================*/
     53          #include "lfrx_immo_flash.h"

   \                                 In  segment ABSOLUTE, at 0x21
   \   union <unnamed> volatile __io _A_PRR1
   \                     _A_PRR1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x35
   \   union <unnamed> volatile __io _A_LTCMR
   \                     _A_LTCMR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x37
   \   union <unnamed> volatile __io _A_PHTCR
   \                     _A_PHTCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x38
   \   union <unnamed> volatile __io _A_LDFFL
   \                     _A_LDFFL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x39
   \   union <unnamed> volatile __io _A_LDFD
   \                     _A_LDFD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3a
   \   union <unnamed> volatile __io _A_PRR0
   \                     _A_PRR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3b
   \   union <unnamed> volatile __io _A_PHFR
   \                     _A_PHFR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x50
   \   union <unnamed> volatile __io _A_LFCR1
   \                     _A_LFCR1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x58
   \   union <unnamed> volatile __io _A_SMCR
   \                     _A_SMCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x18e
   \   union <unnamed> volatile __ext_io _A_LFCPR
   \                     _A_LFCPR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x194
   \   union <unnamed> volatile __ext_io _A_PHID0L
   \                     _A_PHID0L:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x199
   \   union <unnamed> volatile __ext_io _A_PHID1L
   \                     _A_PHID1L:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x19a
   \   union <unnamed> volatile __ext_io _A_PHIDFR
   \                     _A_PHIDFR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1a1
   \   union <unnamed> volatile __ext_io _A_LTCOR
   \                     _A_LTCOR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1a4
   \   union <unnamed> volatile __ext_io _A_PHTBLR
   \                     _A_PHTBLR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1a5
   \   union <unnamed> volatile __ext_io _A_PHDFR
   \                     _A_PHDFR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1a6
   \   union <unnamed> volatile __ext_io _A_LTEMR
   \                     _A_LTEMR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1d7
   \   union <unnamed> volatile __ext_io _A_LDFC
   \                     _A_LDFC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1d8
   \   union <unnamed> volatile __ext_io _A_PHIMR
   \                     _A_PHIMR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1d9
   \   union <unnamed> volatile __ext_io _A_PHCRCR
   \                     _A_PHCRCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1da
   \   union <unnamed> volatile __ext_io _A_PHCSTL
   \                     _A_PHCSTL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1db
   \   union <unnamed> volatile __ext_io _A_PHCSTH
   \                     _A_PHCSTH:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1dc
   \   union <unnamed> volatile __ext_io _A_PHCRPL
   \                     _A_PHCRPL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x1dd
   \   union <unnamed> volatile __ext_io _A_PHCRPH
   \                     _A_PHCRPH:
   \   00000000                      DS8 1
     54          #include "../../lfrx/src/lfrx_flash.h"
     55          #include "../../rftx/src/rftx.h"
     56          #include "../../spi/src/ata5700_command_set_flash.h"
     57          #include "../../eep/src/eep.h"
     58          #include "../../aes/src/aes.h"
     59          #include "../../globals/src/globals_flash.h"
     60          #include "../../lfrssi/src/lfrssi_flash.h"
     61          #include "../../rftx/src/rftx_flash.h"
     62          
     63          /*===========================================================================*/
     64          /*  DEFINES                                                                  */
     65          /*===========================================================================*/
     66          
     67          /*===========================================================================*/
     68          /*  Modul Globals                                                            */
     69          /*===========================================================================*/

   \                                 In  segment NEAR_N, align 1, keep-with-next
     70          __no_init static uint8_t m_bTempArray[40];
   \                     m_bTempArray:
   \   00000000                      DS8 40

   \                                 In  segment NEAR_N, align 1, keep-with-next
     71          __no_init static uint8_t m_bChallengeLengthBits_flash;
   \                     m_bChallengeLengthBits_flash:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_N, align 1, keep-with-next
     72          __no_init static uint8_t m_bResponseLengthBits_flash;
   \                     m_bResponseLengthBits_flash:
   \   00000000                      DS8 1
     73          
     74          
     75          /*===========================================================================*/
     76          /*  LOCAL PROTOTYPES                                                         */
     77          /*===========================================================================*/
     78          static void ATA_lfRxInitImmo_flash_C(void);
     79          static uint8_t ATA_lfRxParseCmdImmo_flash_C(void);
     80          static void ATA_lfRxAuthenticateImmo_flash_C(void);
     81          
     82          /*===========================================================================*/
     83          /*  IMPLEMENTATION                                                           */
     84          /*===========================================================================*/
     85          
     86          //-----------------------------------------------------------------------------
     87          /** \brief <b>ATA_lfRxRfTxProcessImmo_flash_C</b>
     88              does the process of one command reception via LF, command processing via AOI
     89              protocol and response via RF
     90          
     91              010:
     92          
     93              020:
     94          
     95              030:
     96          
     97          
     98              \param none
     99          
    100              \return none
    101          
    102              \Derived no
    103          
    104              \Rationale none
    105          
    106              \Traceability none
    107          
    108              \StackUsage SU_XXX bytes
    109          
    110              \image none
    111              \n
    112          */
    113          //-----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    114          void ATA_lfRxRfTxProcessImmo_flash_C(void)
   \                     ATA_lfRxRfTxProcessImmo_flash_C:
    115          //-----------------------------------------------------------------------------
    116          {
   \   00000000   938A               ST      -Y, R24
    117            uint8_t bRftxConfig = 0x48;
   \   00000002   E488               LDI     R24, 72
    118          
    119            /* Read the configuration byte present in EEPROM.
    120               Only used to distinguish between unilateral and bilateral authentication
    121               and CRC enabled/disabled configuration */
    122            ATA_eepReadBytes_C(&g_uTpConfig.bConfigbyte, 0x0800U, 0x01U);
   \   00000004   E041               LDI     R20, 1
   \   00000006   E020               LDI     R18, 0
   \   00000008   E038               LDI     R19, 8
   \   0000000A   ....               LDI     R16, LOW(g_uTpConfig)
   \   0000000C   ....               LDI     R17, (g_uTpConfig) >> 8
   \   0000000E   ........           CALL    ATA_eepReadBytes_C
    123          
    124            /* initialize for LF reception */
    125            ATA_lfRxInitImmo_flash_C();
   \   00000012   ....               RCALL   ATA_lfRxInitImmo_flash_C
    126            /* configure sleep mode power down */
    127            SMCR = 0x05;
   \   00000014   E005               LDI     R16, 5
   \   00000016   BF08               OUT     0x38, R16
   \   00000018   C002               RJMP    ??ATA_lfRxRfTxProcessImmo_flash_C_0
    128          
    129            /* sleep till complete frame is received */
    130            while(TRUE) {
    131              __disable_interrupt();
    132              if(g_bReceiveState > 2) {
    133                break;
    134              }
    135              __enable_interrupt();
   \                     ??ATA_lfRxRfTxProcessImmo_flash_C_1:
   \   0000001A   9478               SEI
    136              __sleep();
   \   0000001C   9588               SLEEP
   \                     ??ATA_lfRxRfTxProcessImmo_flash_C_0:
   \   0000001E   94F8               CLI
   \   00000020   9100....           LDS     R16, g_bReceiveState
   \   00000024   3003               CPI     R16, 3
   \   00000026   F3C8               BRCS    ??ATA_lfRxRfTxProcessImmo_flash_C_1
    137            }
    138          
    139            g_bReceiveState = 0;
   \   00000028   E000               LDI     R16, 0
   \   0000002A   9300....           STS     g_bReceiveState, R16
    140            __enable_interrupt();
   \   0000002E   9478               SEI
    141          
    142            g_bBytesToTransmit = ATA_lfRxParseCmdImmo_flash_C();
   \   00000030   ....               RCALL   ATA_lfRxParseCmdImmo_flash_C
   \   00000032   9300....           STS     g_bBytesToTransmit, R16
    143          
    144            if(g_bBytesToTransmit > 0) {
   \   00000036   2300               TST     R16
   \   00000038   F091               BREQ    ??ATA_lfRxRfTxProcessImmo_flash_C_2
    145          
    146              /* check if LF RSSI measurement has been done */
    147              if( extReq.lfrxRftxConfig & 0x06 )
   \   0000003A   9100....           LDS     R16, (extReq + 5)
   \   0000003E   7006               ANDI    R16, 0x06
   \   00000040   F031               BREQ    ??ATA_lfRxRfTxProcessImmo_flash_C_3
    148              {
    149                  ATA_lfRssiMeasConfig_flash_C( extReq.lfrxRftxConfig & 0x06 );
   \   00000042   9100....           LDS     R16, (extReq + 5)
   \   00000046   7006               ANDI    R16, 0x06
   \   00000048   ........           CALL    ATA_lfRssiMeasConfig_flash_C
    150                  bRftxConfig |= 0x04;  /* stay in TX after transmission */
   \   0000004C   E48C               LDI     R24, 76
    151              }
    152          
    153              /* start RF TX statemachine */
    154              uint16_t eepService = ATA_rfTxGetIndirectEEPromServiceConfigAddr_flash_C((uint16_t)&g_sCustomerEEPromSection.eepRfTxSer0Ptr_l);
   \                     ??ATA_lfRxRfTxProcessImmo_flash_C_3:
   \   0000004E   ....               LDI     R16, LOW((g_sCustomerEEPromSection + 108))
   \   00000050   ....               LDI     R17, HIGH((g_sCustomerEEPromSection + 108))
   \   00000052   ........           CALL    ATA_rfTxGetIndirectEEPromServiceConfigAddr_flash_C
   \   00000056   0198               MOVW    R19:R18, R17:R16
    155              ATA_rfTxStartTx_C(bRftxConfig, (uint8_t*)eepService);
   \   00000058   2F08               MOV     R16, R24
   \   0000005A   ........           CALL    ATA_rfTxStartTx_C
    156            }
    157            /* delete external request flag */
    158            extReq.lfrxRftxConfig &= ~BIT_MASK_0;
   \                     ??ATA_lfRxRfTxProcessImmo_flash_C_2:
   \   0000005E   ....               LDI     R30, LOW(extReq)
   \   00000060   ....               LDI     R31, (extReq) >> 8
   \   00000062   8105               LDD     R16, Z+5
   \   00000064   7F0E               ANDI    R16, 0xFE
   \   00000066   8305               STD     Z+5, R16
    159          }
   \   00000068                      REQUIRE ?Subroutine0
   \   00000068                      REQUIRE _A_SMCR
   \   00000068                      ;               // Fall through to label ?Subroutine0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9508               RET
    160          
    161          //-----------------------------------------------------------------------------
    162          /** \brief <b>ATA_lfRxInitImmo_flash_C</b>
    163              shall configure the transponder for AOIP command reception
    164          
    165              010:
    166          
    167              020:
    168          
    169              030:
    170          
    171          
    172              \param none
    173          
    174              \return none
    175          
    176              \Derived no
    177          
    178              \Rationale none
    179          
    180              \Traceability Primus2P-916, Primus2P-917, Primus2P-1226
    181          
    182              \StackUsage SU_XXX bytes
    183          
    184              \image none
    185              \n
    186          */
    187          //-----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    188          static void ATA_lfRxInitImmo_flash_C(void)
   \                     ATA_lfRxInitImmo_flash_C:
    189          //-----------------------------------------------------------------------------
    190          {
    191            /* LLR-Ref: Disable power reduction to serial peripheral interface. */
    192            PRR0 &= ~BM_PRCO;
   \   00000000   98D5               CBI     0x1A, 0x05
    193          
    194            /* LLR-Ref: Disable power reduction to LF receiver. */
    195            PRR1 &= ~(BM_PRLFR|BM_PRLFPH);
   \   00000002   B101               IN      R16, 0x01
   \   00000004   750F               ANDI    R16, 0x5F
   \   00000006   B901               OUT     0x01, R16
    196          
    197            /* LF synchronization stop bit */
    198            // LFSTOP = 0x4F; // symbols length = 4, symbols = b1111
    199          
    200            /* LF calibration protect */
    201            m_bTempArray[0] = 0x03;
   \   00000008   E003               LDI     R16, 3
   \   0000000A   9300....           STS     m_bTempArray, R16
    202            LFCPR = BM_LFCPCE;    // change enable
   \   0000000E   E800               LDI     R16, 128
   \   00000010   9300....           STS     _A_LFCPR, R16
    203            LFCPR = m_bTempArray[0]; // calibration ready, calibration protect
   \   00000014   E003               LDI     R16, 3
   \   00000016   9300....           STS     _A_LFCPR, R16
    204          
    205            /* LLR-Ref: Switch FIFO and CRC clock to AVR clock to do configuration. */
    206            ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)(BM_LDFSCKS | BM_LDFSCSW));
   \   0000001A   ........           CALL    ATA_globalsSwitchAvrPhClock_flash_C
    207          
    208            /* LLR-Ref: CRC settings. */
    209            // PHCRCR = 0x00;
    210            // PHCSTH = 0x00;
    211            // PHCSTL = 0x00;
    212            // PHCRPH = 0x00;
    213            // PHCRPL = 0x02;
    214            // PHCRCR = 0xC8;      /* CRC enable, strobe enable, CRC4, MSB, ID frame excluded */
    215          
    216            /* LLR-Ref: FIFO settings. */
    217            LDFC = 0x00|BM_LDFMSB;   /* Set fill level configuration to 0 */
   \   0000001E   E400               LDI     R16, 64
   \   00000020   9300....           STS     _A_LDFC, R16
    218            LDFFL = BM_LDFCLR;        /* clear RdPtr, WrPtr, fill-level, status and bit length */
   \   00000024   E800               LDI     R16, 128
   \   00000026   BB08               OUT     0x18, R16
    219            PHFR = 0x03;            /* clear bit length and CRC error flags */
   \   00000028   E003               LDI     R16, 3
   \   0000002A   BB0B               OUT     0x1B, R16
    220          
    221            /* LLR-Ref: Switch clocks back to protocol handler clock. */
    222            ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)0x00);
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   ........           CALL    ATA_globalsSwitchAvrPhClock_flash_C
    223          
    224            /* LLR-Ref: Interrupt settings. */
    225            // LFIMR = 0x00;       /* disable LF Interrupts */
    226            // PHIMR = BM_PHDFIM;  /* enable data frame interrupt (LFBCR_vect) */
    227            // LDFIM  = 0x00;       /* disable FIFO interrupts */
    228          
    229            /* LLR-Ref: Clear the reception buffer index for LF reception. */
    230            g_bRxBufferIndex = 0x00;
   \   00000032   E000               LDI     R16, 0
   \   00000034   9300....           STS     g_bRxBufferIndex, R16
    231          
    232            /* LLR-Ref: Update the number of bits to be received. */
    233            g_bBitsToReceive = 0x08;
   \   00000038   E008               LDI     R16, 8
   \   0000003A   9300....           STS     g_bBitsToReceive, R16
    234          
    235            /* LLR-Ref: Initialize receive state */
    236            g_bReceiveState = 0;
   \   0000003E   E000               LDI     R16, 0
   \   00000040   9300....           STS     g_bReceiveState, R16
    237          
    238            /* LLR-Ref: Enable response delay timer. */
    239            LTCOR = 58;        /* 62 * 32ms = 1984ms */
   \   00000044   E30A               LDI     R16, 58
   \   00000046   9300....           STS     _A_LTCOR, R16
    240            LTEMR = BM_TBLEM;  /* bit length reached triggers PH-timer event */
   \   0000004A   E100               LDI     R16, 16
   \   0000004C   9300....           STS     _A_LTEMR, R16
    241            LTCMR = 0x7A;      /* start timer on event, enable continuous mode, enable
   \   00000050   E70A               LDI     R16, 122
   \   00000052   BB05               OUT     0x15, R16
    242                                   interrupt, compare reset, prescaler value = 4 */
    243            g_bResponseDelayReached = FALSE; /* Reset response delay flag. */
   \   00000054   E000               LDI     R16, 0
   \   00000056   9300....           STS     g_bResponseDelayReached, R16
    244            LTCMR |= BM_LTENA;
   \   0000005A   9AAF               SBI     0x15, 0x07
    245          
    246            /* LLR-Ref: Start reception. */
    247            LFCR1 |= BM_LFRE;
   \   0000005C   B700               IN      R16, 0x30
   \   0000005E   6800               ORI     R16, 0x80
   \   00000060   BF00               OUT     0x30, R16
    248          }
   \   00000062   9508               RET
   \   00000064                      REQUIRE _A_PRR0
   \   00000064                      REQUIRE _A_PRR1
   \   00000064                      REQUIRE _A_LFCPR
   \   00000064                      REQUIRE _A_LDFC
   \   00000064                      REQUIRE _A_LDFFL
   \   00000064                      REQUIRE _A_PHFR
   \   00000064                      REQUIRE _A_LTCOR
   \   00000064                      REQUIRE _A_LTEMR
   \   00000064                      REQUIRE _A_LTCMR
   \   00000064                      REQUIRE _A_LFCR1
    249          
    250          //-----------------------------------------------------------------------------
    251          /** \brief <b>ATA_lfRxReinitImmo_flash_C</b>
    252              Function is called to reconfigure the LF receiver while receiving data.
    253              The reconfiguration is needed for commands which includes additional data
    254              after the command byte.
    255          
    256              010: Parse commands for reconfiguration.
    257          
    258              020: Reconfiguration of CRC (no clock switch has to be done cause data is
    259                   stored in shadow registers).
    260          
    261          
    262              \param none
    263          
    264              \return none
    265          
    266              \Derived no
    267          
    268              \Rationale none
    269          
    270              \Traceability Primus2P-1222
    271          
    272              \StackUsage SU_XXX bytes
    273          
    274              \image none
    275              \n
    276          */
    277          //-----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    278          void ATA_lfRxReinitImmo_flash_C(uint8_t bCmd4Bit)
   \                     ATA_lfRxReinitImmo_flash_C:
    279          //-----------------------------------------------------------------------------
    280          {
    281            /* LLR-Ref: 010 */
    282            if(bCmd4Bit == START_AUTH) {
   \   00000000   3001               CPI     R16, 1
   \   00000002   F4E9               BRNE    ??ATA_lfRxReinitImmo_flash_C_0
    283              /* read out challenge and response length from EEPROM */
    284              ATA_eepReadBytes_C(&m_bTempArray[0], (uint16_t)&g_sCustomerEEPromSection.eepCalLen, 0x02);
   \   00000004   E042               LDI     R20, 2
   \   00000006   ....               LDI     R18, LOW((g_sCustomerEEPromSection + 4))
   \   00000008   ....               LDI     R19, HIGH((g_sCustomerEEPromSection + 4))
   \   0000000A   ....               LDI     R16, LOW(m_bTempArray)
   \   0000000C   ....               LDI     R17, (m_bTempArray) >> 8
   \   0000000E   ........           CALL    ATA_eepReadBytes_C
    285              m_bChallengeLengthBits_flash = m_bTempArray[0];
   \   00000012   9100....           LDS     R16, m_bTempArray
   \   00000016   9300....           STS     m_bChallengeLengthBits_flash, R16
    286              m_bResponseLengthBits_flash = m_bTempArray[1];
   \   0000001A   9100....           LDS     R16, (m_bTempArray + 1)
   \   0000001E   9300....           STS     m_bResponseLengthBits_flash, R16
    287          
    288              if(g_uTpConfig.sConfigbits.CM == UNILATERAL) {
   \   00000022   9100....           LDS     R16, g_uTpConfig
   \   00000026   FD02               SBRC    R16, 2
   \   00000028   C003               RJMP    ??ATA_lfRxReinitImmo_flash_C_1
    289                g_bBitsToReceive = m_bChallengeLengthBits_flash;
   \   0000002A   9100....           LDS     R16, m_bChallengeLengthBits_flash
   \   0000002E   C005               RJMP    ??ATA_lfRxReinitImmo_flash_C_2
    290              }
    291              else {
    292                g_bBitsToReceive = m_bChallengeLengthBits_flash + m_bResponseLengthBits_flash;
   \                     ??ATA_lfRxReinitImmo_flash_C_1:
   \   00000030   9100....           LDS     R16, m_bChallengeLengthBits_flash
   \   00000034   9110....           LDS     R17, m_bResponseLengthBits_flash
   \   00000038   0F01               ADD     R16, R17
   \                     ??ATA_lfRxReinitImmo_flash_C_2:
   \   0000003A   9300....           STS     g_bBitsToReceive, R16
    293              }
    294            }
    295          
    296            PHID0L = 0;               /* disable ID0 */
   \                     ??ATA_lfRxReinitImmo_flash_C_0:
   \   0000003E   E000               LDI     R16, 0
   \   00000040   9300....           STS     _A_PHID0L, R16
    297            PHID1L = 0;               /* disable ID1 */
   \   00000044   9300....           STS     _A_PHID1L, R16
    298            PHIDFR = 0;               /* disable ID frame length */
   \   00000048   9300....           STS     _A_PHIDFR, R16
    299            PHTCR |= BM_CSM;          /* enable continue receive mode to transfer shadow register after telegram bit length reached */
   \   0000004C   9ABF               SBI     0x17, 0x07
    300            PHDFR = g_bBitsToReceive; /* data frame length */
   \   0000004E   9100....           LDS     R16, g_bBitsToReceive
   \   00000052   9300....           STS     _A_PHDFR, R16
    301            PHIMR = BM_PHTBLIM;       /* enable telegram bit length reached interrupt (LFBCR_vect) */
   \   00000056   E002               LDI     R16, 2
   \   00000058   9300....           STS     _A_PHIMR, R16
    302          
    303            /* LLR-Ref: 020 */
    304            if(g_uTpConfig.sConfigbits.DCD == 0) {  /* CRC enabled */
   \   0000005C   9100....           LDS     R16, g_uTpConfig
   \   00000060   FD00               SBRC    R16, 0
   \   00000062   C014               RJMP    ??ATA_lfRxReinitImmo_flash_C_3
    305              PHCRPH = 0;                   /* CRC polynomial */
   \   00000064   E000               LDI     R16, 0
   \   00000066   9300....           STS     _A_PHCRPH, R16
    306              PHCRPL = 0xCA;
   \   0000006A   EC0A               LDI     R16, 202
   \   0000006C   9300....           STS     _A_PHCRPL, R16
    307              PHCSTH = 0;
   \   00000070   E000               LDI     R16, 0
   \   00000072   9300....           STS     _A_PHCSTH, R16
    308              PHCSTL = 0x00;
   \   00000076   9300....           STS     _A_PHCSTL, R16
    309              PHCRCR = 0xD8;                 /* CRC enable, strobe enable, CRC8, MSB, ID frame excluded */
   \   0000007A   ED08               LDI     R16, 216
   \   0000007C   9300....           STS     _A_PHCRCR, R16
    310              PHTBLR = g_bBitsToReceive + 8; /* telegram bit length (+8 bit CRC) */
   \   00000080   9100....           LDS     R16, g_bBitsToReceive
   \   00000084   5F08               SUBI    R16, 248
   \   00000086   9300....           STS     _A_PHTBLR, R16
   \   0000008A   9508               RET
    311            }
    312            else {                                /* CRC disabled */
    313              PHTBLR = g_bBitsToReceive;     /* telegram bit length */
   \                     ??ATA_lfRxReinitImmo_flash_C_3:
   \   0000008C   9100....           LDS     R16, g_bBitsToReceive
   \   00000090   9300....           STS     _A_PHTBLR, R16
    314              PHCRCR = 0;                    /* disable CRC */
   \   00000094   E000               LDI     R16, 0
   \   00000096   9300....           STS     _A_PHCRCR, R16
    315            }
    316          }
   \   0000009A   9508               RET
   \   0000009C                      REQUIRE _A_PHID0L
   \   0000009C                      REQUIRE _A_PHID1L
   \   0000009C                      REQUIRE _A_PHIDFR
   \   0000009C                      REQUIRE _A_PHTCR
   \   0000009C                      REQUIRE _A_PHDFR
   \   0000009C                      REQUIRE _A_PHIMR
   \   0000009C                      REQUIRE _A_PHCRPH
   \   0000009C                      REQUIRE _A_PHCRPL
   \   0000009C                      REQUIRE _A_PHCSTH
   \   0000009C                      REQUIRE _A_PHCSTL
   \   0000009C                      REQUIRE _A_PHCRCR
   \   0000009C                      REQUIRE _A_PHTBLR
    317          
    318          //-----------------------------------------------------------------------------
    319          /** \brief <b>ATA_lfRxParseCmdImmo_flash_C</b>
    320              Function checks received command and prepares data for transmission.
    321          
    322              010:
    323          
    324              020:
    325          
    326              030:
    327          
    328          
    329              \param none
    330          
    331              \return [out] bBytesToTransmit  number of bytes to be send out
    332          
    333              \Derived no
    334          
    335              \Rationale none
    336          
    337              \Traceability Primus2P-922, Primus2P-924, Primus2P-925, Primus2P-927,
    338                            Primus2P-929, Primus2P-930, Primus2P-932, Primus2P-933,
    339                            Primus2P-934, Primus2P-936, Primus2P-938, Primus2P-939,
    340                            Primus2P-942, Primus2P-943, Primus2P-946, Primus2P-950,
    341                            Primus2P-952, Primus2P-956, Primus2P-957
    342          
    343              \StackUsage SU_XXX bytes
    344          
    345              \image none
    346              \n
    347          */
    348          //-----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    349          static uint8_t ATA_lfRxParseCmdImmo_flash_C(void)
   \                     ATA_lfRxParseCmdImmo_flash_C:
    350          //-----------------------------------------------------------------------------
    351          {
   \   00000000   938A               ST      -Y, R24
    352            /* variable to hold the command without CRC4 */
    353            uint8_t bCmd4Bit;
    354            /* variable to hold the byte count to be transmitted */
    355            uint8_t bBytesToTransmit = 1;
   \   00000002   E001               LDI     R16, 1
    356          
    357            /* extract the commmand from the received frame */
    358            g_bRxBuffer[0] >>= 4;
   \   00000004   9110....           LDS     R17, g_bRxBuffer
   \   00000008   9512               SWAP    R17
   \   0000000A   701F               ANDI    R17, 0x0F
   \   0000000C   9310....           STS     g_bRxBuffer, R17
    359            bCmd4Bit = g_bRxBuffer[0];
   \   00000010   9180....           LDS     R24, g_bRxBuffer
    360          
    361            if(g_bTpStatusByte == STATUS_SUCCESS) {
   \   00000014   9110....           LDS     R17, g_bTpStatusByte
   \   00000018   3F10               CPI     R17, 240
   \   0000001A   F469               BRNE    ??ATA_lfRxParseCmdImmo_flash_C_0
    362              g_bTxBuffer[0] = 0xFE;
   \   0000001C   EF0E               LDI     R16, 254
   \   0000001E   9300....           STS     g_bTxBuffer, R16
    363          
    364              /* if the command is to read the UID */
    365              if(bCmd4Bit == READ_UID) {
   \   00000022   2388               TST     R24
   \   00000024   F4D9               BRNE    ??ATA_lfRxParseCmdImmo_flash_C_1
    366                /* load the transmission buffer with UID present in EEPROM */
    367                ATA_eepReadBytes_C( &g_bTxBuffer[1], (uint16_t)&g_sAtmelEEPromSection.eepUID[0], 0x04U);
   \   00000026   E044               LDI     R20, 4
   \   00000028   ....               LDI     R18, LOW((g_sAtmelEEPromSection + 48))
   \   0000002A   ....               LDI     R19, HIGH((g_sAtmelEEPromSection + 48))
   \   0000002C   ....               LDI     R16, LOW((g_bTxBuffer + 1))
   \   0000002E   ....               LDI     R17, HIGH((g_bTxBuffer + 1))
   \   00000030   ........           CALL    ATA_eepReadBytes_C
    368                /* update the number of bytes to be transmitted */
    369                bBytesToTransmit = 5; // UID_SIZE + 1;
   \   00000034   E005               LDI     R16, 5
    370              }
    371          
    372              /* if the command is to start the authentication process */
    373              else if(bCmd4Bit == START_AUTH) {
    374          
    375                /* call the authentication processing function */
    376                ATA_lfRxAuthenticateImmo_flash_C();
    377          
    378                /* update the number of bytes to be transmitted */
    379                bBytesToTransmit = (m_bResponseLengthBits_flash >> 3) + 1;
    380              }
    381          
    382              else {
    383                /* any other cases nothing to be transmitted */
    384                g_bTpStatusByte = STATUS_COMMAND_NOT_SUPPORTED;
    385              }
    386            }
    387          
    388            if(g_bTpStatusByte != STATUS_SUCCESS) {
   \                     ??ATA_lfRxParseCmdImmo_flash_C_0:
   \   00000036   9110....           LDS     R17, g_bTpStatusByte
   \   0000003A   3F10               CPI     R17, 240
   \   0000003C   F009               BREQ    ??ATA_lfRxParseCmdImmo_flash_C_2
    389              bBytesToTransmit = 0;
   \                     ??ATA_lfRxParseCmdImmo_flash_C_3:
   \   0000003E   E000               LDI     R16, 0
    390            }
    391          
    392            /* update the status byte with the command */
    393            g_bTpStatusByte = ((bCmd4Bit << 4) | MASK_HIGH_NIBBLE) & g_bTpStatusByte;
   \                     ??ATA_lfRxParseCmdImmo_flash_C_2:
   \   00000040   2F18               MOV     R17, R24
   \   00000042   9512               SWAP    R17
   \   00000044   601F               ORI     R17, 0x0F
   \   00000046   9120....           LDS     R18, g_bTpStatusByte
   \   0000004A   2321               AND     R18, R17
   \   0000004C   9320....           STS     g_bTpStatusByte, R18
    394          
    395            if(   (bCmd4Bit > TP_ERR_STS)
    396               && (bCmd4Bit < RPT_LST_RES)) {
   \   00000050   5083               SUBI    R24, 3
   \   00000052   308B               CPI     R24, 11
   \   00000054   F410               BRCC    ??ATA_lfRxParseCmdImmo_flash_C_4
    397              /* update the transmission buffer with existing status byte */
    398              g_bTxBuffer[0] = g_bTpStatusByte;
   \   00000056   9320....           STS     g_bTxBuffer, R18
    399            }
    400          
    401            return bBytesToTransmit;
   \                     ??ATA_lfRxParseCmdImmo_flash_C_4:
   \   0000005A   ....               RJMP    ?Subroutine0
   \                     ??ATA_lfRxParseCmdImmo_flash_C_1:
   \   0000005C   3081               CPI     R24, 1
   \   0000005E   F441               BRNE    ??ATA_lfRxParseCmdImmo_flash_C_5
   \   00000060   ....               RCALL   ATA_lfRxAuthenticateImmo_flash_C
   \   00000062   9100....           LDS     R16, m_bResponseLengthBits_flash
   \   00000066   9506               LSR     R16
   \   00000068   9506               LSR     R16
   \   0000006A   9506               LSR     R16
   \   0000006C   9503               INC     R16
   \   0000006E   CFE3               RJMP    ??ATA_lfRxParseCmdImmo_flash_C_0
   \                     ??ATA_lfRxParseCmdImmo_flash_C_5:
   \   00000070   EF03               LDI     R16, 243
   \   00000072   9300....           STS     g_bTpStatusByte, R16
   \   00000076   CFE3               RJMP    ??ATA_lfRxParseCmdImmo_flash_C_3
    402          }
    403          
    404          //-----------------------------------------------------------------------------
    405          /** \brief <b>ATA_lfRxAuthenticateImmo_flash_C</b>
    406              Function handles the authentication process using the EEPROM data and the
    407              AES block whether unilateral or bilateral authentication is configured.
    408          
    409              010:
    410          
    411              020:
    412          
    413              030:
    414          
    415          
    416              \param none
    417          
    418              \return none
    419          
    420              \Derived no
    421          
    422              \Rationale none
    423          
    424              \Traceability Primus2P-924, Primus2P-925, Primus2P-956, Primus2P-1372,
    425                            Primus2P-1406
    426          
    427              \StackUsage SU_XXX bytes
    428          
    429              \image none
    430              \n
    431          */
    432          //-----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    433          static void ATA_lfRxAuthenticateImmo_flash_C(void)
   \                     ATA_lfRxAuthenticateImmo_flash_C:
    434          //-----------------------------------------------------------------------------
    435          {
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
    436              /* local value for calculation */
    437              uint8_t bIndex, i;
    438              /* value to hold the number of the actual secret key */
    439              uint8_t bKeySelect = 0;
   \   00000004   E000               LDI     R16, 0
    440              /* value to hold the number of challenge bytes */
    441              uint8_t bChallengeLengthBytes;
    442              /* value to hold the number of response bytes */
    443              uint8_t bResponseLengthBytes;
    444          
    445              /* check configuration which key schould be used first */
    446              if(g_uTpConfig.sConfigbits.KS == 1) {
   \   00000006   9110....           LDS     R17, g_uTpConfig
   \   0000000A   FD15               SBRC    R17, 5
    447                  bKeySelect = 1;
   \   0000000C   E001               LDI     R16, 1
    448              }
    449          
    450              ATA_aesSetConfig_C(bKeySelect, 0x02, 0x00U);
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_0:
   \   0000000E   E020               LDI     R18, 0
   \   00000010   E012               LDI     R17, 2
   \   00000012   ........           CALL    ATA_aesSetConfig_C
    451          
    452              bChallengeLengthBytes = m_bChallengeLengthBits_flash >> 3;
   \   00000016   9190....           LDS     R25, m_bChallengeLengthBits_flash
   \   0000001A   9596               LSR     R25
   \   0000001C   9596               LSR     R25
   \   0000001E   9596               LSR     R25
    453              for(bIndex = 0; bIndex < bChallengeLengthBytes; bIndex++) {
   \   00000020   E000               LDI     R16, 0
   \   00000022   C00B               RJMP    ??ATA_lfRxAuthenticateImmo_flash_C_1
    454                  g_sAesComponentData.bDataBuffer[bIndex] = g_bRxBuffer[1 + bIndex];
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_2:
   \   00000024   2FE0               MOV     R30, R16
   \   00000026   E0F0               LDI     R31, 0
   \   00000028   ....               SUBI    R30, LOW((-(g_bRxBuffer) & 0xFFFF))
   \   0000002A   ....               SBCI    R31, (-(g_bRxBuffer) & 0xFFFF) >> 8
   \   0000002C   8121               LDD     R18, Z+1
   \   0000002E   2FE0               MOV     R30, R16
   \   00000030   E0F0               LDI     R31, 0
   \   00000032   ....               SUBI    R30, LOW((-(g_sAesComponentData) & 0xFFFF))
   \   00000034   ....               SBCI    R31, (-(g_sAesComponentData) & 0xFFFF) >> 8
   \   00000036   8324               STD     Z+4, R18
    455              }
   \   00000038   9503               INC     R16
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_1:
   \   0000003A   1709               CP      R16, R25
   \   0000003C   F398               BRCS    ??ATA_lfRxAuthenticateImmo_flash_C_2
    456              /* Padding done manually cause different to ROM library */
    457              g_sAesComponentData.bDataLength = 128;
   \   0000003E   E810               LDI     R17, 128
   \   00000040   9310....           STS     (g_sAesComponentData + 20), R17
    458              m_bTempArray[ 0] = 0x12;
   \   00000044   E112               LDI     R17, 18
   \   00000046   9310....           STS     m_bTempArray, R17
    459              m_bTempArray[ 1] = 0x34;
   \   0000004A   E314               LDI     R17, 52
   \   0000004C   9310....           STS     (m_bTempArray + 1), R17
    460              m_bTempArray[ 2] = 0x56;
   \   00000050   E516               LDI     R17, 86
   \   00000052   9310....           STS     (m_bTempArray + 2), R17
    461              m_bTempArray[ 3] = 0x78;
   \   00000056   E718               LDI     R17, 120
   \   00000058   9310....           STS     (m_bTempArray + 3), R17
    462              m_bTempArray[ 4] = 0x00;
   \   0000005C   E010               LDI     R17, 0
   \   0000005E   9310....           STS     (m_bTempArray + 4), R17
    463              m_bTempArray[ 5] = 0x00;
   \   00000062   9310....           STS     (m_bTempArray + 5), R17
    464              m_bTempArray[ 6] = 0x00;
   \   00000066   9310....           STS     (m_bTempArray + 6), R17
    465              m_bTempArray[ 7] = 0x00;
   \   0000006A   9310....           STS     (m_bTempArray + 7), R17
    466              m_bTempArray[ 8] = 0x00;
   \   0000006E   9310....           STS     (m_bTempArray + 8), R17
    467              m_bTempArray[ 9] = 0x00;
   \   00000072   9310....           STS     (m_bTempArray + 9), R17
    468              m_bTempArray[10] = 0x00;
   \   00000076   9310....           STS     (m_bTempArray + 10), R17
    469              m_bTempArray[11] = 0x00;
   \   0000007A   9310....           STS     (m_bTempArray + 11), R17
    470              for(i = 0; bIndex < 16; bIndex++, i++) {
   \   0000007E   E020               LDI     R18, 0
   \   00000080   C00B               RJMP    ??ATA_lfRxAuthenticateImmo_flash_C_3
    471                  g_sAesComponentData.bDataBuffer[bIndex] = m_bTempArray[i];
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_4:
   \   00000082   E0F0               LDI     R31, 0
   \   00000084   2FE2               MOV     R30, R18
   \   00000086   ....               SUBI    R30, LOW((-(m_bTempArray) & 0xFFFF))
   \   00000088   ....               SBCI    R31, (-(m_bTempArray) & 0xFFFF) >> 8
   \   0000008A   8130               LD      R19, Z
   \   0000008C   01F8               MOVW    R31:R30, R17:R16
   \   0000008E   ....               SUBI    R30, LOW((-(g_sAesComponentData) & 0xFFFF))
   \   00000090   ....               SBCI    R31, (-(g_sAesComponentData) & 0xFFFF) >> 8
   \   00000092   8334               STD     Z+4, R19
    472              }
   \   00000094   9503               INC     R16
   \   00000096   9523               INC     R18
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_3:
   \   00000098   3100               CPI     R16, 16
   \   0000009A   F398               BRCS    ??ATA_lfRxAuthenticateImmo_flash_C_4
    473          
    474              ATA_aesEncryptData_C();
   \   0000009C   ........           CALL    ATA_aesEncryptData_C
    475          
    476              bResponseLengthBytes = m_bResponseLengthBits_flash >> 3;
   \   000000A0   9180....           LDS     R24, m_bResponseLengthBits_flash
   \   000000A4   9586               LSR     R24
   \   000000A6   9586               LSR     R24
   \   000000A8   9586               LSR     R24
    477          
    478              if(g_uTpConfig.sConfigbits.CM == BILATERAL) {
   \   000000AA   9100....           LDS     R16, g_uTpConfig
   \   000000AE   FF02               SBRS    R16, 2
   \   000000B0   C028               RJMP    ??ATA_lfRxAuthenticateImmo_flash_C_5
    479                  /* check if encrypted challenge correlate with received MAC */
    480                  i = bChallengeLengthBytes + 1;
   \   000000B2   9593               INC     R25
   \   000000B4   2F29               MOV     R18, R25
    481                  for(bIndex = 0; bIndex < bResponseLengthBytes; bIndex++, i++) {
   \   000000B6   E000               LDI     R16, 0
   \   000000B8   C011               RJMP    ??ATA_lfRxAuthenticateImmo_flash_C_6
    482                      if(g_bRxBuffer[i] != g_sAesComponentData.bDataBuffer[bIndex]) {
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_7:
   \   000000BA   E0F0               LDI     R31, 0
   \   000000BC   2FE2               MOV     R30, R18
   \   000000BE   ....               SUBI    R30, LOW((-(g_bRxBuffer) & 0xFFFF))
   \   000000C0   ....               SBCI    R31, (-(g_bRxBuffer) & 0xFFFF) >> 8
   \   000000C2   8130               LD      R19, Z
   \   000000C4   E0F0               LDI     R31, 0
   \   000000C6   2FE0               MOV     R30, R16
   \   000000C8   ....               SUBI    R30, LOW((-(g_sAesComponentData) & 0xFFFF))
   \   000000CA   ....               SBCI    R31, (-(g_sAesComponentData) & 0xFFFF) >> 8
   \   000000CC   8114               LDD     R17, Z+4
   \   000000CE   1731               CP      R19, R17
   \   000000D0   F019               BREQ    ??ATA_lfRxAuthenticateImmo_flash_C_8
    483                      g_bTpStatusByte = STATUS_BILATERAL_AUTHEN_FAILED;
   \   000000D2   EF16               LDI     R17, 246
   \   000000D4   9310....           STS     g_bTpStatusByte, R17
    484                      }
    485                  }
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_8:
   \   000000D8   9503               INC     R16
   \   000000DA   9523               INC     R18
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_6:
   \   000000DC   1708               CP      R16, R24
   \   000000DE   F368               BRCS    ??ATA_lfRxAuthenticateImmo_flash_C_7
    486                  if(g_bTpStatusByte == STATUS_SUCCESS) {
   \   000000E0   9100....           LDS     R16, g_bTpStatusByte
   \   000000E4   3F00               CPI     R16, 240
   \   000000E6   F469               BRNE    ??ATA_lfRxAuthenticateImmo_flash_C_5
    487                      /* check configuration which key schould be used second */
    488                      if(g_uTpConfig.sConfigbits.KS == 1) {
    489                          bKeySelect = 0;
    490                      }
    491                      else {
    492                          bKeySelect = 1;
    493                      }
    494                      ATA_aesSetConfig_C(bKeySelect, 0x02, 0x00);
   \   000000E8   E020               LDI     R18, 0
   \   000000EA   E012               LDI     R17, 2
   \   000000EC   9100....           LDS     R16, g_uTpConfig
   \   000000F0   FB05               BST     R16, 5
   \   000000F2   E000               LDI     R16, 0
   \   000000F4   F900               BLD     R16, 0
   \   000000F6   E031               LDI     R19, 1
   \   000000F8   2703               EOR     R16, R19
   \   000000FA   ........           CALL    ATA_aesSetConfig_C
    495          
    496                      ATA_aesEncryptData_C();
   \   000000FE   ........           CALL    ATA_aesEncryptData_C
    497                  }
    498              }
    499          
    500              /* copy encrypted data to TX buffer */
    501              for(bIndex = 0; bIndex < bResponseLengthBytes; bIndex++) {
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_5:
   \   00000102   E000               LDI     R16, 0
   \   00000104   C00B               RJMP    ??ATA_lfRxAuthenticateImmo_flash_C_9
    502                  g_bTxBuffer[1 + bIndex] = g_sAesComponentData.bDataBuffer[bIndex];
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_10:
   \   00000106   2FE0               MOV     R30, R16
   \   00000108   E0F0               LDI     R31, 0
   \   0000010A   ....               SUBI    R30, LOW((-(g_sAesComponentData) & 0xFFFF))
   \   0000010C   ....               SBCI    R31, (-(g_sAesComponentData) & 0xFFFF) >> 8
   \   0000010E   8124               LDD     R18, Z+4
   \   00000110   2FE0               MOV     R30, R16
   \   00000112   E0F0               LDI     R31, 0
   \   00000114   ....               SUBI    R30, LOW((-(g_bTxBuffer) & 0xFFFF))
   \   00000116   ....               SBCI    R31, (-(g_bTxBuffer) & 0xFFFF) >> 8
   \   00000118   8321               STD     Z+1, R18
    503              }
   \   0000011A   9503               INC     R16
   \                     ??ATA_lfRxAuthenticateImmo_flash_C_9:
   \   0000011C   1708               CP      R16, R24
   \   0000011E   F398               BRCS    ??ATA_lfRxAuthenticateImmo_flash_C_10
    504          }
   \   00000120   9189               LD      R24, Y+
   \   00000122   9199               LD      R25, Y+
   \   00000124   9508               RET
    505          
    506          //-----------------------------------------------------------------------------
    507          /** \brief <b>ATA_lfRxBitCntReachedImmo_flash_C</b>
    508              This function is serviced in after/while reception if the defined bit count
    509              is reached to reconfigure or stop the ongoing reception.
    510          
    511              010:
    512          
    513              020:
    514          
    515              030:
    516          
    517          
    518              \param none
    519          
    520              \return none
    521          
    522              \Derived no
    523          
    524              \Rationale none
    525          
    526              \Traceability none
    527          
    528              \StackUsage SU_XXX bytes
    529          
    530              \image none
    531              \n
    532          */
    533          //-----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    534          void ATA_lfRxBitCntReachedImmo_flash_C(void)
   \                     ATA_lfRxBitCntReachedImmo_flash_C:
    535          //-----------------------------------------------------------------------------
    536          {
    537            /* variable to hold the command without CRC4 */
    538            uint8_t bCmd4Bit;
    539            /* variable to hold count of bytes to be received */
    540            uint8_t bBytesToReceive;
    541          
    542            /* LLR-Ref: 040 */
    543            g_bReceiveState++;
    544          
    545            /* LLR-Ref: 045 */
    546            PHFR = (BM_PHTBLF | BM_PHDFF);
   \   00000000   E006               LDI     R16, 6
   \   00000002   BB0B               OUT     0x1B, R16
    547          
    548            /* LLR-Ref: 050 */
    549            if(g_bReceiveState > 1) {
   \   00000004   9100....           LDS     R16, g_bReceiveState
   \   00000008   9503               INC     R16
   \   0000000A   9300....           STS     g_bReceiveState, R16
   \   0000000E   3002               CPI     R16, 2
   \   00000010   F0C8               BRCS    ??ATA_lfRxBitCntReachedImmo_flash_C_0
    550              PHTCR &= ~BM_CSM;               /* disable continue receive mode */
   \   00000012   98BF               CBI     0x17, 0x07
    551              if(PHFR & BM_CRCEF) {
   \   00000014   9BD8               SBIS    0x1B, 0x00
   \   00000016   C012               RJMP    ??ATA_lfRxBitCntReachedImmo_flash_C_1
    552                g_bTpStatusByte = STATUS_CRC_INCORRECT;
   \   00000018   EF04               LDI     R16, 244
   \   0000001A   9300....           STS     g_bTpStatusByte, R16
    553                PHFR = BM_CRCEF;
   \   0000001E   E001               LDI     R16, 1
   \   00000020   BB0B               OUT     0x1B, R16
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_2:
   \   00000022   9100....           LDS     R16, g_bReceiveState
   \   00000026   3003               CPI     R16, 3
   \   00000028   F521               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_3
    554              }
    555              else {
    556                g_bTpStatusByte = STATUS_SUCCESS;
    557              }
    558            }
    559          
    560            /* LLR-Ref: 060 */
    561            if(   (g_bReceiveState == 1)
    562               || (g_bReceiveState == 3))
    563            {
    564              ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)(BM_LDFSCKS | BM_LDFSCSW));
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_4:
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   ........           CALL    ATA_globalsSwitchAvrPhClock_flash_C
    565          
    566              bBytesToReceive = g_bBitsToReceive >> 3;
   \   00000030   9100....           LDS     R16, g_bBitsToReceive
   \   00000034   9506               LSR     R16
   \   00000036   9506               LSR     R16
   \   00000038   9506               LSR     R16
   \   0000003A   C014               RJMP    ??ATA_lfRxBitCntReachedImmo_flash_C_5
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_1:
   \   0000003C   EF00               LDI     R16, 240
   \   0000003E   9300....           STS     g_bTpStatusByte, R16
   \   00000042   CFEF               RJMP    ??ATA_lfRxBitCntReachedImmo_flash_C_2
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_0:
   \   00000044   3001               CPI     R16, 1
   \   00000046   F4A9               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_3
   \   00000048   CFF0               RJMP    ??ATA_lfRxBitCntReachedImmo_flash_C_4
    567              while(bBytesToReceive > 0) {
    568                /* read data from protocol handler FIFO data register */
    569                g_bRxBuffer[g_bRxBufferIndex] = LDFD;
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_6:
   \   0000004A   B319               IN      R17, 0x19
   \   0000004C   91E0....           LDS     R30, g_bRxBufferIndex
   \   00000050   E0F0               LDI     R31, 0
   \   00000052   ....               SUBI    R30, LOW((-(g_bRxBuffer) & 0xFFFF))
   \   00000054   ....               SBCI    R31, (-(g_bRxBuffer) & 0xFFFF) >> 8
   \   00000056   8310               ST      Z, R17
    570                g_bRxBufferIndex += 1;
   \   00000058   9110....           LDS     R17, g_bRxBufferIndex
   \   0000005C   9513               INC     R17
   \   0000005E   9310....           STS     g_bRxBufferIndex, R17
    571                bBytesToReceive--;
   \   00000062   950A               DEC     R16
    572              }
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_5:
   \   00000064   2300               TST     R16
   \   00000066   F789               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_6
    573          
    574              LDFFL = 0x80;            /* clear RdPtr, WrPtr, fill-level, status and bit length */
   \   00000068   E800               LDI     R16, 128
   \   0000006A   BB08               OUT     0x18, R16
    575          
    576              ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)0x00);
   \   0000006C   E000               LDI     R16, 0
   \   0000006E   ........           CALL    ATA_globalsSwitchAvrPhClock_flash_C
    577            }
    578          
    579            /* LLR-Ref: 070 */
    580            bCmd4Bit = g_bRxBuffer[0];
    581            bCmd4Bit >>= 4;
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_3:
   \   00000072   9100....           LDS     R16, g_bRxBuffer
   \   00000076   9502               SWAP    R16
   \   00000078   700F               ANDI    R16, 0x0F
    582          
    583            /* LLR-Ref: 080 */
    584            if(   (g_bReceiveState == 1)
    585               && (   (bCmd4Bit == START_AUTH)
    586                   || ((bCmd4Bit >= READ_USR_MEM) && (bCmd4Bit <= LRN_SKT_K2)) ) ) {
   \   0000007A   9110....           LDS     R17, g_bReceiveState
   \   0000007E   3011               CPI     R17, 1
   \   00000080   F439               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_7
   \   00000082   3001               CPI     R16, 1
   \   00000084   F021               BREQ    ??ATA_lfRxBitCntReachedImmo_flash_C_8
   \   00000086   2F10               MOV     R17, R16
   \   00000088   5014               SUBI    R17, 4
   \   0000008A   3015               CPI     R17, 5
   \   0000008C   F4B0               BRCC    ??ATA_lfRxBitCntReachedImmo_flash_C_9
    587              ATA_lfRxReinitImmo_flash_C(bCmd4Bit);
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_8:
   \   0000008E   ....               RJMP    ATA_lfRxReinitImmo_flash_C
    588            }
    589            /* LLR-Ref: 090 */
    590            else if(g_bReceiveState == 1) {
    591              /* enable telegram bit length reached interrupt (LFBCR_vect) */
    592              PHIMR = BM_PHTBLIM;
    593              g_bReceiveState++;
    594            }
    595            /* LLR-Ref: 100 */
    596            else if(   (g_bReceiveState == 2)
    597                    && (g_bTpStatusByte == STATUS_SUCCESS)) {
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_7:
   \   00000090   3012               CPI     R17, 2
   \   00000092   F4B9               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_10
   \   00000094   9110....           LDS     R17, g_bTpStatusByte
   \   00000098   3F10               CPI     R17, 240
   \   0000009A   F4A1               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_11
    598              if(bCmd4Bit == WRT_USR_MEM) {
   \   0000009C   3005               CPI     R16, 5
   \   0000009E   F419               BRNE    ??ATA_lfRxBitCntReachedImmo_flash_C_12
    599                PHIMR = 0;          /* disable bit count reached interrupt (LFBCR_vect) */
   \   000000A0   E000               LDI     R16, 0
   \   000000A2   9300....           STS     _A_PHIMR, R16
    600              }
    601              if(LTEMR & BM_TBLEM) {
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_12:
   \   000000A6   9100....           LDS     R16, _A_LTEMR
   \   000000AA   FF04               SBRS    R16, 4
   \   000000AC   C01B               RJMP    ??ATA_lfRxBitCntReachedImmo_flash_C_13
    602                LTCMR &= ~BM_LTENA;
   \   000000AE   98AF               CBI     0x15, 0x07
    603                g_bResponseDelayReached = FALSE; /* Reset response delay flag. */
   \   000000B0   E000               LDI     R16, 0
   \   000000B2   9300....           STS     g_bResponseDelayReached, R16
    604                LTCMR |= BM_LTENA;
   \   000000B6   9AAF               SBI     0x15, 0x07
   \   000000B8   9508               RET
    605              }
    606            }
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_9:
   \   000000BA   E002               LDI     R16, 2
   \   000000BC   9300....           STS     _A_PHIMR, R16
   \   000000C0   C009               RJMP    ??ATA_lfRxBitCntReachedImmo_flash_C_14
    607            /* LLR-Ref: 105 */
    608            else if(   (g_bReceiveState > 1)
    609                    && (g_bTpStatusByte != STATUS_SUCCESS)) {
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_10:
   \   000000C2   F058               BRCS    ??ATA_lfRxBitCntReachedImmo_flash_C_15
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_11:
   \   000000C4   9100....           LDS     R16, g_bTpStatusByte
   \   000000C8   3F00               CPI     R16, 240
   \   000000CA   F039               BREQ    ??ATA_lfRxBitCntReachedImmo_flash_C_15
    610              /* disable protocol handler interrupts */
    611              PHIMR = 0;
   \   000000CC   E000               LDI     R16, 0
   \   000000CE   9300....           STS     _A_PHIMR, R16
    612              /* set receive state to value '2' to hold sleep in main function till
    613                 field timeout is detected */
    614              g_bReceiveState = 2;
   \   000000D2   E002               LDI     R16, 2
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_14:
   \   000000D4   9300....           STS     g_bReceiveState, R16
   \   000000D8   9508               RET
    615            }
    616            /* LLR-Ref: 110 */
    617            else {
    618              /* LLR-Ref: 120 */
    619              PHIMR = 0;
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_15:
   \   000000DA   E000               LDI     R16, 0
   \   000000DC   9300....           STS     _A_PHIMR, R16
    620              /* LLR-Ref: 140 */
    621              PHCRCR = 0x00;
   \   000000E0   9300....           STS     _A_PHCRCR, R16
    622            }
    623          }
   \                     ??ATA_lfRxBitCntReachedImmo_flash_C_13:
   \   000000E4   9508               RET
   \   000000E6                      REQUIRE _A_PHFR
   \   000000E6                      REQUIRE _A_PHTCR
   \   000000E6                      REQUIRE _A_LDFD
   \   000000E6                      REQUIRE _A_LDFFL
   \   000000E6                      REQUIRE _A_PHIMR
   \   000000E6                      REQUIRE _A_LTEMR
   \   000000E6                      REQUIRE _A_LTCMR
   \   000000E6                      REQUIRE _A_PHCRCR

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   ATA_lfRxAuthenticateImmo_flash_C
        2      2   -> ATA_aesEncryptData_C
        2      2   -> ATA_aesSetConfig_C
      0      2   ATA_lfRxBitCntReachedImmo_flash_C
        0      2   -> ATA_globalsSwitchAvrPhClock_flash_C
        0      2   -> ATA_lfRxReinitImmo_flash_C
      0      2   ATA_lfRxInitImmo_flash_C
        0      2   -> ATA_globalsSwitchAvrPhClock_flash_C
      1      2   ATA_lfRxParseCmdImmo_flash_C
        1      2   -> ATA_eepReadBytes_C
        1      2   -> ATA_lfRxAuthenticateImmo_flash_C
      0      2   ATA_lfRxReinitImmo_flash_C
        0      2   -> ATA_eepReadBytes_C
      1      2   ATA_lfRxRfTxProcessImmo_flash_C
        1      2   -> ATA_eepReadBytes_C
        1      2   -> ATA_lfRssiMeasConfig_flash_C
        1      2   -> ATA_lfRxInitImmo_flash_C
        1      2   -> ATA_lfRxParseCmdImmo_flash_C
        1      2   -> ATA_rfTxGetIndirectEEPromServiceConfigAddr_flash_C
        1      2   -> ATA_rfTxStartTx_C


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?Subroutine0
     294  ATA_lfRxAuthenticateImmo_flash_C
     230  ATA_lfRxBitCntReachedImmo_flash_C
     100  ATA_lfRxInitImmo_flash_C
     120  ATA_lfRxParseCmdImmo_flash_C
     156  ATA_lfRxReinitImmo_flash_C
     104  ATA_lfRxRfTxProcessImmo_flash_C
       1  _A_LDFC
       1  _A_LDFD
       1  _A_LDFFL
       1  _A_LFCPR
       1  _A_LFCR1
       1  _A_LTCMR
       1  _A_LTCOR
       1  _A_LTEMR
       1  _A_PHCRCR
       1  _A_PHCRPH
       1  _A_PHCRPL
       1  _A_PHCSTH
       1  _A_PHCSTL
       1  _A_PHDFR
       1  _A_PHFR
       1  _A_PHID0L
       1  _A_PHID1L
       1  _A_PHIDFR
       1  _A_PHIMR
       1  _A_PHTBLR
       1  _A_PHTCR
       1  _A_PRR0
       1  _A_PRR1
       1  _A_SMCR
       1  m_bChallengeLengthBits_flash
       1  m_bResponseLengthBits_flash
      40  m_bTempArray

 
    24 bytes in segment ABSOLUTE
 1 008 bytes in segment CODE
    42 bytes in segment NEAR_N
 
 1 008 bytes of CODE memory
    42 bytes of DATA memory (+ 24 bytes shared)

Errors: none
Warnings: none
