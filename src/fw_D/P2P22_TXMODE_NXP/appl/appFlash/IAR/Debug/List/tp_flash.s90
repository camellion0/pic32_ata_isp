///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.1.1197 for Atmel AVR          13/May/2020  17:03:25
// Copyright 1996-2017 IAR Systems AB.
// Network license: dvriar01.mchp-main.com (STD)
//
//    Source file  =  
//        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\firmware\tp\src\tp_flash.c
//    Command line =  
//        -f C:\Users\C41045\AppData\Local\Temp\EW233E.tmp
//        (C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\firmware\tp\src\tp_flash.c
//        -v3 --enhanced_core -ms -o
//        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\Obj
//        -lCN
//        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\List
//        -lA
//        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\List
//        --no_cse --no_inline --no_code_motion --no_cross_call --no_clustering
//        --no_tbaa --debug --64k_flash -DENABLE_BIT_DEFINITIONS -e
//        --eeprom_size 2304 --clib -Ohz)
//    Locale       =  English_USA.1252
//    List file    =  
//        C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\appl\appFlash\IAR\Debug\List\tp_flash.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME tp_flash

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__cpu", "3"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"
        RTMODEL "__vtable_memory", "__nearflash"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        PUBWEAK `??ATA_tpTimeoutError_flash_ISR_C::??INTVEC 128`
        PUBLIC ATA_tpEmModeCommandReconfiguration_flash_C
        PUBLIC ATA_tpEmModeInit_flash_C
        PUBLIC ATA_tpEmModeSingleTelProc_flash_C
        PUBLIC ATA_tpRxTxInit_flash_C
        PUBLIC ATA_tpTimeoutError_flash_ISR_C
        PUBWEAK _A_LDFC
        PUBWEAK _A_LDFD
        PUBWEAK _A_LDFFL
        PUBWEAK _A_LDFIM
        PUBWEAK _A_PHDFR
        PUBWEAK _A_PHFR
        PUBWEAK _A_PHID0L
        PUBWEAK _A_PHID1L
        PUBWEAK _A_PHIDFR
        PUBWEAK _A_PHIMR
        PUBWEAK _A_PHTBLR
        PUBWEAK _A_PHTCR
        PUBWEAK _A_TPCR3
        PUBWEAK _A_TPECMR
        PUBWEAK _A_TPECR1
        PUBWEAK _A_TPFR
        PUBWEAK _A_TPIMR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC g_bTpEmTransponderStateIndex_flash
        PUBLIC g_sTpRxTx
        
          CFI Names cfiNames0
          CFI StackFrame CFA_Y Y DATA
          CFI StackFrame CFA_SP SP DATA
          CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
          CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
          CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
          CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
          CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
          CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
          CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
          CFI ResourceParts SP SPH, SPL
          CFI ResourceParts Y R29, R28
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 Undefined
          CFI R17 Undefined
          CFI R18 Undefined
          CFI R19 Undefined
          CFI R20 Undefined
          CFI R21 Undefined
          CFI R22 Undefined
          CFI R23 Undefined
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 Undefined
          CFI R31 Undefined
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 SameValue
          CFI R17 SameValue
          CFI R18 SameValue
          CFI R19 SameValue
          CFI R20 SameValue
          CFI R21 SameValue
          CFI R22 SameValue
          CFI R23 SameValue
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 SameValue
          CFI R31 SameValue
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon1
        
ATA_tpTimeoutError_flash_ISR_C SYMBOL "ATA_tpTimeoutError_flash_ISR_C"
`??ATA_tpTimeoutError_flash_ISR_C::??INTVEC 128` SYMBOL "??INTVEC 128", ATA_tpTimeoutError_flash_ISR_C

        EXTERN ATA_eepReadBytes_C
        EXTERN ATA_globalsSwitchAvrPhClock_flash_C
        EXTERN ATA_systemSetEventPin_flash_ASM
        EXTERN g_sAtmelEEPromSection
        EXTERN g_sEventHandling_flash

// C:\Users\C41045\Documents\CDB\Apps\SW_Lib\Car_Access\CARS_GEN2\ATAB5702A\Branches\P2P22_TXMODE_NXP\firmware\tp\src\tp_flash.c
//    1 //lint -e9059
//    2 /******************************************************************************
//    3   Use of this software is subject to Microchip's Software License Agreement.
//    4 --------------------------------------------------------------------------------
//    5   $URL: http://svnservulm.corp.atmel.com/svn/CDB/Apps/SW_Lib/Car_Access/CARS_GEN2/ATAB5702A/Branches/P2P22_TXMODE_NXP/firmware/tp/src/tp_flash.c $
//    6   $LastChangedRevision: 458065 $
//    7   $LastChangedDate: 2017-05-02 04:55:50 -0600 (Tue, 02 May 2017) $
//    8   $LastChangedBy: krishna.balan $
//    9 -------------------------------------------------------------------------------
//   10   Project:      ATA5700
//   11   Target MCU:   ATA5700
//   12   Compiler:     IAR C/C++ Compiler for AVR 6.3.18.0
//   13 -------------------------------------------------------------------------------
//   14 
//   15 ******************************************************************************
//   16 * Copyright 2017, Microchip Technology Incorporated and its subsidiaries.     *
//   17 *                                                                             *
//   18 * This software is owned by the Microchip Technology Incorporated.            *
//   19 * Microchip hereby grants to licensee a personal                              *
//   20 * non-exclusive, non-transferable license to copy, use, modify, create        *
//   21 * derivative works of, and compile the Microchip Source Code and derivative   *
//   22 * works for the sole and exclusive purpose of creating custom software in     *
//   23 * support of licensee product to be used only in conjunction with a Microchip *
//   24 * integrated circuit as specified in the applicable agreement. Any            *        
//   25 * reproduction, modification, translation, compilation, or representation of  *
//   26 * this software except as specified above is prohibited without the express   *
//   27 * written permission of Microchip.                                            *
//   28 *                                                                             *
//   29 * Disclaimer: MICROCHIP MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,    *
//   30 * WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    *
//   31 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.         *
//   32 * Microchip reserves the right to make changes without further notice to the  *
//   33 * materials described herein. Microchip does not assume any liability arising *
//   34 * out of the application or use of any product or circuit described herein.   *
//   35 * Microchip does not authorize its products for use as critical components in *
//   36 * life-support systems where a malfunction or failure may reasonably be       *
//   37 * expected to result in significant injury to the user. The inclusion of      *
//   38 * Microchip products in a life-support systems application implies that the   *
//   39 * manufacturer assumes all risk of such use and in doing so indemnifies       *
//   40 * Microchip against all charges.                                              *
//   41 *                                                                             *
//   42 * Use may be limited by and subject to the applicable Microchip software      *
//   43 * license agreement.                                                          *
//   44 ******************************************************************************/
//   45 /** \file tp_flash.c
//   46 */
//   47 
//   48 //lint -restore
//   49 
//   50 /*===========================================================================*/
//   51 /*  INCLUDES                                                                 */
//   52 /*===========================================================================*/
//   53 #include "tp_flash.h"

        ASEGN ABSOLUTE:DATA:NOROOT,02dH
// union <unnamed> volatile __io _A_TPFR
_A_TPFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,037H
// union <unnamed> volatile __io _A_PHTCR
_A_PHTCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,038H
// union <unnamed> volatile __io _A_LDFFL
_A_LDFFL:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,039H
// union <unnamed> volatile __io _A_LDFD
_A_LDFD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,03bH
// union <unnamed> volatile __io _A_PHFR
_A_PHFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0166H
// union <unnamed> volatile __ext_io _A_TPIMR
_A_TPIMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,016cH
// union <unnamed> volatile __ext_io _A_TPECR1
_A_TPECR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0170H
// union <unnamed> volatile __ext_io _A_TPECMR
_A_TPECMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0171H
// union <unnamed> volatile __ext_io _A_TPCR3
_A_TPCR3:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0194H
// union <unnamed> volatile __ext_io _A_PHID0L
_A_PHID0L:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0199H
// union <unnamed> volatile __ext_io _A_PHID1L
_A_PHID1L:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,019aH
// union <unnamed> volatile __ext_io _A_PHIDFR
_A_PHIDFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,01a4H
// union <unnamed> volatile __ext_io _A_PHTBLR
_A_PHTBLR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,01a5H
// union <unnamed> volatile __ext_io _A_PHDFR
_A_PHDFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,01d6H
// union <unnamed> volatile __ext_io _A_LDFIM
_A_LDFIM:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,01d7H
// union <unnamed> volatile __ext_io _A_LDFC
_A_LDFC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,01d8H
// union <unnamed> volatile __ext_io _A_PHIMR
_A_PHIMR:
        DS8 1
//   54 #include "../../eep/src/eep.h"
//   55 #include "../../init/src/init_flash.h"
//   56 #include "../../system/src/system_flash.h"
//   57 #include "../../globals/src/globals_flash.h"
//   58 
//   59 /*===========================================================================*/
//   60 /*  DEFINES                                                                  */
//   61 /*===========================================================================*/
//   62 
//   63 /*===========================================================================*/
//   64 /*  Modul Globals                                                            */
//   65 /*===========================================================================*/
//   66 
//   67 /** \brief <b>tpRxTx</b>
//   68     contains the Transponder configuration
//   69 */
//   70 #pragma location = ".sram_FlashApp_TpRxTx"

        RSEG `.sram_FlashApp_TpRxTx`:DATA:ROOT(0)
//   71 __root __no_init sTpRxTxConfig g_sTpRxTx;
g_sTpRxTx:
        DS8 3
//   72 
//   73 /** \brief <b>g_bLfRxEmTransponderModeCommand_flash</b>
//   74     contains which EM Transponder Mode command has been received
//   75 */
//   76 #pragma location = ".sram_FlashApp_TpRxTx"

        RSEG `.sram_FlashApp_TpRxTx`:DATA:ROOT(0)
//   77 __root __no_init static uint8_t g_bTpEmTransponderModeCommand_flash;
g_bTpEmTransponderModeCommand_flash:
        DS8 1
//   78 
//   79 /** \brief <b>g_bTpEmTransponderStateIndex_flash</b>
//   80     contains the EM Mode SW state
//   81 */
//   82 #pragma location = ".sram_FlashApp_TpRxTx"

        RSEG `.sram_FlashApp_TpRxTx`:DATA:ROOT(0)
//   83 __root __no_init uint8_t g_bTpEmTransponderStateIndex_flash;
g_bTpEmTransponderStateIndex_flash:
        DS8 1
//   84 
//   85 /** \brief <b>g_fTpEmTransponderModeErrorFlag_flash</b>
//   86     indicates any EM Transponder Mode error
//   87 */
//   88 #pragma location = ".sram_FlashApp_TpRxTx"

        RSEG `.sram_FlashApp_TpRxTx`:DATA:ROOT(0)
//   89 __root __no_init static uint8_t g_fTpEmTransponderModeErrorFlag_flash;
g_fTpEmTransponderModeErrorFlag_flash:
        DS8 1
//   90 
//   91 
//   92 /** \brief <b>g_fTpEmTransponderModeLongCommand_flash</b>
//   93     indicates the reception of a long EM Transponder Mode command, e.g.
//   94     Authentication
//   95 */
//   96 #pragma location = ".sram_FlashApp_TpRxTx"

        RSEG `.sram_FlashApp_TpRxTx`:DATA:ROOT(0)
//   97 __root __no_init static uint8_t g_fTpEmTransponderModeLongCommand_flash;
g_fTpEmTransponderModeLongCommand_flash:
        DS8 1
//   98 
//   99 
//  100 
//  101 /*===========================================================================*/
//  102 /*  Modul Globals                                                            */
//  103 /*===========================================================================*/
//  104 
//  105 /*===========================================================================*/
//  106 /*  IMPLEMENTATION                                                           */
//  107 /*===========================================================================*/
//  108 
//  109 /**/

        RSEG CODE:CODE:ROOT(1)
//  110 VOIDFUNC ATA_tpEmModeInit_flash_C(void)
ATA_tpEmModeInit_flash_C:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function ATA_tpEmModeInit_flash_C
//  111 {
//  112     /* Reset long command indication */
//  113     g_fTpEmTransponderModeLongCommand_flash = FALSE;
        LDI     R16, 0
        STS     g_fTpEmTransponderModeLongCommand_flash, R16
//  114     g_fTpEmTransponderModeErrorFlag_flash = 0x00U;
        STS     g_fTpEmTransponderModeErrorFlag_flash, R16
//  115 
//  116     /* disable ID0 and ID1 */
//  117     PHID0L = 0x00U;
        STS     _A_PHID0L, R16
//  118     PHID1L = 0x00U;
        STS     _A_PHID1L, R16
//  119 
//  120     /* Set ID frame length to 3 bit to be able to set the parity bit length
//  121        when BCR interrupt is executed. */
//  122     PHIDFR = 0x03U;
        LDI     R16, 3
        STS     _A_PHIDFR, R16
//  123 
//  124     /* data frame length 4 bit */
//  125     PHDFR  = 0x04U;
        LDI     R16, 4
        STS     _A_PHDFR, R16
//  126 
//  127     /* telegram bit length 4 bit */
//  128     PHTBLR = 0x04U;
        STS     _A_PHTBLR, R16
//  129 
//  130     /* LLR-Ref: 050 */
//  131     PHTCR &= ~BM_CSM;
        CBI     0x17, 0x07
//  132     PHTCR |= BM_FRFIFO;
        SBI     0x17, 0x05
//  133     ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)(BM_LDFSCKS | BM_LDFSCSW));
        LDI     R16, 3
          CFI FunCall ATA_globalsSwitchAvrPhClock_flash_C
        CALL    ATA_globalsSwitchAvrPhClock_flash_C
//  134 
//  135     /* LLR-Ref: 070 */
//  136     LDFC = 0x00U|BM_LDFMSB;  /* Set fill level configuration to 0 */
        LDI     R16, 64
        STS     _A_LDFC, R16
//  137     LDFFL = BM_LDFCLR;        /* clear RdPtr, WrPtr, fill-level, status and bit length */
        LDI     R16, 128
        OUT     0x18, R16
//  138     PHFR = 0x07;            /* clear data frame, bit length and CRC error flags */
        LDI     R16, 7
        OUT     0x1B, R16
//  139 
//  140     /* LLR-Ref: 080 */
//  141     ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)0x00U);
        LDI     R16, 0
          CFI FunCall ATA_globalsSwitchAvrPhClock_flash_C
        CALL    ATA_globalsSwitchAvrPhClock_flash_C
//  142 
//  143     /* LLR-Ref: 090 */
//  144     TPIMR &= ~BM_TPFTIM;                /* disable transponder field timeout interrupt (TPTOERR_vect) */
        LDS     R16, 358
        ANDI    R16, 0xFD
        STS     358, R16
//  145     PHIMR = (BM_PHIDFIM | BM_PHTBLIM);  /* disable data frame interrupt (LFBCR_vect)
        LDI     R16, 10
        STS     _A_PHIMR, R16
//  146                                            enable bit count reached interrupt ()
//  147                                            enable ID Frame interrupt
//  148                                         */
//  149     LDFIM  = 0x00U;                      /* disable FIFO interrupts */
        LDI     R16, 0
        STS     _A_LDFIM, R16
//  150 
//  151 
//  152     /* LLR-Ref: 120 */
//  153     TPCR3 |= (BM_TPRD | BM_TPTLIW);
        LDS     R16, _A_TPCR3
        ORI     R16, 0x06
        STS     _A_TPCR3, R16
//  154 }
        RET
          CFI EndBlock cfiBlock0
        REQUIRE _A_PHID0L
        REQUIRE _A_PHID1L
        REQUIRE _A_PHIDFR
        REQUIRE _A_PHDFR
        REQUIRE _A_PHTBLR
        REQUIRE _A_PHTCR
        REQUIRE _A_LDFC
        REQUIRE _A_LDFFL
        REQUIRE _A_PHFR
        REQUIRE _A_TPIMR
        REQUIRE _A_PHIMR
        REQUIRE _A_LDFIM
        REQUIRE _A_TPCR3
//  155 
//  156 
//  157 /* function will be executed in an interrupt context */

        RSEG CODE:CODE:ROOT(1)
//  158 VOIDFUNC ATA_tpEmModeCommandReconfiguration_flash_C(void)
ATA_tpEmModeCommandReconfiguration_flash_C:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function ATA_tpEmModeCommandReconfiguration_flash_C
//  159 {
//  160     /* Retrieve the received command ID, switch FIFO clock */
//  161     ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)(BM_LDFSCKS | BM_LDFSCSW));
        LDI     R16, 3
          CFI FunCall ATA_globalsSwitchAvrPhClock_flash_C
        CALL    ATA_globalsSwitchAvrPhClock_flash_C
//  162     
//  163     /* Store EM command ID */
//  164     g_bTpEmTransponderModeCommand_flash = LDFD;
//  165     g_bTpEmTransponderModeCommand_flash >>= 5;
        IN      R16, 0x19
        SWAP    R16
        ANDI    R16, 0x0F
        LSR     R16
        STS     g_bTpEmTransponderModeCommand_flash, R16
//  166     
//  167     /* If command ID is set to ID mode */
//  168     switch (g_bTpEmTransponderModeCommand_flash)
        CPI     R16, 3
        BRNE    ??ATA_tpEmModeCommandReconfiguration_flash_C_0
//  169     {
//  170         case EM_CMD_ID_MODE:
//  171           break;
//  172 
//  173         case EM_CMD_AUTHENTICATION:
//  174           /* data frame and telegram bit length to 36 bit */
//  175           PHDFR  = 0x24U;
        LDI     R16, 36
        STS     _A_PHDFR, R16
//  176           PHTBLR = 0x24U;
        STS     _A_PHTBLR, R16
//  177           break;
//  178 
//  179         default:
//  180           break;
//  181     }
//  182 
//  183     /**/
//  184     ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)0x00U);
??ATA_tpEmModeCommandReconfiguration_flash_C_0:
        LDI     R16, 0
          CFI FunCall ATA_globalsSwitchAvrPhClock_flash_C
        JMP     ATA_globalsSwitchAvrPhClock_flash_C
          CFI EndBlock cfiBlock1
        REQUIRE _A_LDFD
        REQUIRE _A_PHDFR
        REQUIRE _A_PHTBLR
//  185 }
//  186 
//  187 
//  188 /* function will be executed in an interrupt context */

        RSEG CODE:CODE:ROOT(1)
//  189 VOIDFUNC ATA_tpEmModeSingleTelProc_flash_C(void)
ATA_tpEmModeSingleTelProc_flash_C:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function ATA_tpEmModeSingleTelProc_flash_C
//  190 {
        SBIW    R29:R28, 4
          CFI CFA_Y Y+4
//  191     /* Variable to hold the function's return value. */
//  192     eEepErrorCode eepErrorCode = EEC_NO_ERROR;
//  193     uint8_t tempDataBuffer[EEP_XROW_UID_SIZE];
//  194     uint8_t bParityBitValue;
//  195 
//  196     /* Retrieve the received command ID, switch FIFO clock */
//  197     ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)(BM_LDFSCKS | BM_LDFSCSW));
        LDI     R16, 3
          CFI FunCall ATA_globalsSwitchAvrPhClock_flash_C
        CALL    ATA_globalsSwitchAvrPhClock_flash_C
//  198 
//  199     /* If command ID is set to ID mode */
//  200     switch (g_bTpEmTransponderModeCommand_flash)
        LDS     R16, g_bTpEmTransponderModeCommand_flash
        DEC     R16
        BREQ    ??ATA_tpEmModeSingleTelProc_flash_C_0
        SUBI    R16, 2
        BREQ    ??ATA_tpEmModeSingleTelProc_flash_C_1
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_2
//  201     {
//  202         case EM_CMD_ID_MODE:
//  203 
//  204             /* Store EM command ID parity bit */
//  205             bParityBitValue = LDFD;
//  206             bParityBitValue >>= 7;
//  207             
//  208             if (bParityBitValue == EM_CMD_ID_MODE_PARITY)
??ATA_tpEmModeSingleTelProc_flash_C_0:
        SBIS    0x19, 0x07
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_2
//  209             {
//  210                 /* Disable Transponder reception, since a response is required */
//  211                 TPCR3 &= ~ (BM_TPRD | BM_TPTLIW);
        LDS     R16, _A_TPCR3
        ANDI    R16, 0xF9
        STS     _A_TPCR3, R16
//  212 
//  213                 /* LLR-Ref: 000 */
//  214                 PHDFR  = 0x32U;              /* data frame length 50 bit */
        LDI     R16, 50
        STS     _A_PHDFR, R16
//  215                 PHTBLR = 0x32U;              /* telegram bit length 50 bit */
        STS     _A_PHTBLR, R16
//  216 
//  217                 /* LLR-Ref: 000 */
//  218                 LDFC = (BM_LDFMSB);  /* Set fill level configuration to 0 */
        LDI     R16, 64
        STS     _A_LDFC, R16
//  219                 LDFFL = 0x80U;       /* clear RdPtr, WrPtr, fill-level, status and bit length */
        LDI     R16, 128
        OUT     0x18, R16
//  220                 LDFIM = 0x00U;       /* disable interrupts */
        LDI     R16, 0
        STS     _A_LDFIM, R16
//  221 
//  222                 /* Write data to PH FIFO: First header 12 Bit 1's and 4 Bit 0's */
//  223                 LDFD = 0xFFU;
        LDI     R16, 255
        OUT     0x19, R16
//  224                 LDFD = 0xF0U;
        LDI     R16, 240
        OUT     0x19, R16
//  225 
//  226                 /* Set Manchester encoding and bit length */
//  227                 TPECMR = 0xFFU;
        LDI     R16, 255
        STS     _A_TPECMR, R16
//  228                 TPECR1 = 0x32U;
        LDI     R16, 50
        STS     _A_TPECR1, R16
//  229 
//  230                 /* Fill EEPROM UID of 32 bits */
//  231                 eepErrorCode = ATA_eepReadBytes_C(&tempDataBuffer[0], (uint16_t)&g_sAtmelEEPromSection.eepUID[0], EEP_XROW_UID_SIZE);
        LDI     R20, 4
        LDI     R18, LOW((g_sAtmelEEPromSection + 48))
        LDI     R19, HIGH((g_sAtmelEEPromSection + 48))
        MOVW    R17:R16, R29:R28
          CFI FunCall ATA_eepReadBytes_C
        CALL    ATA_eepReadBytes_C
        MOV     R20, R16
//  232 
//  233                 /* UID is stored MSB-wise in V2.0, thus this code is correct */
//  234                 for (uint8_t i = 0; i < EEP_XROW_UID_SIZE; i++)
        LDI     R18, 0
        LDI     R16, 4
        LDI     R19, 0
//  235                 {
//  236                     if (eepErrorCode == EEC_NO_ERROR)
??ATA_tpEmModeSingleTelProc_flash_C_3:
        TST     R20
        BRNE    ??ATA_tpEmModeSingleTelProc_flash_C_4
//  237                     {
//  238                         LDFD = tempDataBuffer[i];
        MOVW    R31:R30, R29:R28
        ADD     R30, R18
        ADC     R31, R19
        LD      R17, Z
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_5
//  239                     }
//  240                     else
//  241                     {
//  242                         LDFD = 0x55U;
??ATA_tpEmModeSingleTelProc_flash_C_4:
        LDI     R17, 85
??ATA_tpEmModeSingleTelProc_flash_C_5:
        OUT     0x19, R17
//  243                     }
//  244                 }
        INC     R18
        DEC     R16
        BRNE    ??ATA_tpEmModeSingleTelProc_flash_C_3
//  245 
//  246                 /* Add two trailing bits to have a none byte-aligned response. */
//  247                 LDFD = 0xC0U;
        LDI     R16, 192
        OUT     0x19, R16
//  248 
//  249                 /* Enable Transponder trasmit sequence */
//  250                 TPCR3 |= BM_TPTD;
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_6
//  251             }
//  252             break;
//  253 
//  254         case EM_CMD_AUTHENTICATION:
//  255 
//  256             /* Only the first part of the AUTHENTICATION message has been
//  257                received */
//  258             if ( g_fTpEmTransponderModeLongCommand_flash == FALSE )
??ATA_tpEmModeSingleTelProc_flash_C_1:
        LDS     R16, g_fTpEmTransponderModeLongCommand_flash
        TST     R16
        BRNE    ??ATA_tpEmModeSingleTelProc_flash_C_7
//  259             {
//  260                 g_fTpEmTransponderModeLongCommand_flash = TRUE;
        LDI     R16, 1
        STS     g_fTpEmTransponderModeLongCommand_flash, R16
//  261 
//  262                 /* Store AUTHENTICATION command ID parity bit */
//  263                 bParityBitValue = LDFD;
//  264                 bParityBitValue >>= 7;
//  265 
//  266                 if (bParityBitValue != EM_CMD_AUTHENTICATION_PARITY)
        SBIS    0x19, 0x07
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_2
//  267                 {
//  268                     g_fTpEmTransponderModeErrorFlag_flash = 0x01U;
        STS     g_fTpEmTransponderModeErrorFlag_flash, R16
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_2
//  269                 }
//  270             }
//  271             else
//  272             {
//  273                 /* Send ACK if command ID and parity do match, i.e. no error is flagged */
//  274                 if ( g_fTpEmTransponderModeErrorFlag_flash == 0x00U )
??ATA_tpEmModeSingleTelProc_flash_C_7:
        LDS     R16, g_fTpEmTransponderModeErrorFlag_flash
        TST     R16
        LDS     R16, _A_TPCR3
        BRNE    ??ATA_tpEmModeSingleTelProc_flash_C_8
//  275                 {
//  276                     /* Disable Transponder reception, since a response is required */
//  277                     TPCR3 &= ~ (BM_TPRD | BM_TPTLIW);
        ANDI    R16, 0xF9
        STS     _A_TPCR3, R16
//  278 
//  279                     /* Send NACK, since parity bit is wrong */
//  280                     PHDFR  = 0x0AU;              /* data frame length 10 bit */
        LDI     R16, 10
        STS     _A_PHDFR, R16
//  281                     PHTBLR = 0x0AU;              /* telegram bit length 10 bit */
        STS     _A_PHTBLR, R16
//  282 
//  283                     LDFC = (BM_LDFMSB);  /* Set fill level configuration to 0 */
        LDI     R16, 64
        STS     _A_LDFC, R16
//  284                     LDFFL = 0x80U;       /* clear RdPtr, WrPtr, fill-level, status and bit length */
        LDI     R16, 128
        OUT     0x18, R16
//  285                     LDFIM = 0x00U;       /* disable interrupts */
        LDI     R16, 0
        STS     _A_LDFIM, R16
//  286 
//  287                     /* Write data to PH FIFO: 10 Bit ACK 0b1011 1011 10 */
//  288                     LDFD = 0xBBU;
        LDI     R16, 187
        OUT     0x19, R16
//  289                     LDFD = 0x80U;
        LDI     R16, 128
        RJMP    ??ATA_tpEmModeSingleTelProc_flash_C_9
//  290 
//  291                     /* Set NRZ encoding and bit length */
//  292                     TPECMR = 0xAAU;
//  293                     TPECR1 = 0x0AU;
//  294 
//  295                     /* Enable Transponder trasmit sequence */
//  296                     TPCR3 |= BM_TPTD;
//  297                 }
//  298                 else
//  299                 {
//  300                     /* Disable Transponder reception, since a response is required */
//  301                     TPCR3 &= ~ (BM_TPRD | BM_TPTLIW);
??ATA_tpEmModeSingleTelProc_flash_C_8:
        ANDI    R16, 0xF9
        STS     _A_TPCR3, R16
//  302 
//  303                     /* Send ACK, since parity bit is wrong */
//  304                     PHDFR  = 0x0AU;              /* data frame length 10 bit */
        LDI     R16, 10
        STS     _A_PHDFR, R16
//  305                     PHTBLR = 0x0AU;              /* telegram bit length 10 bit */
        STS     _A_PHTBLR, R16
//  306 
//  307                     LDFC = (BM_LDFMSB);  /* Set fill level configuration to 0 */
        LDI     R16, 64
        STS     _A_LDFC, R16
//  308                     LDFFL = 0x80U;       /* clear RdPtr, WrPtr, fill-level, status and bit length */
        LDI     R16, 128
        OUT     0x18, R16
//  309                     LDFIM = 0x00U;       /* disable interrupts */
        LDI     R16, 0
        STS     _A_LDFIM, R16
//  310 
//  311                     /* Write data to PH FIFO: 10 Bit NACK 0b1011 1011 01 */
//  312                     LDFD = 0xBBU;
        LDI     R16, 187
        OUT     0x19, R16
//  313                     LDFD = 0x40U;
        LDI     R16, 64
??ATA_tpEmModeSingleTelProc_flash_C_9:
        OUT     0x19, R16
//  314 
//  315                     /* Set NRZ encoding and bit length */
//  316                     TPECMR = 0xAAU;
        LDI     R16, 170
        STS     _A_TPECMR, R16
//  317                     TPECR1 = 0x0AU;
        LDI     R16, 10
        STS     _A_TPECR1, R16
//  318 
//  319                     /* Enable Transponder trasmit sequence */
//  320                     TPCR3 |= BM_TPTD;
??ATA_tpEmModeSingleTelProc_flash_C_6:
        LDS     R16, 369
        ORI     R16, 0x01
        STS     369, R16
//  321                 }
//  322             }
//  323             break;
//  324 
//  325         default:
//  326 
//  327           break;
//  328     }
//  329 
//  330     /**/
//  331     ATA_globalsSwitchAvrPhClock_flash_C((uint8_t)0x00U);
??ATA_tpEmModeSingleTelProc_flash_C_2:
        LDI     R16, 0
          CFI FunCall ATA_globalsSwitchAvrPhClock_flash_C
        CALL    ATA_globalsSwitchAvrPhClock_flash_C
//  332 }
        ADIW    R29:R28, 4
          CFI CFA_Y Y+0
        RET
          CFI EndBlock cfiBlock2
        REQUIRE _A_LDFD
        REQUIRE _A_TPCR3
        REQUIRE _A_PHDFR
        REQUIRE _A_PHTBLR
        REQUIRE _A_LDFC
        REQUIRE _A_LDFFL
        REQUIRE _A_LDFIM
        REQUIRE _A_TPECMR
        REQUIRE _A_TPECR1
//  333 
//  334 
//  335 
//  336 /*---------------------------------------------------------------------------*/
//  337 /** \brief <b>ATA_tpTimeoutError_flash_ISR_C</b>
//  338     shall handle Transponder errors.
//  339 
//  340     \return VOIDFUNC
//  341 
//  342     \Derived no
//  343 
//  344     \Rationale none
//  345 
//  346     \Traceability
//  347 
//  348     \StackUsage SU_XXX bytes
//  349 
//  350     \image html ATA_tpTimeoutError_flash_ISR_C.png
//  351     \image rtf ATA_tpTimeoutError_flash_ISR_C.png
//  352     \n
//  353 */
//  354 /*---------------------------------------------------------------------------*/
//  355 #pragma vector=TPTOERR_vect

        RSEG CODE:CODE:ROOT(1)
        CALL_GRAPH_ROOT ATA_tpTimeoutError_flash_ISR_C, "interrupt"
//  356 __interrupt VOIDFUNC ATA_tpTimeoutError_flash_ISR_C(void)
ATA_tpTimeoutError_flash_ISR_C:
          CFI Block cfiBlock3 Using cfiCommon1
          CFI Function ATA_tpTimeoutError_flash_ISR_C
//  357 {
        ST      -Y, R24
          CFI R24 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R31
          CFI R31 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        ST      -Y, R30
          CFI R30 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        ST      -Y, R3
          CFI R3 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        ST      -Y, R2
          CFI R2 Frame(CFA_Y, -5)
          CFI CFA_Y Y+5
        ST      -Y, R1
          CFI R1 Frame(CFA_Y, -6)
          CFI CFA_Y Y+6
        ST      -Y, R0
          CFI R0 Frame(CFA_Y, -7)
          CFI CFA_Y Y+7
        ST      -Y, R23
          CFI R23 Frame(CFA_Y, -8)
          CFI CFA_Y Y+8
        ST      -Y, R22
          CFI R22 Frame(CFA_Y, -9)
          CFI CFA_Y Y+9
        ST      -Y, R21
          CFI R21 Frame(CFA_Y, -10)
          CFI CFA_Y Y+10
        ST      -Y, R20
          CFI R20 Frame(CFA_Y, -11)
          CFI CFA_Y Y+11
        ST      -Y, R19
          CFI R19 Frame(CFA_Y, -12)
          CFI CFA_Y Y+12
        ST      -Y, R18
          CFI R18 Frame(CFA_Y, -13)
          CFI CFA_Y Y+13
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -14)
          CFI CFA_Y Y+14
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -15)
          CFI CFA_Y Y+15
        IN      R24, 0x3F
//  358     /* Check if a transponder bit error has been detected */
//  359     if ( (TPFR & BM_TPBERF) != 0x00U )
        SBIS    0x0D, 0x03
        RJMP    ??ATA_tpTimeoutError_flash_ISR_C_0
//  360     {
//  361         g_sTpRxTx.bTpFlags |= BM_LFRXCONFIG_TP_FLAGS_TPBERF;
        LDI     R30, LOW(g_sTpRxTx)
        LDI     R31, (g_sTpRxTx) >> 8
        LD      R16, Z
        ORI     R16, 0x08
        ST      Z, R16
//  362 
//  363         /* Do event pin handling */
//  364         if ( g_sEventHandling_flash.bTpRxTx & BM_LFRXCONFIG_TP_FLAGS_TPBERF )
        LDS     R16, (g_sEventHandling_flash + 8)
        SBRS    R16, 3
        RJMP    ??ATA_tpTimeoutError_flash_ISR_C_1
//  365         {
//  366             ATA_systemSetEventPin_flash_ASM();
          CFI FunCall ATA_systemSetEventPin_flash_ASM
        CALL    ATA_systemSetEventPin_flash_ASM
//  367         }
//  368 
//  369         /* Clear flag */
//  370         TPFR |= BM_TPBERF;
??ATA_tpTimeoutError_flash_ISR_C_1:
        SBI     0x0D, 0x03
//  371     }
//  372 
//  373     /* Check if a No field timeout has been detected */
//  374     if ( (TPFR & BM_TPNFTF) != 0x00U )
??ATA_tpTimeoutError_flash_ISR_C_0:
        SBIS    0x0D, 0x02
        RJMP    ??ATA_tpTimeoutError_flash_ISR_C_2
//  375     {
//  376         g_sTpRxTx.bTpFlags |= BM_LFRXCONFIG_TP_FLAGS_TPNFTF;
        LDI     R30, LOW(g_sTpRxTx)
        LDI     R31, (g_sTpRxTx) >> 8
        LD      R16, Z
        ORI     R16, 0x04
        ST      Z, R16
//  377 
//  378         /* Do event pin handling */
//  379         if ( g_sEventHandling_flash.bTpRxTx & BM_LFRXCONFIG_TP_FLAGS_TPNFTF )
        LDS     R16, (g_sEventHandling_flash + 8)
        SBRS    R16, 2
        RJMP    ??ATA_tpTimeoutError_flash_ISR_C_3
//  380         {
//  381             ATA_systemSetEventPin_flash_ASM();
          CFI FunCall ATA_systemSetEventPin_flash_ASM
        CALL    ATA_systemSetEventPin_flash_ASM
//  382         }
//  383 
//  384         /* Clear flag */
//  385         TPFR |= BM_TPNFTF;
??ATA_tpTimeoutError_flash_ISR_C_3:
        SBI     0x0D, 0x02
//  386     }
//  387 
//  388     /* Check if a field timeout has been detected */
//  389     if ( (TPFR & BM_TPFTF) != 0x00U )
??ATA_tpTimeoutError_flash_ISR_C_2:
        SBIS    0x0D, 0x01
        RJMP    ??ATA_tpTimeoutError_flash_ISR_C_4
//  390     {
//  391         g_sTpRxTx.bTpFlags |= BM_LFRXCONFIG_TP_FLAGS_TPFTF;
        LDI     R30, LOW(g_sTpRxTx)
        LDI     R31, (g_sTpRxTx) >> 8
        LD      R16, Z
        ORI     R16, 0x02
        ST      Z, R16
//  392 
//  393         /* Do event pin handling */
//  394         if ( g_sEventHandling_flash.bTpRxTx & BM_LFRXCONFIG_TP_FLAGS_TPFTF )
        LDS     R16, (g_sEventHandling_flash + 8)
        SBRS    R16, 1
        RJMP    ??ATA_tpTimeoutError_flash_ISR_C_5
//  395         {
//  396             ATA_systemSetEventPin_flash_ASM();
          CFI FunCall ATA_systemSetEventPin_flash_ASM
        CALL    ATA_systemSetEventPin_flash_ASM
//  397         }
//  398 
//  399         /* Clear flag */
//  400         TPFR |= BM_TPFTF;
??ATA_tpTimeoutError_flash_ISR_C_5:
        SBI     0x0D, 0x01
//  401     }
//  402 }
??ATA_tpTimeoutError_flash_ISR_C_4:
        OUT     0x3F, R24
        LD      R16, Y+
          CFI R16 SameValue
          CFI CFA_Y Y+14
        LD      R17, Y+
          CFI R17 SameValue
          CFI CFA_Y Y+13
        LD      R18, Y+
          CFI R18 SameValue
          CFI CFA_Y Y+12
        LD      R19, Y+
          CFI R19 SameValue
          CFI CFA_Y Y+11
        LD      R20, Y+
          CFI R20 SameValue
          CFI CFA_Y Y+10
        LD      R21, Y+
          CFI R21 SameValue
          CFI CFA_Y Y+9
        LD      R22, Y+
          CFI R22 SameValue
          CFI CFA_Y Y+8
        LD      R23, Y+
          CFI R23 SameValue
          CFI CFA_Y Y+7
        LD      R0, Y+
          CFI R0 SameValue
          CFI CFA_Y Y+6
        LD      R1, Y+
          CFI R1 SameValue
          CFI CFA_Y Y+5
        LD      R2, Y+
          CFI R2 SameValue
          CFI CFA_Y Y+4
        LD      R3, Y+
          CFI R3 SameValue
          CFI CFA_Y Y+3
        LD      R30, Y+
          CFI R30 SameValue
          CFI CFA_Y Y+2
        LD      R31, Y+
          CFI R31 SameValue
          CFI CFA_Y Y+1
        LD      R24, Y+
          CFI R24 SameValue
          CFI CFA_Y Y+0
        RETI
          CFI EndBlock cfiBlock3
        REQUIRE _A_TPFR
//  403 
//  404 /*---------------------------------------------------------------------------*/
//  405 /** \brief <b>ATA_tpRxTxInit_flash_C</b>
//  406     shall initialize the Transponder component data.
//  407 
//  408     \return VOIDFUNC
//  409 
//  410     \Derived no
//  411 
//  412     \Rationale none
//  413 
//  414     \Traceability
//  415 
//  416     \StackUsage SU_XXX bytes
//  417 
//  418     \image html ATA_tpRxTxInit_flash_C.png
//  419     \image rtf ATA_tpRxTxInit_flash_C.png
//  420     \n
//  421 */
//  422 /*---------------------------------------------------------------------------*/

        RSEG CODE:CODE:ROOT(1)
//  423 VOIDFUNC ATA_tpRxTxInit_flash_C(void)
ATA_tpRxTxInit_flash_C:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function ATA_tpRxTxInit_flash_C
          CFI NoCalls
//  424 {
//  425     g_sTpRxTx.bTpFlags = 0x00U;
        LDI     R16, 0
        STS     g_sTpRxTx, R16
//  426     g_sTpRxTx.bStatus = 0x00U;
        STS     (g_sTpRxTx + 1), R16
//  427     g_sTpRxTx.bConfig = 0x00U;
        STS     (g_sTpRxTx + 2), R16
//  428 
//  429     /* EM Transponder Mode */
//  430     g_bTpEmTransponderModeCommand_flash = 0x00U;
        STS     g_bTpEmTransponderModeCommand_flash, R16
//  431     g_bTpEmTransponderStateIndex_flash = EM_MODE_STATE_INIT;
        STS     g_bTpEmTransponderStateIndex_flash, R16
//  432     g_fTpEmTransponderModeErrorFlag_flash = 0x00U;
        STS     g_fTpEmTransponderModeErrorFlag_flash, R16
//  433 }
        RET
          CFI EndBlock cfiBlock4

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 128
`??ATA_tpTimeoutError_flash_ISR_C::??INTVEC 128`:
        JMP     ATA_tpTimeoutError_flash_ISR_C

        END
// 
//   7 bytes in segment .sram_FlashApp_TpRxTx
//  17 bytes in segment ABSOLUTE
// 594 bytes in segment CODE
//   4 bytes in segment INTVEC
// 
// 594 bytes of CODE memory (+  4 bytes shared)
//   7 bytes of DATA memory (+ 17 bytes shared)
//
//Errors: none
//Warnings: none
